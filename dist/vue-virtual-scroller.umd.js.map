{"version":3,"file":"vue-virtual-scroller.umd.js","sources":["../src/config.js","../../vue-resize/dist/vue-resize.esm.js","../../vue-observe-visibility/dist/vue-observe-visibility.esm.js","../node_modules/scrollparent/scrollparent.js","../src/components/common.js","../src/utils.js","../src/components/RecycleScroller.vue","../src/components/RecycleScroller.vue?vue&type=template&id=093a936d&lang.js","../src/components/DynamicScroller.vue","../src/components/DynamicScroller.vue?vue&type=template&id=76e15f19&lang.js","../src/components/DynamicScrollerItem.vue","../src/mixins/IdState.js","../src/index.js"],"sourcesContent":["export default {\r\n  itemsLimit: 1000,\r\n}\r\n","/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            res += normalizeClass(value[i]) + ' ';\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst NOOP = () => { };\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if ((process.env.NODE_ENV !== 'production') && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key)\r\n            ? builtInSymbols.has(key)\r\n            : key === `__proto__` || key === `__v_isRef`) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    target.add(value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    pauseTracking();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    resetTracking();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (isString(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (isRef(value)) {\r\n        value = formatProp(key, toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (isFunction(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n    [\"c\" /* CREATED */]: 'created hook',\r\n    [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n    [\"m\" /* MOUNTED */]: 'mounted hook',\r\n    [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n    [\"u\" /* UPDATED */]: 'updated',\r\n    [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n    [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n    [\"a\" /* ACTIVATED */]: 'activated hook',\r\n    [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n    [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n    [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n    [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n    [0 /* SETUP_FUNCTION */]: 'setup function',\r\n    [1 /* RENDER_FUNCTION */]: 'render function',\r\n    [2 /* WATCH_GETTER */]: 'watcher getter',\r\n    [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n    [7 /* VNODE_HOOK */]: 'vnode hook',\r\n    [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n    [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n    [12 /* FUNCTION_REF */]: 'ref function',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (isFunction(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && isPromise(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = (process.env.NODE_ENV !== 'production') ? ErrorTypeStrings[type] : type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const info = ErrorTypeStrings[type];\r\n        if (contextVNode) {\r\n            pushWarningContext(contextVNode);\r\n        }\r\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\r\n        if (contextVNode) {\r\n            popWarningContext();\r\n        }\r\n        // crash in dev by default so it's more noticeable\r\n        if (throwInDev) {\r\n            throw err;\r\n        }\r\n        else {\r\n            console.error(err);\r\n        }\r\n    }\r\n    else {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        queue.push(job);\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!isArray(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex]);\r\n            }\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex]);\r\n            }\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        seen = seen || new Map();\r\n    }\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkRecursiveUpdates(seen, job);\r\n                }\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length || pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            throw new Error(`Maximum recursive updates exceeded. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\nconst hmrDirtyComponents = new Set();\r\n// Expose the HMR runtime on the global object\r\n// This makes it entirely tree-shakable without polluting the exports and makes\r\n// it easier to be used in toolings like vue-loader\r\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n// to be set so that its instances can be registered / removed.\r\nif ((process.env.NODE_ENV !== 'production')) {\r\n    const globalObject = typeof global !== 'undefined'\r\n        ? global\r\n        : typeof self !== 'undefined'\r\n            ? self\r\n            : typeof window !== 'undefined'\r\n                ? window\r\n                : {};\r\n    globalObject.__VUE_HMR_RUNTIME__ = {\r\n        createRecord: tryWrap(createRecord),\r\n        rerender: tryWrap(rerender),\r\n        reload: tryWrap(reload)\r\n    };\r\n}\r\nconst map = new Map();\r\nfunction createRecord(id, component) {\r\n    if (!component) {\r\n        warn(`HMR API usage is out of date.\\n` +\r\n            `Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ` +\r\n            `depdendency that handles Vue SFC compilation.`);\r\n        component = {};\r\n    }\r\n    if (map.has(id)) {\r\n        return false;\r\n    }\r\n    map.set(id, {\r\n        component: isClassComponent(component) ? component.__vccOpts : component,\r\n        instances: new Set()\r\n    });\r\n    return true;\r\n}\r\nfunction rerender(id, newRender) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    if (newRender)\r\n        record.component.render = newRender;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    Array.from(record.instances).forEach(instance => {\r\n        if (newRender) {\r\n            instance.render = newRender;\r\n        }\r\n        instance.renderCache = [];\r\n        instance.update();\r\n    });\r\n}\r\nfunction reload(id, newComp) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    const { component, instances } = record;\r\n    if (!hmrDirtyComponents.has(component)) {\r\n        // 1. Update existing comp definition to match new one\r\n        newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;\r\n        extend(component, newComp);\r\n        for (const key in component) {\r\n            if (!(key in newComp)) {\r\n                delete component[key];\r\n            }\r\n        }\r\n        // 2. Mark component dirty. This forces the renderer to replace the component\r\n        // on patch.\r\n        hmrDirtyComponents.add(component);\r\n        // 3. Make sure to unmark the component after the reload.\r\n        queuePostFlushCb(() => {\r\n            hmrDirtyComponents.delete(component);\r\n        });\r\n    }\r\n    Array.from(instances).forEach(instance => {\r\n        if (instance.parent) {\r\n            // 4. Force the parent instance to re-render. This will cause all updated\r\n            // components to be unmounted and re-mounted. Queue the update so that we\r\n            // don't end up forcing the same parent to re-render multiple times.\r\n            queueJob(instance.parent.update);\r\n        }\r\n        else if (instance.appContext.reload) {\r\n            // root instance mounted via createApp() has a reload method\r\n            instance.appContext.reload();\r\n        }\r\n        else if (typeof window !== 'undefined') {\r\n            // root instance inside tree created via raw render(). Force reload.\r\n            window.location.reload();\r\n        }\r\n        else {\r\n            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\r\n        }\r\n    });\r\n}\r\nfunction tryWrap(fn) {\r\n    return (id, arg) => {\r\n        try {\r\n            return fn(id, arg);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\r\n                `Full reload required.`);\r\n        }\r\n    };\r\n}\nfunction setDevtoolsHook(hook) {\r\n}\r\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nfunction setCurrentRenderingInstance(instance) {\r\n    currentRenderingInstance = instance;\r\n}\r\nfunction markAttrsAccessed() {\r\n}\r\nfunction filterSingleRoot(children) {\r\n    let singleRoot;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (isVNode(child)) {\r\n            // ignore user comment\r\n            if (child.type !== Comment || child.children === 'v-if') {\r\n                if (singleRoot) {\r\n                    // has more than 1 non-comment child, return now\r\n                    return;\r\n                }\r\n                else {\r\n                    singleRoot = child;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    return singleRoot;\r\n}\r\n\nconst isSuspense = (type) => type.__isSuspense;\r\nfunction normalizeSuspenseChildren(vnode) {\r\n    const { shapeFlag, children } = vnode;\r\n    let content;\r\n    let fallback;\r\n    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        content = normalizeSuspenseSlot(children.default);\r\n        fallback = normalizeSuspenseSlot(children.fallback);\r\n    }\r\n    else {\r\n        content = normalizeSuspenseSlot(children);\r\n        fallback = normalizeVNode(null);\r\n    }\r\n    return {\r\n        content,\r\n        fallback\r\n    };\r\n}\r\nfunction normalizeSuspenseSlot(s) {\r\n    if (isFunction(s)) {\r\n        s = s();\r\n    }\r\n    if (isArray(s)) {\r\n        const singleChild = filterSingleRoot(s);\r\n        if ((process.env.NODE_ENV !== 'production') && !singleChild) {\r\n            warn(`<Suspense> slots expect a single root node.`);\r\n        }\r\n        s = singleChild;\r\n    }\r\n    return normalizeVNode(s);\r\n}\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if (isArray(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\n\nlet isRenderingCompiledSlot = 0;\r\nconst setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);\r\n\n/**\r\n * Wrap a slot function to memoize current rendering instance\r\n * @private\r\n */\r\nfunction withCtx(fn, ctx = currentRenderingInstance) {\r\n    if (!ctx)\r\n        return fn;\r\n    const renderFnWithContext = (...args) => {\r\n        // If a user calls a compiled slot inside a template expression (#1745), it\r\n        // can mess up block tracking, so by default we need to push a null block to\r\n        // avoid that. This isn't necessary if rendering a compiled `<slot>`.\r\n        if (!isRenderingCompiledSlot) {\r\n            openBlock(true /* null block that disables tracking */);\r\n        }\r\n        const owner = currentRenderingInstance;\r\n        setCurrentRenderingInstance(ctx);\r\n        const res = fn(...args);\r\n        setCurrentRenderingInstance(owner);\r\n        if (!isRenderingCompiledSlot) {\r\n            closeBlock();\r\n        }\r\n        return res;\r\n    };\r\n    renderFnWithContext._c = true;\r\n    return renderFnWithContext;\r\n}\n\n// SFC scoped style ID management.\r\nlet currentScopeId = null;\r\nconst scopeIdStack = [];\r\n/**\r\n * @private\r\n */\r\nfunction pushScopeId(id) {\r\n    scopeIdStack.push((currentScopeId = id));\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction popScopeId() {\r\n    scopeIdStack.pop();\r\n    currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction withScopeId(id) {\r\n    return ((fn) => withCtx(function () {\r\n        pushScopeId(id);\r\n        const res = fn.apply(this, arguments);\r\n        popScopeId();\r\n        return res;\r\n    }));\r\n}\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ, instance = currentInstance) {\r\n    if ((process.env.NODE_ENV !== 'production') && !cb) {\r\n        if (immediate !== undefined) {\r\n            warn(`watch() \"immediate\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n        if (deep !== undefined) {\r\n            warn(`watch() \"deep\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n    }\r\n    const warnInvalidSource = (s) => {\r\n        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n            `a reactive object, or an array of these types.`);\r\n    };\r\n    let getter;\r\n    let forceTrigger = false;\r\n    if (isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = !!source._shallow;\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        getter = () => source.map(s => {\r\n            if (isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (isFunction(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);\r\n            }\r\n            else {\r\n                (process.env.NODE_ENV !== 'production') && warnInvalidSource(s);\r\n            }\r\n        });\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = NOOP;\r\n        (process.env.NODE_ENV !== 'production') && warnInvalidSource(source);\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    const onInvalidate = (fn) => {\r\n        cleanup = runner.options.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!runner.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = runner();\r\n            if (deep || forceTrigger || hasChanged(newValue, oldValue)) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onInvalidate\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            runner();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = job;\r\n    }\r\n    else if (flush === 'post') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: 'pre'\r\n        scheduler = () => {\r\n            if (!instance || instance.isMounted) {\r\n                queuePreFlushCb(job);\r\n            }\r\n            else {\r\n                // with 'pre' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    const runner = effect(getter, {\r\n        lazy: true,\r\n        onTrack,\r\n        onTrigger,\r\n        scheduler\r\n    });\r\n    recordInstanceBoundEffect(runner, instance);\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = runner();\r\n        }\r\n    }\r\n    else if (flush === 'post') {\r\n        queuePostRenderEffect(runner, instance && instance.suspense);\r\n    }\r\n    else {\r\n        runner();\r\n    }\r\n    return () => {\r\n        stop(runner);\r\n        if (instance) {\r\n            remove(instance.effects, runner);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, cb, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = isString(source)\r\n        ? () => publicThis[source]\r\n        : source.bind(publicThis);\r\n    return doWatch(getter, cb.bind(publicThis), options, this);\r\n}\r\nfunction traverse(value, seen = new Set()) {\r\n    if (!isObject(value) || seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (isSet(value) || isMap(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\nconst queuePostRenderEffect =  queueEffectWithSuspense\r\n    ;\r\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n\nconst Fragment = Symbol((process.env.NODE_ENV !== 'production') ? 'Fragment' : undefined);\r\nconst Text = Symbol((process.env.NODE_ENV !== 'production') ? 'Text' : undefined);\r\nconst Comment = Symbol((process.env.NODE_ENV !== 'production') ? 'Comment' : undefined);\r\nconst Static = Symbol((process.env.NODE_ENV !== 'production') ? 'Static' : undefined);\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nconst blockStack = [];\r\nlet currentBlock = null;\r\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock('div', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\r\nfunction openBlock(disableTracking = false) {\r\n    blockStack.push((currentBlock = disableTracking ? null : []));\r\n}\r\nfunction closeBlock() {\r\n    blockStack.pop();\r\n    currentBlock = blockStack[blockStack.length - 1] || null;\r\n}\r\n/**\r\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n * A block root keeps track of dynamic nodes within the block in the\r\n * `dynamicChildren` array.\r\n *\r\n * @private\r\n */\r\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\r\n    const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */);\r\n    // save current block children on the block vnode\r\n    vnode.dynamicChildren = currentBlock || EMPTY_ARR;\r\n    // close block\r\n    closeBlock();\r\n    // a block is always going to be patched, so track it as a child of its\r\n    // parent block\r\n    if ( currentBlock) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nconst createVNodeWithArgsTransform = (...args) => {\r\n    return _createVNode(...( args));\r\n};\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref }) => {\r\n    return (ref != null\r\n        ? isString(ref) || isRef(ref) || isFunction(ref)\r\n            ? { i: currentRenderingInstance, r: ref }\r\n            : ref\r\n        : null);\r\n};\r\nconst createVNode = ((process.env.NODE_ENV !== 'production')\r\n    ? createVNodeWithArgsTransform\r\n    : _createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        if ((process.env.NODE_ENV !== 'production') && !type) {\r\n            warn(`Invalid vnode type when creating vnode: ${type}.`);\r\n        }\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is=\"vnode\"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        if (isProxy(props) || InternalObjectKey in props) {\r\n            props = extend({}, props);\r\n        }\r\n        let { class: klass, style } = props;\r\n        if (klass && !isString(klass)) {\r\n            props.class = normalizeClass(klass);\r\n        }\r\n        if (isObject(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isProxy(style) && !isArray(style)) {\r\n                style = extend({}, style);\r\n            }\r\n            props.style = normalizeStyle(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = isString(type)\r\n        ? 1 /* ELEMENT */\r\n        :  isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : isObject(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : isFunction(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    if ((process.env.NODE_ENV !== 'production') && shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {\r\n        type = toRaw(type);\r\n        warn(`Vue received a Component which was made a reactive object. This can ` +\r\n            `lead to unnecessary performance overhead, and should be avoided by ` +\r\n            `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\r\n            `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\r\n    }\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        children: null,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    // validate key\r\n    if ((process.env.NODE_ENV !== 'production') && vnode.key !== vnode.key) {\r\n        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\r\n    }\r\n    normalizeChildren(vnode, children);\r\n    // normalize suspense children\r\n    if ( shapeFlag & 128 /* SUSPENSE */) {\r\n        const { content, fallback } = normalizeSuspenseChildren(vnode);\r\n        vnode.ssContent = content;\r\n        vnode.ssFallback = fallback;\r\n    }\r\n    if (\r\n        // avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn't need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    return {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? isArray(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        children: vnode.children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: perserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn't affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\nfunction normalizeVNode(child) {\r\n    if (child == null || typeof child === 'boolean') {\r\n        // empty placeholder\r\n        return createVNode(Comment);\r\n    }\r\n    else if (isArray(child)) {\r\n        // fragment\r\n        return createVNode(Fragment, null, child);\r\n    }\r\n    else if (typeof child === 'object') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return child.el === null ? child : cloneVNode(child);\r\n    }\r\n    else {\r\n        // strings and numbers\r\n        return createVNode(Text, null, String(child));\r\n    }\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (isArray(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && setCompiledSlotRendering(1);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && setCompiledSlotRendering(-1);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent's slot type.\r\n                if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n                else {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (isFunction(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = extend({}, args[0]);\r\n    for (let i = 1; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = normalizeClass([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = normalizeStyle([ret.style, toMerge.style]);\r\n            }\r\n            else if (isOn(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (existing !== incoming) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, toMerge[key])\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== '') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\nlet isInBeforeCreate = false;\r\nfunction resolveMergedOptions(instance) {\r\n    const raw = instance.type;\r\n    const { __merged, mixins, extends: extendsOptions } = raw;\r\n    if (__merged)\r\n        return __merged;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (!globalMixins.length && !mixins && !extendsOptions)\r\n        return raw;\r\n    const options = {};\r\n    globalMixins.forEach(m => mergeOptions(options, m, instance));\r\n    mergeOptions(options, raw, instance);\r\n    return (raw.__merged = options);\r\n}\r\nfunction mergeOptions(to, from, instance) {\r\n    const strats = instance.appContext.config.optionMergeStrategies;\r\n    const { mixins, extends: extendsOptions } = from;\r\n    extendsOptions && mergeOptions(to, extendsOptions, instance);\r\n    mixins &&\r\n        mixins.forEach((m) => mergeOptions(to, m, instance));\r\n    for (const key in from) {\r\n        if (strats && hasOwn(strats, key)) {\r\n            to[key] = strats[key](to[key], from[key], instance.proxy, key);\r\n        }\r\n        else {\r\n            to[key] = from[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => i && (i.proxy ? i.proxy : getPublicInstance(i.parent));\r\nconst publicPropertiesMap = extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.props) : i.props),\r\n    $attrs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.attrs) : i.attrs),\r\n    $slots: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.slots) : i.slots),\r\n    $refs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.refs) : i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => i.root && i.root.proxy,\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => () => queueJob(i.update),\r\n    $nextTick: i => nextTick.bind(i.proxy),\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)\r\n});\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // let @vue/reactivity know it should never observe Vue public instances.\r\n        if (key === \"__v_skip\" /* SKIP */) {\r\n            return true;\r\n        }\r\n        // for internal formatters to know that this is a Vue instance\r\n        if ((process.env.NODE_ENV !== 'production') && key === '__isVue') {\r\n            return true;\r\n        }\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== '$') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 0 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 1 /* DATA */:\r\n                        return data[key];\r\n                    case 3 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 2 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n                accessCache[key] = 0 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n                accessCache[key] = 1 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                hasOwn(normalizedProps, key)) {\r\n                accessCache[key] = 2 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n                accessCache[key] = 3 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (!__VUE_OPTIONS_API__ || !isInBeforeCreate) {\r\n                accessCache[key] = 4 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === '$attrs') {\r\n                track(instance, \"get\" /* GET */, key);\r\n                (process.env.NODE_ENV !== 'production') && markAttrsAccessed();\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 3 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // global properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            hasOwn(globalProperties, key))) {\r\n            return globalProperties[key];\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production') &&\r\n            currentRenderingInstance &&\r\n            (!isString(key) ||\r\n                // #1091 avoid internal isRef/isVNode checks on component instance leading\r\n                // to infinite warning loop\r\n                key.indexOf('__v') !== 0)) {\r\n            if (data !== EMPTY_OBJ &&\r\n                (key[0] === '$' || key[0] === '_') &&\r\n                hasOwn(data, key)) {\r\n                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +\r\n                    `character (\"$\" or \"_\") and is not proxied on the render context.`);\r\n            }\r\n            else {\r\n                warn(`Property ${JSON.stringify(key)} was accessed during render ` +\r\n                    `but is not defined on instance.`);\r\n            }\r\n        }\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n            setupState[key] = value;\r\n        }\r\n        else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n            data[key] = value;\r\n        }\r\n        else if (key in instance.props) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate prop \"${key}\". Props are readonly.`, instance);\r\n            return false;\r\n        }\r\n        if (key[0] === '$' && key.slice(1) in instance) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate public property \"${key}\". ` +\r\n                    `Properties starting with $ are reserved and readonly.`, instance);\r\n            return false;\r\n        }\r\n        else {\r\n            if ((process.env.NODE_ENV !== 'production') && key in instance.appContext.config.globalProperties) {\r\n                Object.defineProperty(ctx, key, {\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    value\r\n                });\r\n            }\r\n            else {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (accessCache[key] !== undefined ||\r\n            (data !== EMPTY_OBJ && hasOwn(data, key)) ||\r\n            (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\r\n            hasOwn(ctx, key) ||\r\n            hasOwn(publicPropertiesMap, key) ||\r\n            hasOwn(appContext.config.globalProperties, key));\r\n    }\r\n};\r\nif ((process.env.NODE_ENV !== 'production') && !false) {\r\n    PublicInstanceProxyHandlers.ownKeys = (target) => {\r\n        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +\r\n            `The keys will be empty in production mode to avoid performance overhead.`);\r\n        return Reflect.ownKeys(target);\r\n    };\r\n}\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== '_' && !isGloballyWhitelisted(key);\r\n        if ((process.env.NODE_ENV !== 'production') && !has && PublicInstanceProxyHandlers.has(_, key)) {\r\n            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\r\n        }\r\n        return has;\r\n    }\r\n});\r\nlet currentInstance = null;\r\n// record effects created during a component's setup() so that they can be\r\n// stopped when the component unmounts\r\nfunction recordInstanceBoundEffect(effect, instance = currentInstance) {\r\n    if (instance) {\r\n        (instance.effects || (instance.effects = [])).push(effect);\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = isFunction(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return isFunction(value) && '__vccOpts' in value;\r\n}\n\nconst ssrContextKey = Symbol((process.env.NODE_ENV !== 'production') ? `ssrContext` : ``);\r\n\nfunction initCustomFormatter() {\r\n    /* eslint-disable no-restricted-globals */\r\n    if (!(process.env.NODE_ENV !== 'production') || typeof window === 'undefined') {\r\n        return;\r\n    }\r\n    const vueStyle = { style: 'color:#3ba776' };\r\n    const numberStyle = { style: 'color:#0b1bc9' };\r\n    const stringStyle = { style: 'color:#b62e24' };\r\n    const keywordStyle = { style: 'color:#9d288c' };\r\n    // custom formatter for Chrome\r\n    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n    const formatter = {\r\n        header(obj) {\r\n            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n            if (!isObject(obj)) {\r\n                return null;\r\n            }\r\n            if (obj.__isVue) {\r\n                return ['div', vueStyle, `VueInstance`];\r\n            }\r\n            else if (isRef(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, genRefFlag(obj)],\r\n                    '<',\r\n                    formatValue(obj.value),\r\n                    `>`\r\n                ];\r\n            }\r\n            else if (isReactive(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Reactive'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    `>${isReadonly(obj) ? ` (readonly)` : ``}`\r\n                ];\r\n            }\r\n            else if (isReadonly(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Readonly'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    '>'\r\n                ];\r\n            }\r\n            return null;\r\n        },\r\n        hasBody(obj) {\r\n            return obj && obj.__isVue;\r\n        },\r\n        body(obj) {\r\n            if (obj && obj.__isVue) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ...formatInstance(obj.$)\r\n                ];\r\n            }\r\n        }\r\n    };\r\n    function formatInstance(instance) {\r\n        const blocks = [];\r\n        if (instance.type.props && instance.props) {\r\n            blocks.push(createInstanceBlock('props', toRaw(instance.props)));\r\n        }\r\n        if (instance.setupState !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('setup', instance.setupState));\r\n        }\r\n        if (instance.data !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('data', toRaw(instance.data)));\r\n        }\r\n        const computed = extractKeys(instance, 'computed');\r\n        if (computed) {\r\n            blocks.push(createInstanceBlock('computed', computed));\r\n        }\r\n        const injected = extractKeys(instance, 'inject');\r\n        if (injected) {\r\n            blocks.push(createInstanceBlock('injected', injected));\r\n        }\r\n        blocks.push([\r\n            'div',\r\n            {},\r\n            [\r\n                'span',\r\n                {\r\n                    style: keywordStyle.style + ';opacity:0.66'\r\n                },\r\n                '$ (internal): '\r\n            ],\r\n            ['object', { object: instance }]\r\n        ]);\r\n        return blocks;\r\n    }\r\n    function createInstanceBlock(type, target) {\r\n        target = extend({}, target);\r\n        if (!Object.keys(target).length) {\r\n            return ['span', {}];\r\n        }\r\n        return [\r\n            'div',\r\n            { style: 'line-height:1.25em;margin-bottom:0.6em' },\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'color:#476582'\r\n                },\r\n                type\r\n            ],\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'padding-left:1.25em'\r\n                },\r\n                ...Object.keys(target).map(key => {\r\n                    return [\r\n                        'div',\r\n                        {},\r\n                        ['span', keywordStyle, key + ': '],\r\n                        formatValue(target[key], false)\r\n                    ];\r\n                })\r\n            ]\r\n        ];\r\n    }\r\n    function formatValue(v, asRaw = true) {\r\n        if (typeof v === 'number') {\r\n            return ['span', numberStyle, v];\r\n        }\r\n        else if (typeof v === 'string') {\r\n            return ['span', stringStyle, JSON.stringify(v)];\r\n        }\r\n        else if (typeof v === 'boolean') {\r\n            return ['span', keywordStyle, v];\r\n        }\r\n        else if (isObject(v)) {\r\n            return ['object', { object: asRaw ? toRaw(v) : v }];\r\n        }\r\n        else {\r\n            return ['span', stringStyle, String(v)];\r\n        }\r\n    }\r\n    function extractKeys(instance, type) {\r\n        const Comp = instance.type;\r\n        if (isFunction(Comp)) {\r\n            return;\r\n        }\r\n        const extracted = {};\r\n        for (const key in instance.ctx) {\r\n            if (isKeyOfType(Comp, key, type)) {\r\n                extracted[key] = instance.ctx[key];\r\n            }\r\n        }\r\n        return extracted;\r\n    }\r\n    function isKeyOfType(Comp, key, type) {\r\n        const opts = Comp[type];\r\n        if ((isArray(opts) && opts.includes(key)) ||\r\n            (isObject(opts) && key in opts)) {\r\n            return true;\r\n        }\r\n        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n            return true;\r\n        }\r\n        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n            return true;\r\n        }\r\n    }\r\n    function genRefFlag(v) {\r\n        if (v._shallow) {\r\n            return `ShallowRef`;\r\n        }\r\n        if (v.effect) {\r\n            return `ComputedRef`;\r\n        }\r\n        return `Ref`;\r\n    }\r\n    if (window.devtoolsFormatters) {\r\n        window.devtoolsFormatters.push(formatter);\r\n    }\r\n    else {\r\n        window.devtoolsFormatters = [formatter];\r\n    }\r\n}\n\nfunction initDev() {\r\n    const target = getGlobalThis();\r\n    target.__VUE__ = true;\r\n    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);\r\n    {\r\n        initCustomFormatter();\r\n    }\r\n}\n\n// This entry exports the runtime only, and is built as\r\n(process.env.NODE_ENV !== 'production') && initDev();\n\nfunction getInternetExplorerVersion() {\n  var ua = window.navigator.userAgent;\n  var msie = ua.indexOf('MSIE ');\n\n  if (msie > 0) {\n    // IE 10 or older => return version number\n    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n  }\n\n  var trident = ua.indexOf('Trident/');\n\n  if (trident > 0) {\n    // IE 11 => return version number\n    var rv = ua.indexOf('rv:');\n    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n  }\n\n  var edge = ua.indexOf('Edge/');\n\n  if (edge > 0) {\n    // Edge (IE 12+) => return version number\n    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n  } // other browser\n\n\n  return -1;\n}\n\nvar isIE;\n\nfunction initCompat() {\n  if (!initCompat.init) {\n    initCompat.init = true;\n    isIE = getInternetExplorerVersion() !== -1;\n  }\n}\n\nvar script = {\n  name: 'ResizeObserver',\n  mounted: function mounted() {\n    var _this = this;\n\n    initCompat();\n    nextTick(function () {\n      _this._w = _this.$el.offsetWidth;\n      _this._h = _this.$el.offsetHeight;\n    });\n    var object = document.createElement('object');\n    this._resizeObject = object;\n    object.setAttribute('aria-hidden', 'true');\n    object.setAttribute('tabindex', -1);\n    object.onload = this.addResizeHandlers;\n    object.type = 'text/html';\n\n    if (isIE) {\n      this.$el.appendChild(object);\n    }\n\n    object.data = 'about:blank';\n\n    if (!isIE) {\n      this.$el.appendChild(object);\n    }\n  },\n  beforeUnmount: function beforeUnmount() {\n    this.removeResizeHandlers();\n  },\n  methods: {\n    compareAndNotify: function compareAndNotify() {\n      if (this._w !== this.$el.offsetWidth || this._h !== this.$el.offsetHeight) {\n        this._w = this.$el.offsetWidth;\n        this._h = this.$el.offsetHeight;\n        this.$emit('notify', {\n          width: this._w,\n          height: this._h\n        });\n      }\n    },\n    addResizeHandlers: function addResizeHandlers() {\n      this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify);\n\n      this.compareAndNotify();\n    },\n    removeResizeHandlers: function removeResizeHandlers() {\n      if (this._resizeObject && this._resizeObject.onload) {\n        if (!isIE && this._resizeObject.contentDocument) {\n          this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify);\n        }\n\n        this.$el.removeChild(this._resizeObject);\n        this._resizeObject.onload = null;\n        this._resizeObject = null;\n      }\n    }\n  }\n};\n\nvar _withId = /*#__PURE__*/withScopeId(\"data-v-b329ee4c\");\n\npushScopeId(\"data-v-b329ee4c\");\n\nvar _hoisted_1 = {\n  class: \"resize-observer\",\n  tabindex: \"-1\"\n};\n\npopScopeId();\n\nvar render = /*#__PURE__*/_withId(function (_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createBlock(\"div\", _hoisted_1);\n});\n\nscript.render = render;\nscript.__scopeId = \"data-v-b329ee4c\";\nscript.__file = \"src/components/ResizeObserver.vue\";\n\nfunction install(Vue) {\n  Vue.component('resize-observer', script);\n  Vue.component('ResizeObserver', script);\n}\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"0.5.0\",\n  install: install\n};\n\nvar GlobalVue = null;\n\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\n\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n\nexport default plugin;\nexport { script as ResizeObserver, install };\n//# sourceMappingURL=vue-resize.esm.js.map\n","function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            res += normalizeClass(value[i]) + ' ';\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst NOOP = () => { };\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if ((process.env.NODE_ENV !== 'production') && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key)\r\n            ? builtInSymbols.has(key)\r\n            : key === `__proto__` || key === `__v_isRef`) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    target.add(value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    pauseTracking();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    resetTracking();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (isString(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (isRef(value)) {\r\n        value = formatProp(key, toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (isFunction(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n    [\"c\" /* CREATED */]: 'created hook',\r\n    [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n    [\"m\" /* MOUNTED */]: 'mounted hook',\r\n    [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n    [\"u\" /* UPDATED */]: 'updated',\r\n    [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n    [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n    [\"a\" /* ACTIVATED */]: 'activated hook',\r\n    [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n    [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n    [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n    [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n    [0 /* SETUP_FUNCTION */]: 'setup function',\r\n    [1 /* RENDER_FUNCTION */]: 'render function',\r\n    [2 /* WATCH_GETTER */]: 'watcher getter',\r\n    [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n    [7 /* VNODE_HOOK */]: 'vnode hook',\r\n    [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n    [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n    [12 /* FUNCTION_REF */]: 'ref function',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (isFunction(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && isPromise(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = (process.env.NODE_ENV !== 'production') ? ErrorTypeStrings[type] : type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const info = ErrorTypeStrings[type];\r\n        if (contextVNode) {\r\n            pushWarningContext(contextVNode);\r\n        }\r\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\r\n        if (contextVNode) {\r\n            popWarningContext();\r\n        }\r\n        // crash in dev by default so it's more noticeable\r\n        if (throwInDev) {\r\n            throw err;\r\n        }\r\n        else {\r\n            console.error(err);\r\n        }\r\n    }\r\n    else {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        queue.push(job);\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!isArray(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex]);\r\n            }\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex]);\r\n            }\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        seen = seen || new Map();\r\n    }\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkRecursiveUpdates(seen, job);\r\n                }\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length || pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            throw new Error(`Maximum recursive updates exceeded. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\nconst hmrDirtyComponents = new Set();\r\n// Expose the HMR runtime on the global object\r\n// This makes it entirely tree-shakable without polluting the exports and makes\r\n// it easier to be used in toolings like vue-loader\r\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n// to be set so that its instances can be registered / removed.\r\nif ((process.env.NODE_ENV !== 'production')) {\r\n    const globalObject = typeof global !== 'undefined'\r\n        ? global\r\n        : typeof self !== 'undefined'\r\n            ? self\r\n            : typeof window !== 'undefined'\r\n                ? window\r\n                : {};\r\n    globalObject.__VUE_HMR_RUNTIME__ = {\r\n        createRecord: tryWrap(createRecord),\r\n        rerender: tryWrap(rerender),\r\n        reload: tryWrap(reload)\r\n    };\r\n}\r\nconst map = new Map();\r\nfunction createRecord(id, component) {\r\n    if (!component) {\r\n        warn(`HMR API usage is out of date.\\n` +\r\n            `Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ` +\r\n            `depdendency that handles Vue SFC compilation.`);\r\n        component = {};\r\n    }\r\n    if (map.has(id)) {\r\n        return false;\r\n    }\r\n    map.set(id, {\r\n        component: isClassComponent(component) ? component.__vccOpts : component,\r\n        instances: new Set()\r\n    });\r\n    return true;\r\n}\r\nfunction rerender(id, newRender) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    if (newRender)\r\n        record.component.render = newRender;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    Array.from(record.instances).forEach(instance => {\r\n        if (newRender) {\r\n            instance.render = newRender;\r\n        }\r\n        instance.renderCache = [];\r\n        instance.update();\r\n    });\r\n}\r\nfunction reload(id, newComp) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    const { component, instances } = record;\r\n    if (!hmrDirtyComponents.has(component)) {\r\n        // 1. Update existing comp definition to match new one\r\n        newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;\r\n        extend(component, newComp);\r\n        for (const key in component) {\r\n            if (!(key in newComp)) {\r\n                delete component[key];\r\n            }\r\n        }\r\n        // 2. Mark component dirty. This forces the renderer to replace the component\r\n        // on patch.\r\n        hmrDirtyComponents.add(component);\r\n        // 3. Make sure to unmark the component after the reload.\r\n        queuePostFlushCb(() => {\r\n            hmrDirtyComponents.delete(component);\r\n        });\r\n    }\r\n    Array.from(instances).forEach(instance => {\r\n        if (instance.parent) {\r\n            // 4. Force the parent instance to re-render. This will cause all updated\r\n            // components to be unmounted and re-mounted. Queue the update so that we\r\n            // don't end up forcing the same parent to re-render multiple times.\r\n            queueJob(instance.parent.update);\r\n        }\r\n        else if (instance.appContext.reload) {\r\n            // root instance mounted via createApp() has a reload method\r\n            instance.appContext.reload();\r\n        }\r\n        else if (typeof window !== 'undefined') {\r\n            // root instance inside tree created via raw render(). Force reload.\r\n            window.location.reload();\r\n        }\r\n        else {\r\n            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\r\n        }\r\n    });\r\n}\r\nfunction tryWrap(fn) {\r\n    return (id, arg) => {\r\n        try {\r\n            return fn(id, arg);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\r\n                `Full reload required.`);\r\n        }\r\n    };\r\n}\nfunction setDevtoolsHook(hook) {\r\n}\r\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nfunction markAttrsAccessed() {\r\n}\r\nfunction filterSingleRoot(children) {\r\n    let singleRoot;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (isVNode(child)) {\r\n            // ignore user comment\r\n            if (child.type !== Comment || child.children === 'v-if') {\r\n                if (singleRoot) {\r\n                    // has more than 1 non-comment child, return now\r\n                    return;\r\n                }\r\n                else {\r\n                    singleRoot = child;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    return singleRoot;\r\n}\r\n\nconst isSuspense = (type) => type.__isSuspense;\r\nfunction normalizeSuspenseChildren(vnode) {\r\n    const { shapeFlag, children } = vnode;\r\n    let content;\r\n    let fallback;\r\n    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        content = normalizeSuspenseSlot(children.default);\r\n        fallback = normalizeSuspenseSlot(children.fallback);\r\n    }\r\n    else {\r\n        content = normalizeSuspenseSlot(children);\r\n        fallback = normalizeVNode(null);\r\n    }\r\n    return {\r\n        content,\r\n        fallback\r\n    };\r\n}\r\nfunction normalizeSuspenseSlot(s) {\r\n    if (isFunction(s)) {\r\n        s = s();\r\n    }\r\n    if (isArray(s)) {\r\n        const singleChild = filterSingleRoot(s);\r\n        if ((process.env.NODE_ENV !== 'production') && !singleChild) {\r\n            warn(`<Suspense> slots expect a single root node.`);\r\n        }\r\n        s = singleChild;\r\n    }\r\n    return normalizeVNode(s);\r\n}\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if (isArray(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\n\nlet isRenderingCompiledSlot = 0;\r\nconst setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);\r\n\n// SFC scoped style ID management.\r\nlet currentScopeId = null;\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ, instance = currentInstance) {\r\n    if ((process.env.NODE_ENV !== 'production') && !cb) {\r\n        if (immediate !== undefined) {\r\n            warn(`watch() \"immediate\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n        if (deep !== undefined) {\r\n            warn(`watch() \"deep\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n    }\r\n    const warnInvalidSource = (s) => {\r\n        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n            `a reactive object, or an array of these types.`);\r\n    };\r\n    let getter;\r\n    let forceTrigger = false;\r\n    if (isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = !!source._shallow;\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        getter = () => source.map(s => {\r\n            if (isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (isFunction(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);\r\n            }\r\n            else {\r\n                (process.env.NODE_ENV !== 'production') && warnInvalidSource(s);\r\n            }\r\n        });\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = NOOP;\r\n        (process.env.NODE_ENV !== 'production') && warnInvalidSource(source);\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    const onInvalidate = (fn) => {\r\n        cleanup = runner.options.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!runner.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = runner();\r\n            if (deep || forceTrigger || hasChanged(newValue, oldValue)) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onInvalidate\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            runner();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = job;\r\n    }\r\n    else if (flush === 'post') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: 'pre'\r\n        scheduler = () => {\r\n            if (!instance || instance.isMounted) {\r\n                queuePreFlushCb(job);\r\n            }\r\n            else {\r\n                // with 'pre' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    const runner = effect(getter, {\r\n        lazy: true,\r\n        onTrack,\r\n        onTrigger,\r\n        scheduler\r\n    });\r\n    recordInstanceBoundEffect(runner, instance);\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = runner();\r\n        }\r\n    }\r\n    else if (flush === 'post') {\r\n        queuePostRenderEffect(runner, instance && instance.suspense);\r\n    }\r\n    else {\r\n        runner();\r\n    }\r\n    return () => {\r\n        stop(runner);\r\n        if (instance) {\r\n            remove(instance.effects, runner);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, cb, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = isString(source)\r\n        ? () => publicThis[source]\r\n        : source.bind(publicThis);\r\n    return doWatch(getter, cb.bind(publicThis), options, this);\r\n}\r\nfunction traverse(value, seen = new Set()) {\r\n    if (!isObject(value) || seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (isSet(value) || isMap(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\nconst queuePostRenderEffect =  queueEffectWithSuspense\r\n    ;\r\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n\nconst Fragment = Symbol((process.env.NODE_ENV !== 'production') ? 'Fragment' : undefined);\r\nconst Text = Symbol((process.env.NODE_ENV !== 'production') ? 'Text' : undefined);\r\nconst Comment = Symbol((process.env.NODE_ENV !== 'production') ? 'Comment' : undefined);\r\nconst Static = Symbol((process.env.NODE_ENV !== 'production') ? 'Static' : undefined);\r\nlet currentBlock = null;\r\n// Whether we should be tracking dynamic child nodes inside a block.\r\n// Only tracks when this value is > 0\r\n// We are not using a simple boolean because this value may need to be\r\n// incremented/decremented by nested usage of v-once (see below)\r\nlet shouldTrack$1 = 1;\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nlet vnodeArgsTransformer;\r\nconst createVNodeWithArgsTransform = (...args) => {\r\n    return _createVNode(...(vnodeArgsTransformer\r\n        ? vnodeArgsTransformer(args, currentRenderingInstance)\r\n        : args));\r\n};\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref }) => {\r\n    return (ref != null\r\n        ? isString(ref) || isRef(ref) || isFunction(ref)\r\n            ? { i: currentRenderingInstance, r: ref }\r\n            : ref\r\n        : null);\r\n};\r\nconst createVNode = ((process.env.NODE_ENV !== 'production')\r\n    ? createVNodeWithArgsTransform\r\n    : _createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        if ((process.env.NODE_ENV !== 'production') && !type) {\r\n            warn(`Invalid vnode type when creating vnode: ${type}.`);\r\n        }\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is=\"vnode\"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        if (isProxy(props) || InternalObjectKey in props) {\r\n            props = extend({}, props);\r\n        }\r\n        let { class: klass, style } = props;\r\n        if (klass && !isString(klass)) {\r\n            props.class = normalizeClass(klass);\r\n        }\r\n        if (isObject(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isProxy(style) && !isArray(style)) {\r\n                style = extend({}, style);\r\n            }\r\n            props.style = normalizeStyle(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = isString(type)\r\n        ? 1 /* ELEMENT */\r\n        :  isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : isObject(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : isFunction(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    if ((process.env.NODE_ENV !== 'production') && shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {\r\n        type = toRaw(type);\r\n        warn(`Vue received a Component which was made a reactive object. This can ` +\r\n            `lead to unnecessary performance overhead, and should be avoided by ` +\r\n            `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\r\n            `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\r\n    }\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        children: null,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    // validate key\r\n    if ((process.env.NODE_ENV !== 'production') && vnode.key !== vnode.key) {\r\n        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\r\n    }\r\n    normalizeChildren(vnode, children);\r\n    // normalize suspense children\r\n    if ( shapeFlag & 128 /* SUSPENSE */) {\r\n        const { content, fallback } = normalizeSuspenseChildren(vnode);\r\n        vnode.ssContent = content;\r\n        vnode.ssFallback = fallback;\r\n    }\r\n    if (shouldTrack$1 > 0 &&\r\n        // avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn't need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    return {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? isArray(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        children: vnode.children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: perserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn't affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\nfunction normalizeVNode(child) {\r\n    if (child == null || typeof child === 'boolean') {\r\n        // empty placeholder\r\n        return createVNode(Comment);\r\n    }\r\n    else if (isArray(child)) {\r\n        // fragment\r\n        return createVNode(Fragment, null, child);\r\n    }\r\n    else if (typeof child === 'object') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return child.el === null ? child : cloneVNode(child);\r\n    }\r\n    else {\r\n        // strings and numbers\r\n        return createVNode(Text, null, String(child));\r\n    }\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (isArray(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && setCompiledSlotRendering(1);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && setCompiledSlotRendering(-1);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent's slot type.\r\n                if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n                else {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (isFunction(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = extend({}, args[0]);\r\n    for (let i = 1; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = normalizeClass([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = normalizeStyle([ret.style, toMerge.style]);\r\n            }\r\n            else if (isOn(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (existing !== incoming) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, toMerge[key])\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== '') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\nlet isInBeforeCreate = false;\r\nfunction resolveMergedOptions(instance) {\r\n    const raw = instance.type;\r\n    const { __merged, mixins, extends: extendsOptions } = raw;\r\n    if (__merged)\r\n        return __merged;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (!globalMixins.length && !mixins && !extendsOptions)\r\n        return raw;\r\n    const options = {};\r\n    globalMixins.forEach(m => mergeOptions(options, m, instance));\r\n    mergeOptions(options, raw, instance);\r\n    return (raw.__merged = options);\r\n}\r\nfunction mergeOptions(to, from, instance) {\r\n    const strats = instance.appContext.config.optionMergeStrategies;\r\n    const { mixins, extends: extendsOptions } = from;\r\n    extendsOptions && mergeOptions(to, extendsOptions, instance);\r\n    mixins &&\r\n        mixins.forEach((m) => mergeOptions(to, m, instance));\r\n    for (const key in from) {\r\n        if (strats && hasOwn(strats, key)) {\r\n            to[key] = strats[key](to[key], from[key], instance.proxy, key);\r\n        }\r\n        else {\r\n            to[key] = from[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => i && (i.proxy ? i.proxy : getPublicInstance(i.parent));\r\nconst publicPropertiesMap = extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.props) : i.props),\r\n    $attrs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.attrs) : i.attrs),\r\n    $slots: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.slots) : i.slots),\r\n    $refs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.refs) : i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => i.root && i.root.proxy,\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => () => queueJob(i.update),\r\n    $nextTick: i => nextTick.bind(i.proxy),\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)\r\n});\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // let @vue/reactivity know it should never observe Vue public instances.\r\n        if (key === \"__v_skip\" /* SKIP */) {\r\n            return true;\r\n        }\r\n        // for internal formatters to know that this is a Vue instance\r\n        if ((process.env.NODE_ENV !== 'production') && key === '__isVue') {\r\n            return true;\r\n        }\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== '$') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 0 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 1 /* DATA */:\r\n                        return data[key];\r\n                    case 3 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 2 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n                accessCache[key] = 0 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n                accessCache[key] = 1 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                hasOwn(normalizedProps, key)) {\r\n                accessCache[key] = 2 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n                accessCache[key] = 3 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (!__VUE_OPTIONS_API__ || !isInBeforeCreate) {\r\n                accessCache[key] = 4 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === '$attrs') {\r\n                track(instance, \"get\" /* GET */, key);\r\n                (process.env.NODE_ENV !== 'production') && markAttrsAccessed();\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 3 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // global properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            hasOwn(globalProperties, key))) {\r\n            return globalProperties[key];\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production') &&\r\n            currentRenderingInstance &&\r\n            (!isString(key) ||\r\n                // #1091 avoid internal isRef/isVNode checks on component instance leading\r\n                // to infinite warning loop\r\n                key.indexOf('__v') !== 0)) {\r\n            if (data !== EMPTY_OBJ &&\r\n                (key[0] === '$' || key[0] === '_') &&\r\n                hasOwn(data, key)) {\r\n                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +\r\n                    `character (\"$\" or \"_\") and is not proxied on the render context.`);\r\n            }\r\n            else {\r\n                warn(`Property ${JSON.stringify(key)} was accessed during render ` +\r\n                    `but is not defined on instance.`);\r\n            }\r\n        }\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n            setupState[key] = value;\r\n        }\r\n        else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n            data[key] = value;\r\n        }\r\n        else if (key in instance.props) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate prop \"${key}\". Props are readonly.`, instance);\r\n            return false;\r\n        }\r\n        if (key[0] === '$' && key.slice(1) in instance) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate public property \"${key}\". ` +\r\n                    `Properties starting with $ are reserved and readonly.`, instance);\r\n            return false;\r\n        }\r\n        else {\r\n            if ((process.env.NODE_ENV !== 'production') && key in instance.appContext.config.globalProperties) {\r\n                Object.defineProperty(ctx, key, {\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    value\r\n                });\r\n            }\r\n            else {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (accessCache[key] !== undefined ||\r\n            (data !== EMPTY_OBJ && hasOwn(data, key)) ||\r\n            (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\r\n            hasOwn(ctx, key) ||\r\n            hasOwn(publicPropertiesMap, key) ||\r\n            hasOwn(appContext.config.globalProperties, key));\r\n    }\r\n};\r\nif ((process.env.NODE_ENV !== 'production') && !false) {\r\n    PublicInstanceProxyHandlers.ownKeys = (target) => {\r\n        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +\r\n            `The keys will be empty in production mode to avoid performance overhead.`);\r\n        return Reflect.ownKeys(target);\r\n    };\r\n}\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== '_' && !isGloballyWhitelisted(key);\r\n        if ((process.env.NODE_ENV !== 'production') && !has && PublicInstanceProxyHandlers.has(_, key)) {\r\n            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\r\n        }\r\n        return has;\r\n    }\r\n});\r\nlet currentInstance = null;\r\n// record effects created during a component's setup() so that they can be\r\n// stopped when the component unmounts\r\nfunction recordInstanceBoundEffect(effect, instance = currentInstance) {\r\n    if (instance) {\r\n        (instance.effects || (instance.effects = [])).push(effect);\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = isFunction(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return isFunction(value) && '__vccOpts' in value;\r\n}\n\nconst ssrContextKey = Symbol((process.env.NODE_ENV !== 'production') ? `ssrContext` : ``);\r\n\nfunction initCustomFormatter() {\r\n    /* eslint-disable no-restricted-globals */\r\n    if (!(process.env.NODE_ENV !== 'production') || typeof window === 'undefined') {\r\n        return;\r\n    }\r\n    const vueStyle = { style: 'color:#3ba776' };\r\n    const numberStyle = { style: 'color:#0b1bc9' };\r\n    const stringStyle = { style: 'color:#b62e24' };\r\n    const keywordStyle = { style: 'color:#9d288c' };\r\n    // custom formatter for Chrome\r\n    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n    const formatter = {\r\n        header(obj) {\r\n            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n            if (!isObject(obj)) {\r\n                return null;\r\n            }\r\n            if (obj.__isVue) {\r\n                return ['div', vueStyle, `VueInstance`];\r\n            }\r\n            else if (isRef(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, genRefFlag(obj)],\r\n                    '<',\r\n                    formatValue(obj.value),\r\n                    `>`\r\n                ];\r\n            }\r\n            else if (isReactive(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Reactive'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    `>${isReadonly(obj) ? ` (readonly)` : ``}`\r\n                ];\r\n            }\r\n            else if (isReadonly(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Readonly'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    '>'\r\n                ];\r\n            }\r\n            return null;\r\n        },\r\n        hasBody(obj) {\r\n            return obj && obj.__isVue;\r\n        },\r\n        body(obj) {\r\n            if (obj && obj.__isVue) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ...formatInstance(obj.$)\r\n                ];\r\n            }\r\n        }\r\n    };\r\n    function formatInstance(instance) {\r\n        const blocks = [];\r\n        if (instance.type.props && instance.props) {\r\n            blocks.push(createInstanceBlock('props', toRaw(instance.props)));\r\n        }\r\n        if (instance.setupState !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('setup', instance.setupState));\r\n        }\r\n        if (instance.data !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('data', toRaw(instance.data)));\r\n        }\r\n        const computed = extractKeys(instance, 'computed');\r\n        if (computed) {\r\n            blocks.push(createInstanceBlock('computed', computed));\r\n        }\r\n        const injected = extractKeys(instance, 'inject');\r\n        if (injected) {\r\n            blocks.push(createInstanceBlock('injected', injected));\r\n        }\r\n        blocks.push([\r\n            'div',\r\n            {},\r\n            [\r\n                'span',\r\n                {\r\n                    style: keywordStyle.style + ';opacity:0.66'\r\n                },\r\n                '$ (internal): '\r\n            ],\r\n            ['object', { object: instance }]\r\n        ]);\r\n        return blocks;\r\n    }\r\n    function createInstanceBlock(type, target) {\r\n        target = extend({}, target);\r\n        if (!Object.keys(target).length) {\r\n            return ['span', {}];\r\n        }\r\n        return [\r\n            'div',\r\n            { style: 'line-height:1.25em;margin-bottom:0.6em' },\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'color:#476582'\r\n                },\r\n                type\r\n            ],\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'padding-left:1.25em'\r\n                },\r\n                ...Object.keys(target).map(key => {\r\n                    return [\r\n                        'div',\r\n                        {},\r\n                        ['span', keywordStyle, key + ': '],\r\n                        formatValue(target[key], false)\r\n                    ];\r\n                })\r\n            ]\r\n        ];\r\n    }\r\n    function formatValue(v, asRaw = true) {\r\n        if (typeof v === 'number') {\r\n            return ['span', numberStyle, v];\r\n        }\r\n        else if (typeof v === 'string') {\r\n            return ['span', stringStyle, JSON.stringify(v)];\r\n        }\r\n        else if (typeof v === 'boolean') {\r\n            return ['span', keywordStyle, v];\r\n        }\r\n        else if (isObject(v)) {\r\n            return ['object', { object: asRaw ? toRaw(v) : v }];\r\n        }\r\n        else {\r\n            return ['span', stringStyle, String(v)];\r\n        }\r\n    }\r\n    function extractKeys(instance, type) {\r\n        const Comp = instance.type;\r\n        if (isFunction(Comp)) {\r\n            return;\r\n        }\r\n        const extracted = {};\r\n        for (const key in instance.ctx) {\r\n            if (isKeyOfType(Comp, key, type)) {\r\n                extracted[key] = instance.ctx[key];\r\n            }\r\n        }\r\n        return extracted;\r\n    }\r\n    function isKeyOfType(Comp, key, type) {\r\n        const opts = Comp[type];\r\n        if ((isArray(opts) && opts.includes(key)) ||\r\n            (isObject(opts) && key in opts)) {\r\n            return true;\r\n        }\r\n        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n            return true;\r\n        }\r\n        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n            return true;\r\n        }\r\n    }\r\n    function genRefFlag(v) {\r\n        if (v._shallow) {\r\n            return `ShallowRef`;\r\n        }\r\n        if (v.effect) {\r\n            return `ComputedRef`;\r\n        }\r\n        return `Ref`;\r\n    }\r\n    if (window.devtoolsFormatters) {\r\n        window.devtoolsFormatters.push(formatter);\r\n    }\r\n    else {\r\n        window.devtoolsFormatters = [formatter];\r\n    }\r\n}\n\nconst svgNS = 'http://www.w3.org/2000/svg';\r\nconst doc = (typeof document !== 'undefined' ? document : null);\r\nlet tempContainer;\r\nlet tempSVGContainer;\r\nconst nodeOps = {\r\n    insert: (child, parent, anchor) => {\r\n        parent.insertBefore(child, anchor || null);\r\n    },\r\n    remove: child => {\r\n        const parent = child.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(child);\r\n        }\r\n    },\r\n    createElement: (tag, isSVG, is) => isSVG\r\n        ? doc.createElementNS(svgNS, tag)\r\n        : doc.createElement(tag, is ? { is } : undefined),\r\n    createText: text => doc.createTextNode(text),\r\n    createComment: text => doc.createComment(text),\r\n    setText: (node, text) => {\r\n        node.nodeValue = text;\r\n    },\r\n    setElementText: (el, text) => {\r\n        el.textContent = text;\r\n    },\r\n    parentNode: node => node.parentNode,\r\n    nextSibling: node => node.nextSibling,\r\n    querySelector: selector => doc.querySelector(selector),\r\n    setScopeId(el, id) {\r\n        el.setAttribute(id, '');\r\n    },\r\n    cloneNode(el) {\r\n        return el.cloneNode(true);\r\n    },\r\n    // __UNSAFE__\r\n    // Reason: innerHTML.\r\n    // Static content here can only come from compiled templates.\r\n    // As long as the user only uses trusted templates, this is safe.\r\n    insertStaticContent(content, parent, anchor, isSVG) {\r\n        const temp = isSVG\r\n            ? tempSVGContainer ||\r\n                (tempSVGContainer = doc.createElementNS(svgNS, 'svg'))\r\n            : tempContainer || (tempContainer = doc.createElement('div'));\r\n        temp.innerHTML = content;\r\n        const first = temp.firstChild;\r\n        let node = first;\r\n        let last = node;\r\n        while (node) {\r\n            last = node;\r\n            nodeOps.insert(node, parent, anchor);\r\n            node = temp.firstChild;\r\n        }\r\n        return [first, last];\r\n    }\r\n};\n\n// compiler should normalize class + :class bindings on the same element\r\n// into a single binding ['staticClass', dynamic]\r\nfunction patchClass(el, value, isSVG) {\r\n    if (value == null) {\r\n        value = '';\r\n    }\r\n    if (isSVG) {\r\n        el.setAttribute('class', value);\r\n    }\r\n    else {\r\n        // directly setting className should be faster than setAttribute in theory\r\n        // if this is an element during a transition, take the temporary transition\r\n        // classes into account.\r\n        const transitionClasses = el._vtc;\r\n        if (transitionClasses) {\r\n            value = (value\r\n                ? [value, ...transitionClasses]\r\n                : [...transitionClasses]).join(' ');\r\n        }\r\n        el.className = value;\r\n    }\r\n}\n\nfunction patchStyle(el, prev, next) {\r\n    const style = el.style;\r\n    if (!next) {\r\n        el.removeAttribute('style');\r\n    }\r\n    else if (isString(next)) {\r\n        if (prev !== next) {\r\n            style.cssText = next;\r\n        }\r\n    }\r\n    else {\r\n        for (const key in next) {\r\n            setStyle(style, key, next[key]);\r\n        }\r\n        if (prev && !isString(prev)) {\r\n            for (const key in prev) {\r\n                if (next[key] == null) {\r\n                    setStyle(style, key, '');\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nconst importantRE = /\\s*!important$/;\r\nfunction setStyle(style, name, val) {\r\n    if (isArray(val)) {\r\n        val.forEach(v => setStyle(style, name, v));\r\n    }\r\n    else {\r\n        if (name.startsWith('--')) {\r\n            // custom property definition\r\n            style.setProperty(name, val);\r\n        }\r\n        else {\r\n            const prefixed = autoPrefix(style, name);\r\n            if (importantRE.test(val)) {\r\n                // !important\r\n                style.setProperty(hyphenate(prefixed), val.replace(importantRE, ''), 'important');\r\n            }\r\n            else {\r\n                style[prefixed] = val;\r\n            }\r\n        }\r\n    }\r\n}\r\nconst prefixes = ['Webkit', 'Moz', 'ms'];\r\nconst prefixCache = {};\r\nfunction autoPrefix(style, rawName) {\r\n    const cached = prefixCache[rawName];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    let name = camelize(rawName);\r\n    if (name !== 'filter' && name in style) {\r\n        return (prefixCache[rawName] = name);\r\n    }\r\n    name = capitalize(name);\r\n    for (let i = 0; i < prefixes.length; i++) {\r\n        const prefixed = prefixes[i] + name;\r\n        if (prefixed in style) {\r\n            return (prefixCache[rawName] = prefixed);\r\n        }\r\n    }\r\n    return rawName;\r\n}\n\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\r\nfunction patchAttr(el, key, value, isSVG) {\r\n    if (isSVG && key.startsWith('xlink:')) {\r\n        if (value == null) {\r\n            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\r\n        }\r\n        else {\r\n            el.setAttributeNS(xlinkNS, key, value);\r\n        }\r\n    }\r\n    else {\r\n        // note we are only checking boolean attributes that don't have a\r\n        // corresponding dom prop of the same name here.\r\n        const isBoolean = isSpecialBooleanAttr(key);\r\n        if (value == null || (isBoolean && value === false)) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            el.setAttribute(key, isBoolean ? '' : value);\r\n        }\r\n    }\r\n}\n\n// __UNSAFE__\r\n// functions. The user is responsible for using them with only trusted content.\r\nfunction patchDOMProp(el, key, value, \r\n// the following args are passed only due to potential innerHTML/textContent\r\n// overriding existing VNodes, in which case the old tree must be properly\r\n// unmounted.\r\nprevChildren, parentComponent, parentSuspense, unmountChildren) {\r\n    if (key === 'innerHTML' || key === 'textContent') {\r\n        if (prevChildren) {\r\n            unmountChildren(prevChildren, parentComponent, parentSuspense);\r\n        }\r\n        el[key] = value == null ? '' : value;\r\n        return;\r\n    }\r\n    if (key === 'value' && el.tagName !== 'PROGRESS') {\r\n        // store value as _value as well since\r\n        // non-string values will be stringified.\r\n        el._value = value;\r\n        const newValue = value == null ? '' : value;\r\n        if (el.value !== newValue) {\r\n            el.value = newValue;\r\n        }\r\n        return;\r\n    }\r\n    if (value === '' || value == null) {\r\n        const type = typeof el[key];\r\n        if (value === '' && type === 'boolean') {\r\n            // e.g. <select multiple> compiles to { multiple: '' }\r\n            el[key] = true;\r\n            return;\r\n        }\r\n        else if (value == null && type === 'string') {\r\n            // e.g. <div :id=\"null\">\r\n            el[key] = '';\r\n            el.removeAttribute(key);\r\n            return;\r\n        }\r\n        else if (type === 'number') {\r\n            // e.g. <img :width=\"null\">\r\n            el[key] = 0;\r\n            el.removeAttribute(key);\r\n            return;\r\n        }\r\n    }\r\n    // some properties perform value validation and throw\r\n    try {\r\n        el[key] = value;\r\n    }\r\n    catch (e) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`Failed setting prop \"${key}\" on <${el.tagName.toLowerCase()}>: ` +\r\n                `value ${value} is invalid.`, e);\r\n        }\r\n    }\r\n}\n\n// Async edge case fix requires storing an event listener's attach timestamp.\r\nlet _getNow = Date.now;\r\n// Determine what event timestamp the browser is using. Annoyingly, the\r\n// timestamp can either be hi-res (relative to page load) or low-res\r\n// (relative to UNIX epoch), so in order to compare time we have to use the\r\n// same timestamp type when saving the flush timestamp.\r\nif (typeof document !== 'undefined' &&\r\n    _getNow() > document.createEvent('Event').timeStamp) {\r\n    // if the low-res timestamp which is bigger than the event timestamp\r\n    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\r\n    // and we need to use the hi-res version for event listeners as well.\r\n    _getNow = () => performance.now();\r\n}\r\n// To avoid the overhead of repeatedly calling performance.now(), we cache\r\n// and use the same timestamp for all event listeners attached in the same tick.\r\nlet cachedNow = 0;\r\nconst p = Promise.resolve();\r\nconst reset = () => {\r\n    cachedNow = 0;\r\n};\r\nconst getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));\r\nfunction addEventListener(el, event, handler, options) {\r\n    el.addEventListener(event, handler, options);\r\n}\r\nfunction removeEventListener(el, event, handler, options) {\r\n    el.removeEventListener(event, handler, options);\r\n}\r\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\r\n    // vei = vue event invokers\r\n    const invokers = el._vei || (el._vei = {});\r\n    const existingInvoker = invokers[rawName];\r\n    if (nextValue && existingInvoker) {\r\n        // patch\r\n        existingInvoker.value = nextValue;\r\n    }\r\n    else {\r\n        const [name, options] = parseName(rawName);\r\n        if (nextValue) {\r\n            // add\r\n            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));\r\n            addEventListener(el, name, invoker, options);\r\n        }\r\n        else if (existingInvoker) {\r\n            // remove\r\n            removeEventListener(el, name, existingInvoker, options);\r\n            invokers[rawName] = undefined;\r\n        }\r\n    }\r\n}\r\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\r\nfunction parseName(name) {\r\n    let options;\r\n    if (optionsModifierRE.test(name)) {\r\n        options = {};\r\n        let m;\r\n        while ((m = name.match(optionsModifierRE))) {\r\n            name = name.slice(0, name.length - m[0].length);\r\n            options[m[0].toLowerCase()] = true;\r\n        }\r\n    }\r\n    return [name.slice(2).toLowerCase(), options];\r\n}\r\nfunction createInvoker(initialValue, instance) {\r\n    const invoker = (e) => {\r\n        // async edge case #6566: inner click event triggers patch, event handler\r\n        // attached to outer element during patch, and triggered again. This\r\n        // happens because browsers fire microtask ticks between event propagation.\r\n        // the solution is simple: we save the timestamp when a handler is attached,\r\n        // and the handler would only fire if the event passed to it was fired\r\n        // AFTER it was attached.\r\n        const timeStamp = e.timeStamp || _getNow();\r\n        if (timeStamp >= invoker.attached - 1) {\r\n            callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);\r\n        }\r\n    };\r\n    invoker.value = initialValue;\r\n    invoker.attached = getNow();\r\n    return invoker;\r\n}\r\nfunction patchStopImmediatePropagation(e, value) {\r\n    if (isArray(value)) {\r\n        const originalStop = e.stopImmediatePropagation;\r\n        e.stopImmediatePropagation = () => {\r\n            originalStop.call(e);\r\n            e._stopped = true;\r\n        };\r\n        return value.map(fn => (e) => !e._stopped && fn(e));\r\n    }\r\n    else {\r\n        return value;\r\n    }\r\n}\n\nconst nativeOnRE = /^on[a-z]/;\r\nconst forcePatchProp = (_, key) => key === 'value';\r\nconst patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\r\n    switch (key) {\r\n        // special\r\n        case 'class':\r\n            patchClass(el, nextValue, isSVG);\r\n            break;\r\n        case 'style':\r\n            patchStyle(el, prevValue, nextValue);\r\n            break;\r\n        default:\r\n            if (isOn(key)) {\r\n                // ignore v-model listeners\r\n                if (!isModelListener(key)) {\r\n                    patchEvent(el, key, prevValue, nextValue, parentComponent);\r\n                }\r\n            }\r\n            else if (shouldSetAsProp(el, key, nextValue, isSVG)) {\r\n                patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\r\n            }\r\n            else {\r\n                // special case for <input v-model type=\"checkbox\"> with\r\n                // :true-value & :false-value\r\n                // store value as dom properties since non-string values will be\r\n                // stringified.\r\n                if (key === 'true-value') {\r\n                    el._trueValue = nextValue;\r\n                }\r\n                else if (key === 'false-value') {\r\n                    el._falseValue = nextValue;\r\n                }\r\n                patchAttr(el, key, nextValue, isSVG);\r\n            }\r\n            break;\r\n    }\r\n};\r\nfunction shouldSetAsProp(el, key, value, isSVG) {\r\n    if (isSVG) {\r\n        // most keys must be set as attribute on svg elements to work\r\n        // ...except innerHTML\r\n        if (key === 'innerHTML') {\r\n            return true;\r\n        }\r\n        // or native onclick with function values\r\n        if (key in el && nativeOnRE.test(key) && isFunction(value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // spellcheck and draggable are numerated attrs, however their\r\n    // corresponding DOM properties are actually booleans - this leads to\r\n    // setting it with a string \"false\" value leading it to be coerced to\r\n    // `true`, so we need to always treat them as attributes.\r\n    // Note that `contentEditable` doesn't have this problem: its DOM\r\n    // property is also enumerated string values.\r\n    if (key === 'spellcheck' || key === 'draggable') {\r\n        return false;\r\n    }\r\n    // #1787 form as an attribute must be a string, while it accepts an Element as\r\n    // a prop\r\n    if (key === 'form' && typeof value === 'string') {\r\n        return false;\r\n    }\r\n    // #1526 <input list> must be set as attribute\r\n    if (key === 'list' && el.tagName === 'INPUT') {\r\n        return false;\r\n    }\r\n    // native onclick with string value, must be set as attribute\r\n    if (nativeOnRE.test(key) && isString(value)) {\r\n        return false;\r\n    }\r\n    return key in el;\r\n}\n\nconst rendererOptions = extend({ patchProp, forcePatchProp }, nodeOps);\n\nfunction initDev() {\r\n    const target = getGlobalThis();\r\n    target.__VUE__ = true;\r\n    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);\r\n    {\r\n        initCustomFormatter();\r\n    }\r\n}\n\n// This entry exports the runtime only, and is built as\r\n(process.env.NODE_ENV !== 'production') && initDev();\n\nfunction processOptions(value) {\n  var options;\n\n  if (typeof value === 'function') {\n    // Simple options (callback-only)\n    options = {\n      callback: value\n    };\n  } else {\n    // Options object\n    options = value;\n  }\n\n  return options;\n}\nfunction throttle(callback, delay) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout;\n  var lastState;\n  var currentArgs;\n\n  var throttled = function throttled(state) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    currentArgs = args;\n    if (timeout && state === lastState) return;\n    var leading = options.leading;\n\n    if (typeof leading === 'function') {\n      leading = leading(state, lastState);\n    }\n\n    if ((!timeout || state !== lastState) && leading) {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n    }\n\n    lastState = state;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n      timeout = 0;\n    }, delay);\n  };\n\n  throttled._clear = function () {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return throttled;\n}\nfunction deepEqual(val1, val2) {\n  if (val1 === val2) return true;\n\n  if (_typeof(val1) === 'object') {\n    for (var key in val1) {\n      if (!deepEqual(val1[key], val2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar VisibilityState =\n/*#__PURE__*/\nfunction () {\n  function VisibilityState(el, options, vnode) {\n    _classCallCheck(this, VisibilityState);\n\n    this.el = el;\n    this.observer = null;\n    this.frozen = false;\n    this.createObserver(options, vnode);\n  }\n\n  _createClass(VisibilityState, [{\n    key: \"createObserver\",\n    value: function createObserver(options, vnode) {\n      var _this = this;\n\n      if (this.observer) {\n        this.destroyObserver();\n      }\n\n      if (this.frozen) return;\n      this.options = processOptions(options);\n\n      this.callback = function (result, entry) {\n        _this.options.callback(result, entry);\n\n        if (result && _this.options.once) {\n          _this.frozen = true;\n\n          _this.destroyObserver();\n        }\n      }; // Throttle\n\n\n      if (this.callback && this.options.throttle) {\n        var _ref = this.options.throttleOptions || {},\n            _leading = _ref.leading;\n\n        this.callback = throttle(this.callback, this.options.throttle, {\n          leading: function leading(state) {\n            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;\n          }\n        });\n      }\n\n      this.oldResult = undefined;\n      this.observer = new IntersectionObserver(function (entries) {\n        var entry = entries[0];\n\n        if (entries.length > 1) {\n          var intersectingEntry = entries.find(function (e) {\n            return e.isIntersecting;\n          });\n\n          if (intersectingEntry) {\n            entry = intersectingEntry;\n          }\n        }\n\n        if (_this.callback) {\n          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.\n          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;\n          if (result === _this.oldResult) return;\n          _this.oldResult = result;\n\n          _this.callback(result, entry);\n        }\n      }, this.options.intersection); // Wait for the element to be in document\n\n      nextTick(function () {\n        if (_this.observer) {\n          _this.observer.observe(_this.el);\n        }\n      });\n    }\n  }, {\n    key: \"destroyObserver\",\n    value: function destroyObserver() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      } // Cancel throttled call\n\n\n      if (this.callback && this.callback._clear) {\n        this.callback._clear();\n\n        this.callback = null;\n      }\n    }\n  }, {\n    key: \"threshold\",\n    get: function get() {\n      return this.options.intersection && this.options.intersection.threshold || 0;\n    }\n  }]);\n\n  return VisibilityState;\n}();\n\nfunction bind(el, _ref2, vnode) {\n  var value = _ref2.value;\n  if (!value) return;\n\n  if (typeof IntersectionObserver === 'undefined') {\n    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');\n  } else {\n    var state = new VisibilityState(el, value, vnode);\n    el._vue_visibilityState = state;\n  }\n}\n\nfunction update(el, _ref3, vnode) {\n  var value = _ref3.value,\n      oldValue = _ref3.oldValue;\n  if (deepEqual(value, oldValue)) return;\n  var state = el._vue_visibilityState;\n\n  if (!value) {\n    unbind(el);\n    return;\n  }\n\n  if (state) {\n    state.createObserver(value, vnode);\n  } else {\n    bind(el, {\n      value: value\n    }, vnode);\n  }\n}\n\nfunction unbind(el) {\n  var state = el._vue_visibilityState;\n\n  if (state) {\n    state.destroyObserver();\n    delete el._vue_visibilityState;\n  }\n}\n\nvar ObserveVisibility = {\n  beforeMount: bind,\n  updated: update,\n  unmounted: unbind\n};\n\nfunction install(Vue) {\n  Vue.directive('observe-visibility', ObserveVisibility);\n  /* -- Add more components here -- */\n}\n/* -- Plugin definition & Auto-install -- */\n\n/* You shouldn't have to modify the code below */\n// Plugin\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"0.4.6\",\n  install: install\n};\n\nvar GlobalVue = null;\n\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\n\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n\nexport default plugin;\nexport { ObserveVisibility, install };\n","(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    root.Scrollparent = factory();\n  }\n}(this, function () {\n  var regex = /(auto|scroll)/;\n\n  var parents = function (node, ps) {\n    if (node.parentNode === null) { return ps; }\n\n    return parents(node.parentNode, ps.concat([node]));\n  };\n\n  var style = function (node, prop) {\n    return getComputedStyle(node, null).getPropertyValue(prop);\n  };\n\n  var overflow = function (node) {\n    return style(node, \"overflow\") + style(node, \"overflow-y\") + style(node, \"overflow-x\");\n  };\n\n  var scroll = function (node) {\n   return regex.test(overflow(node));\n  };\n\n  var scrollParent = function (node) {\n    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n      return ;\n    }\n\n    var ps = parents(node.parentNode, []);\n\n    for (var i = 0; i < ps.length; i += 1) {\n      if (scroll(ps[i])) {\n        return ps[i];\n      }\n    }\n\n    return document.scrollingElement || document.documentElement;\n  };\n\n  return scrollParent;\n}));\n","export const props = {\r\n  items: {\r\n    type: Array,\r\n    required: true,\r\n  },\r\n\r\n  keyField: {\r\n    type: String,\r\n    default: 'id',\r\n  },\r\n\r\n  direction: {\r\n    type: String,\r\n    default: 'vertical',\r\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\r\n  },\r\n}\r\n\r\nexport function simpleArray () {\r\n  return this.items.length && typeof this.items[0] !== 'object'\r\n}\r\n","export let supportsPassive = false\r\n\r\nif (typeof window !== 'undefined') {\r\n  supportsPassive = false\r\n  try {\r\n    var opts = Object.defineProperty({}, 'passive', {\r\n      get () {\r\n        supportsPassive = true\r\n      },\r\n    })\r\n    window.addEventListener('test', null, opts)\r\n  } catch (e) {}\r\n}\r\n","<template>\r\n  <div\r\n    v-observe-visibility=\"handleVisibilityChange\"\r\n    class=\"vue-recycle-scroller\"\r\n    :class=\"{\r\n      ready,\r\n      'page-mode': pageMode,\r\n      [`direction-${direction}`]: true,\r\n    }\"\r\n    @scroll.passive=\"handleScroll\"\r\n  >\r\n    <div\r\n      v-if=\"$slots.before\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"before\"\r\n      />\r\n    </div>\r\n\r\n    <div\r\n      ref=\"wrapper\"\r\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\r\n      class=\"vue-recycle-scroller__item-wrapper\"\r\n    >\r\n      <div\r\n        v-for=\"view of pool\"\r\n        :key=\"view.nr.id\"\r\n        :style=\"ready ? { transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px)` } : null\"\r\n        class=\"vue-recycle-scroller__item-view\"\r\n        :class=\"{ hover: hoverKey === view.nr.key }\"\r\n        @mouseenter=\"hoverKey = view.nr.key\"\r\n        @mouseleave=\"hoverKey = null\"\r\n      >\r\n        <slot\r\n          :item=\"view.item\"\r\n          :index=\"view.nr.index\"\r\n          :active=\"view.nr.used\"\r\n        />\r\n      </div>\r\n    </div>\r\n\r\n    <div\r\n      v-if=\"$slots.after\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"after\"\r\n      />\r\n    </div>\r\n\r\n    <ResizeObserver @notify=\"handleResize\" />\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { shallowReactive } from 'vue';\r\nimport { ResizeObserver } from 'vue-resize'\r\nimport { ObserveVisibility } from 'vue-observe-visibility'\r\nimport ScrollParent from 'scrollparent'\r\nimport config from '../config'\r\nimport { props, simpleArray } from './common'\r\nimport { supportsPassive } from '../utils'\r\n\r\nlet uid = 0\r\n\r\nexport default {\r\n  name: 'RecycleScroller',\r\n\r\n  components: {\r\n    ResizeObserver,\r\n  },\r\n\r\n  directives: {\r\n    ObserveVisibility,\r\n  },\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    itemSize: {\r\n      type: Number,\r\n      default: null,\r\n    },\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      default: null,\r\n    },\r\n\r\n    sizeField: {\r\n      type: String,\r\n      default: 'size',\r\n    },\r\n\r\n    typeField: {\r\n      type: String,\r\n      default: 'type',\r\n    },\r\n\r\n    buffer: {\r\n      type: Number,\r\n      default: 200,\r\n    },\r\n\r\n    pageMode: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    prerender: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n\r\n    emitUpdate: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n  },\r\n\r\n  data () {\r\n    return {\r\n      pool: [],\r\n      totalSize: 0,\r\n      ready: false,\r\n      hoverKey: null,\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    sizes () {\r\n      if (this.itemSize === null) {\r\n        const sizes = {\r\n          '-1': { accumulator: 0 },\r\n        }\r\n        const items = this.items\r\n        const field = this.sizeField\r\n        const minItemSize = this.minItemSize\r\n        let computedMinSize = 10000\r\n        let accumulator = 0\r\n        let current\r\n        for (let i = 0, l = items.length; i < l; i++) {\r\n          current = items[i][field] || minItemSize\r\n          if (current < computedMinSize) {\r\n            computedMinSize = current\r\n          }\r\n          accumulator += current\r\n          sizes[i] = { accumulator, size: current }\r\n        }\r\n        // eslint-disable-next-line\r\n        this.$_computedMinItemSize = computedMinSize\r\n        return sizes\r\n      }\r\n      return []\r\n    },\r\n\r\n    simpleArray,\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.updateVisibleItems(true)\r\n    },\r\n\r\n    pageMode () {\r\n      this.applyPageMode()\r\n      this.updateVisibleItems(false)\r\n    },\r\n\r\n    sizes: {\r\n      handler () {\r\n        this.updateVisibleItems(false)\r\n      },\r\n      deep: true,\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_startIndex = 0\r\n    this.$_endIndex = 0\r\n    this.$_views = new Map()\r\n    this.$_unusedViews = new Map()\r\n    this.$_scrollDirty = false\r\n    this.$_lastUpdateScrollPosition = 0\r\n\r\n    // In SSR mode, we also prerender the same number of item for the first render\r\n    // to avoir mismatch between server and client templates\r\n    if (this.prerender) {\r\n      this.$_prerender = true\r\n      this.updateVisibleItems(false)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    this.applyPageMode()\r\n    this.$nextTick(() => {\r\n      // In SSR mode, render the real number of visible items\r\n      this.$_prerender = false\r\n      this.updateVisibleItems(true)\r\n      this.ready = true\r\n    })\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.removeListeners()\r\n  },\r\n\r\n  methods: {\r\n    addView (pool, index, item, key, type) {\r\n      const view = shallowReactive({\r\n        item,\r\n        position: 0,\r\n        nr: {\r\n          id: uid++,\r\n          index,\r\n          used: true,\r\n          key,\r\n          type,\r\n        },\r\n      })\r\n      pool.push(view)\r\n      return view\r\n    },\r\n\r\n    unuseView (view, fake = false) {\r\n      const unusedViews = this.$_unusedViews\r\n      const type = view.nr.type\r\n      let unusedPool = unusedViews.get(type)\r\n      if (!unusedPool) {\r\n        unusedPool = []\r\n        unusedViews.set(type, unusedPool)\r\n      }\r\n      unusedPool.push(view)\r\n      if (!fake) {\r\n        view.nr.used = false\r\n        view.position = -9999\r\n        this.$_views.delete(view.nr.key)\r\n      }\r\n    },\r\n\r\n    handleResize () {\r\n      this.$emit('resize')\r\n      if (this.ready) this.updateVisibleItems(false)\r\n    },\r\n\r\n    handleScroll (event) {\r\n      if (!this.$_scrollDirty) {\r\n        this.$_scrollDirty = true\r\n        requestAnimationFrame(() => {\r\n          this.$_scrollDirty = false\r\n          const { continuous } = this.updateVisibleItems(false, true)\r\n\r\n          // It seems sometimes chrome doesn't fire scroll event :/\r\n          // When non continous scrolling is ending, we force a refresh\r\n          if (!continuous) {\r\n            clearTimeout(this.$_refreshTimout)\r\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\r\n          }\r\n        })\r\n      }\r\n    },\r\n\r\n    handleVisibilityChange (isVisible, entry) {\r\n      if (this.ready) {\r\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\r\n          this.$emit('visible')\r\n          requestAnimationFrame(() => {\r\n            this.updateVisibleItems(false)\r\n          })\r\n        } else {\r\n          this.$emit('hidden')\r\n        }\r\n      }\r\n    },\r\n\r\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\r\n      const itemSize = this.itemSize\r\n      const minItemSize = this.$_computedMinItemSize\r\n      const typeField = this.typeField\r\n      const keyField = this.simpleArray ? null : this.keyField\r\n      const items = this.items\r\n      const count = items.length\r\n      const sizes = this.sizes\r\n      const views = this.$_views\r\n      const unusedViews = this.$_unusedViews\r\n      const pool = this.pool\r\n      let startIndex, endIndex\r\n      let totalSize\r\n\r\n      if (!count) {\r\n        startIndex = endIndex = totalSize = 0\r\n      } else if (this.$_prerender) {\r\n        startIndex = 0\r\n        endIndex = this.prerender\r\n        totalSize = null\r\n      } else {\r\n        const scroll = this.getScroll()\r\n\r\n        // Skip update if use hasn't scrolled enough\r\n        if (checkPositionDiff) {\r\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\r\n          if (positionDiff < 0) positionDiff = -positionDiff\r\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\r\n            return {\r\n              continuous: true,\r\n            }\r\n          }\r\n        }\r\n        this.$_lastUpdateScrollPosition = scroll.start\r\n\r\n        const buffer = this.buffer\r\n        scroll.start -= buffer\r\n        scroll.end += buffer\r\n\r\n        // Variable size mode\r\n        if (itemSize === null) {\r\n          let h\r\n          let a = 0\r\n          let b = count - 1\r\n          let i = ~~(count / 2)\r\n          let oldI\r\n\r\n          // Searching for startIndex\r\n          do {\r\n            oldI = i\r\n            h = sizes[i].accumulator\r\n            if (h < scroll.start) {\r\n              a = i\r\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\r\n              b = i\r\n            }\r\n            i = ~~((a + b) / 2)\r\n          } while (i !== oldI)\r\n          i < 0 && (i = 0)\r\n          startIndex = i\r\n\r\n          // For container style\r\n          totalSize = sizes[count - 1].accumulator\r\n\r\n          // Searching for endIndex\r\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\r\n          if (endIndex === -1) {\r\n            endIndex = items.length - 1\r\n          } else {\r\n            endIndex++\r\n            // Bounds\r\n            endIndex > count && (endIndex = count)\r\n          }\r\n        } else {\r\n          // Fixed size mode\r\n          startIndex = ~~(scroll.start / itemSize)\r\n          endIndex = Math.ceil(scroll.end / itemSize)\r\n\r\n          // Bounds\r\n          startIndex < 0 && (startIndex = 0)\r\n          endIndex > count && (endIndex = count)\r\n\r\n          totalSize = count * itemSize\r\n        }\r\n      }\r\n\r\n      if (endIndex - startIndex > config.itemsLimit) {\r\n        this.itemsLimitError()\r\n      }\r\n\r\n      this.totalSize = totalSize\r\n\r\n      let view\r\n\r\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\r\n\r\n      if (this.$_continuous !== continuous) {\r\n        if (continuous) {\r\n          views.clear()\r\n          unusedViews.clear()\r\n          for (let i = 0, l = pool.length; i < l; i++) {\r\n            view = pool[i]\r\n            this.unuseView(view)\r\n          }\r\n        }\r\n        this.$_continuous = continuous\r\n      } else if (continuous) {\r\n        for (let i = 0, l = pool.length; i < l; i++) {\r\n          view = pool[i]\r\n          if (view.nr.used) {\r\n            // Update view item index\r\n            if (checkItem) {\r\n              view.nr.index = items.findIndex(\r\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item,\r\n              )\r\n            }\r\n\r\n            // Check if index is still in visible range\r\n            if (\r\n              view.nr.index === -1 ||\r\n              view.nr.index < startIndex ||\r\n              view.nr.index >= endIndex\r\n            ) {\r\n              this.unuseView(view)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const unusedIndex = continuous ? null : new Map()\r\n\r\n      let item, type, unusedPool\r\n      let v\r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        item = items[i]\r\n        const key = keyField ? item[keyField] : item\r\n        if (key == null) {\r\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\r\n        }\r\n        view = views.get(key)\r\n\r\n        if (!itemSize && !sizes[i].size) {\r\n          if (view) this.unuseView(view)\r\n          continue\r\n        }\r\n\r\n        // No view assigned to item\r\n        if (!view) {\r\n          type = item[typeField]\r\n          unusedPool = unusedViews.get(type)\r\n\r\n          if (continuous) {\r\n            // Reuse existing view\r\n            if (unusedPool && unusedPool.length) {\r\n              view = unusedPool.pop()\r\n              view.item = item\r\n              view.nr.used = true\r\n              view.nr.index = i\r\n              view.nr.key = key\r\n              view.nr.type = type\r\n            } else {\r\n              view = this.addView(pool, i, item, key, type)\r\n            }\r\n          } else {\r\n            // Use existing view\r\n            // We don't care if they are already used\r\n            // because we are not in continous scrolling\r\n            v = unusedIndex.get(type) || 0\r\n\r\n            if (!unusedPool || v >= unusedPool.length) {\r\n              view = this.addView(pool, i, item, key, type)\r\n              this.unuseView(view, true)\r\n              unusedPool = unusedViews.get(type)\r\n            }\r\n\r\n            view = unusedPool[v]\r\n            view.item = item\r\n            view.nr.used = true\r\n            view.nr.index = i\r\n            view.nr.key = key\r\n            view.nr.type = type\r\n            unusedIndex.set(type, v + 1)\r\n            v++\r\n          }\r\n          views.set(key, view)\r\n        } else {\r\n          view.nr.used = true\r\n          view.item = item\r\n        }\r\n\r\n        // Update position\r\n        if (itemSize === null) {\r\n          view.position = sizes[i - 1].accumulator\r\n        } else {\r\n          view.position = i * itemSize\r\n        }\r\n      }\r\n\r\n      this.$_startIndex = startIndex\r\n      this.$_endIndex = endIndex\r\n\r\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex)\r\n\r\n      // After the user has finished scrolling\r\n      // Sort views so text selection is correct\r\n      clearTimeout(this.$_sortTimer)\r\n      this.$_sortTimer = setTimeout(this.sortViews, 300)\r\n\r\n      return {\r\n        continuous,\r\n      }\r\n    },\r\n\r\n    getListenerTarget () {\r\n      let target = ScrollParent(this.$el)\r\n      // Fix global scroll target for Chrome and Safari\r\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\r\n        target = window\r\n      }\r\n      return target\r\n    },\r\n\r\n    getScroll () {\r\n      const { $el: el, direction } = this\r\n      const isVertical = direction === 'vertical'\r\n      let scrollState\r\n\r\n      if (this.pageMode) {\r\n        const bounds = el.getBoundingClientRect()\r\n        const boundsSize = isVertical ? bounds.height : bounds.width\r\n        let start = -(isVertical ? bounds.top : bounds.left)\r\n        let size = isVertical ? window.innerHeight : window.innerWidth\r\n        if (start < 0) {\r\n          size += start\r\n          start = 0\r\n        }\r\n        if (start + size > boundsSize) {\r\n          size = boundsSize - start\r\n        }\r\n        scrollState = {\r\n          start,\r\n          end: start + size,\r\n        }\r\n      } else if (isVertical) {\r\n        scrollState = {\r\n          start: el.scrollTop,\r\n          end: el.scrollTop + el.clientHeight,\r\n        }\r\n      } else {\r\n        scrollState = {\r\n          start: el.scrollLeft,\r\n          end: el.scrollLeft + el.clientWidth,\r\n        }\r\n      }\r\n\r\n      return scrollState\r\n    },\r\n\r\n    applyPageMode () {\r\n      if (this.pageMode) {\r\n        this.addListeners()\r\n      } else {\r\n        this.removeListeners()\r\n      }\r\n    },\r\n\r\n    addListeners () {\r\n      this.listenerTarget = this.getListenerTarget()\r\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {\r\n        passive: true,\r\n      } : false)\r\n      this.listenerTarget.addEventListener('resize', this.handleResize)\r\n    },\r\n\r\n    removeListeners () {\r\n      if (!this.listenerTarget) {\r\n        return\r\n      }\r\n\r\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\r\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\r\n\r\n      this.listenerTarget = null\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      let scroll\r\n      if (this.itemSize === null) {\r\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\r\n      } else {\r\n        scroll = index * this.itemSize\r\n      }\r\n      this.scrollToPosition(scroll)\r\n    },\r\n\r\n    scrollToPosition (position) {\r\n      if (this.direction === 'vertical') {\r\n        this.$el.scrollTop = position\r\n      } else {\r\n        this.$el.scrollLeft = position\r\n      }\r\n    },\r\n\r\n    itemsLimitError () {\r\n      setTimeout(() => {\r\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\r\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\r\n      })\r\n      throw new Error('Rendered items limit reached')\r\n    },\r\n\r\n    sortViews () {\r\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style>\r\n.vue-recycle-scroller {\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\r\n  overflow-y: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\r\n  overflow-x: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal {\r\n  display: flex;\r\n}\r\n\r\n.vue-recycle-scroller__slot {\r\n  flex: auto 0 0;\r\n}\r\n\r\n.vue-recycle-scroller__item-wrapper {\r\n  flex: 1;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  will-change: transform;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\r\n  height: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\r\n  height: 100%;\r\n}\r\n</style>\r\n","<template>\r\n  <div\r\n    v-observe-visibility=\"handleVisibilityChange\"\r\n    class=\"vue-recycle-scroller\"\r\n    :class=\"{\r\n      ready,\r\n      'page-mode': pageMode,\r\n      [`direction-${direction}`]: true,\r\n    }\"\r\n    @scroll.passive=\"handleScroll\"\r\n  >\r\n    <div\r\n      v-if=\"$slots.before\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"before\"\r\n      />\r\n    </div>\r\n\r\n    <div\r\n      ref=\"wrapper\"\r\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\r\n      class=\"vue-recycle-scroller__item-wrapper\"\r\n    >\r\n      <div\r\n        v-for=\"view of pool\"\r\n        :key=\"view.nr.id\"\r\n        :style=\"ready ? { transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px)` } : null\"\r\n        class=\"vue-recycle-scroller__item-view\"\r\n        :class=\"{ hover: hoverKey === view.nr.key }\"\r\n        @mouseenter=\"hoverKey = view.nr.key\"\r\n        @mouseleave=\"hoverKey = null\"\r\n      >\r\n        <slot\r\n          :item=\"view.item\"\r\n          :index=\"view.nr.index\"\r\n          :active=\"view.nr.used\"\r\n        />\r\n      </div>\r\n    </div>\r\n\r\n    <div\r\n      v-if=\"$slots.after\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"after\"\r\n      />\r\n    </div>\r\n\r\n    <ResizeObserver @notify=\"handleResize\" />\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { shallowReactive } from 'vue';\r\nimport { ResizeObserver } from 'vue-resize'\r\nimport { ObserveVisibility } from 'vue-observe-visibility'\r\nimport ScrollParent from 'scrollparent'\r\nimport config from '../config'\r\nimport { props, simpleArray } from './common'\r\nimport { supportsPassive } from '../utils'\r\n\r\nlet uid = 0\r\n\r\nexport default {\r\n  name: 'RecycleScroller',\r\n\r\n  components: {\r\n    ResizeObserver,\r\n  },\r\n\r\n  directives: {\r\n    ObserveVisibility,\r\n  },\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    itemSize: {\r\n      type: Number,\r\n      default: null,\r\n    },\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      default: null,\r\n    },\r\n\r\n    sizeField: {\r\n      type: String,\r\n      default: 'size',\r\n    },\r\n\r\n    typeField: {\r\n      type: String,\r\n      default: 'type',\r\n    },\r\n\r\n    buffer: {\r\n      type: Number,\r\n      default: 200,\r\n    },\r\n\r\n    pageMode: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    prerender: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n\r\n    emitUpdate: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n  },\r\n\r\n  data () {\r\n    return {\r\n      pool: [],\r\n      totalSize: 0,\r\n      ready: false,\r\n      hoverKey: null,\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    sizes () {\r\n      if (this.itemSize === null) {\r\n        const sizes = {\r\n          '-1': { accumulator: 0 },\r\n        }\r\n        const items = this.items\r\n        const field = this.sizeField\r\n        const minItemSize = this.minItemSize\r\n        let computedMinSize = 10000\r\n        let accumulator = 0\r\n        let current\r\n        for (let i = 0, l = items.length; i < l; i++) {\r\n          current = items[i][field] || minItemSize\r\n          if (current < computedMinSize) {\r\n            computedMinSize = current\r\n          }\r\n          accumulator += current\r\n          sizes[i] = { accumulator, size: current }\r\n        }\r\n        // eslint-disable-next-line\r\n        this.$_computedMinItemSize = computedMinSize\r\n        return sizes\r\n      }\r\n      return []\r\n    },\r\n\r\n    simpleArray,\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.updateVisibleItems(true)\r\n    },\r\n\r\n    pageMode () {\r\n      this.applyPageMode()\r\n      this.updateVisibleItems(false)\r\n    },\r\n\r\n    sizes: {\r\n      handler () {\r\n        this.updateVisibleItems(false)\r\n      },\r\n      deep: true,\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_startIndex = 0\r\n    this.$_endIndex = 0\r\n    this.$_views = new Map()\r\n    this.$_unusedViews = new Map()\r\n    this.$_scrollDirty = false\r\n    this.$_lastUpdateScrollPosition = 0\r\n\r\n    // In SSR mode, we also prerender the same number of item for the first render\r\n    // to avoir mismatch between server and client templates\r\n    if (this.prerender) {\r\n      this.$_prerender = true\r\n      this.updateVisibleItems(false)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    this.applyPageMode()\r\n    this.$nextTick(() => {\r\n      // In SSR mode, render the real number of visible items\r\n      this.$_prerender = false\r\n      this.updateVisibleItems(true)\r\n      this.ready = true\r\n    })\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.removeListeners()\r\n  },\r\n\r\n  methods: {\r\n    addView (pool, index, item, key, type) {\r\n      const view = shallowReactive({\r\n        item,\r\n        position: 0,\r\n        nr: {\r\n          id: uid++,\r\n          index,\r\n          used: true,\r\n          key,\r\n          type,\r\n        },\r\n      })\r\n      pool.push(view)\r\n      return view\r\n    },\r\n\r\n    unuseView (view, fake = false) {\r\n      const unusedViews = this.$_unusedViews\r\n      const type = view.nr.type\r\n      let unusedPool = unusedViews.get(type)\r\n      if (!unusedPool) {\r\n        unusedPool = []\r\n        unusedViews.set(type, unusedPool)\r\n      }\r\n      unusedPool.push(view)\r\n      if (!fake) {\r\n        view.nr.used = false\r\n        view.position = -9999\r\n        this.$_views.delete(view.nr.key)\r\n      }\r\n    },\r\n\r\n    handleResize () {\r\n      this.$emit('resize')\r\n      if (this.ready) this.updateVisibleItems(false)\r\n    },\r\n\r\n    handleScroll (event) {\r\n      if (!this.$_scrollDirty) {\r\n        this.$_scrollDirty = true\r\n        requestAnimationFrame(() => {\r\n          this.$_scrollDirty = false\r\n          const { continuous } = this.updateVisibleItems(false, true)\r\n\r\n          // It seems sometimes chrome doesn't fire scroll event :/\r\n          // When non continous scrolling is ending, we force a refresh\r\n          if (!continuous) {\r\n            clearTimeout(this.$_refreshTimout)\r\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\r\n          }\r\n        })\r\n      }\r\n    },\r\n\r\n    handleVisibilityChange (isVisible, entry) {\r\n      if (this.ready) {\r\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\r\n          this.$emit('visible')\r\n          requestAnimationFrame(() => {\r\n            this.updateVisibleItems(false)\r\n          })\r\n        } else {\r\n          this.$emit('hidden')\r\n        }\r\n      }\r\n    },\r\n\r\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\r\n      const itemSize = this.itemSize\r\n      const minItemSize = this.$_computedMinItemSize\r\n      const typeField = this.typeField\r\n      const keyField = this.simpleArray ? null : this.keyField\r\n      const items = this.items\r\n      const count = items.length\r\n      const sizes = this.sizes\r\n      const views = this.$_views\r\n      const unusedViews = this.$_unusedViews\r\n      const pool = this.pool\r\n      let startIndex, endIndex\r\n      let totalSize\r\n\r\n      if (!count) {\r\n        startIndex = endIndex = totalSize = 0\r\n      } else if (this.$_prerender) {\r\n        startIndex = 0\r\n        endIndex = this.prerender\r\n        totalSize = null\r\n      } else {\r\n        const scroll = this.getScroll()\r\n\r\n        // Skip update if use hasn't scrolled enough\r\n        if (checkPositionDiff) {\r\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\r\n          if (positionDiff < 0) positionDiff = -positionDiff\r\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\r\n            return {\r\n              continuous: true,\r\n            }\r\n          }\r\n        }\r\n        this.$_lastUpdateScrollPosition = scroll.start\r\n\r\n        const buffer = this.buffer\r\n        scroll.start -= buffer\r\n        scroll.end += buffer\r\n\r\n        // Variable size mode\r\n        if (itemSize === null) {\r\n          let h\r\n          let a = 0\r\n          let b = count - 1\r\n          let i = ~~(count / 2)\r\n          let oldI\r\n\r\n          // Searching for startIndex\r\n          do {\r\n            oldI = i\r\n            h = sizes[i].accumulator\r\n            if (h < scroll.start) {\r\n              a = i\r\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\r\n              b = i\r\n            }\r\n            i = ~~((a + b) / 2)\r\n          } while (i !== oldI)\r\n          i < 0 && (i = 0)\r\n          startIndex = i\r\n\r\n          // For container style\r\n          totalSize = sizes[count - 1].accumulator\r\n\r\n          // Searching for endIndex\r\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\r\n          if (endIndex === -1) {\r\n            endIndex = items.length - 1\r\n          } else {\r\n            endIndex++\r\n            // Bounds\r\n            endIndex > count && (endIndex = count)\r\n          }\r\n        } else {\r\n          // Fixed size mode\r\n          startIndex = ~~(scroll.start / itemSize)\r\n          endIndex = Math.ceil(scroll.end / itemSize)\r\n\r\n          // Bounds\r\n          startIndex < 0 && (startIndex = 0)\r\n          endIndex > count && (endIndex = count)\r\n\r\n          totalSize = count * itemSize\r\n        }\r\n      }\r\n\r\n      if (endIndex - startIndex > config.itemsLimit) {\r\n        this.itemsLimitError()\r\n      }\r\n\r\n      this.totalSize = totalSize\r\n\r\n      let view\r\n\r\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\r\n\r\n      if (this.$_continuous !== continuous) {\r\n        if (continuous) {\r\n          views.clear()\r\n          unusedViews.clear()\r\n          for (let i = 0, l = pool.length; i < l; i++) {\r\n            view = pool[i]\r\n            this.unuseView(view)\r\n          }\r\n        }\r\n        this.$_continuous = continuous\r\n      } else if (continuous) {\r\n        for (let i = 0, l = pool.length; i < l; i++) {\r\n          view = pool[i]\r\n          if (view.nr.used) {\r\n            // Update view item index\r\n            if (checkItem) {\r\n              view.nr.index = items.findIndex(\r\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item,\r\n              )\r\n            }\r\n\r\n            // Check if index is still in visible range\r\n            if (\r\n              view.nr.index === -1 ||\r\n              view.nr.index < startIndex ||\r\n              view.nr.index >= endIndex\r\n            ) {\r\n              this.unuseView(view)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const unusedIndex = continuous ? null : new Map()\r\n\r\n      let item, type, unusedPool\r\n      let v\r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        item = items[i]\r\n        const key = keyField ? item[keyField] : item\r\n        if (key == null) {\r\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\r\n        }\r\n        view = views.get(key)\r\n\r\n        if (!itemSize && !sizes[i].size) {\r\n          if (view) this.unuseView(view)\r\n          continue\r\n        }\r\n\r\n        // No view assigned to item\r\n        if (!view) {\r\n          type = item[typeField]\r\n          unusedPool = unusedViews.get(type)\r\n\r\n          if (continuous) {\r\n            // Reuse existing view\r\n            if (unusedPool && unusedPool.length) {\r\n              view = unusedPool.pop()\r\n              view.item = item\r\n              view.nr.used = true\r\n              view.nr.index = i\r\n              view.nr.key = key\r\n              view.nr.type = type\r\n            } else {\r\n              view = this.addView(pool, i, item, key, type)\r\n            }\r\n          } else {\r\n            // Use existing view\r\n            // We don't care if they are already used\r\n            // because we are not in continous scrolling\r\n            v = unusedIndex.get(type) || 0\r\n\r\n            if (!unusedPool || v >= unusedPool.length) {\r\n              view = this.addView(pool, i, item, key, type)\r\n              this.unuseView(view, true)\r\n              unusedPool = unusedViews.get(type)\r\n            }\r\n\r\n            view = unusedPool[v]\r\n            view.item = item\r\n            view.nr.used = true\r\n            view.nr.index = i\r\n            view.nr.key = key\r\n            view.nr.type = type\r\n            unusedIndex.set(type, v + 1)\r\n            v++\r\n          }\r\n          views.set(key, view)\r\n        } else {\r\n          view.nr.used = true\r\n          view.item = item\r\n        }\r\n\r\n        // Update position\r\n        if (itemSize === null) {\r\n          view.position = sizes[i - 1].accumulator\r\n        } else {\r\n          view.position = i * itemSize\r\n        }\r\n      }\r\n\r\n      this.$_startIndex = startIndex\r\n      this.$_endIndex = endIndex\r\n\r\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex)\r\n\r\n      // After the user has finished scrolling\r\n      // Sort views so text selection is correct\r\n      clearTimeout(this.$_sortTimer)\r\n      this.$_sortTimer = setTimeout(this.sortViews, 300)\r\n\r\n      return {\r\n        continuous,\r\n      }\r\n    },\r\n\r\n    getListenerTarget () {\r\n      let target = ScrollParent(this.$el)\r\n      // Fix global scroll target for Chrome and Safari\r\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\r\n        target = window\r\n      }\r\n      return target\r\n    },\r\n\r\n    getScroll () {\r\n      const { $el: el, direction } = this\r\n      const isVertical = direction === 'vertical'\r\n      let scrollState\r\n\r\n      if (this.pageMode) {\r\n        const bounds = el.getBoundingClientRect()\r\n        const boundsSize = isVertical ? bounds.height : bounds.width\r\n        let start = -(isVertical ? bounds.top : bounds.left)\r\n        let size = isVertical ? window.innerHeight : window.innerWidth\r\n        if (start < 0) {\r\n          size += start\r\n          start = 0\r\n        }\r\n        if (start + size > boundsSize) {\r\n          size = boundsSize - start\r\n        }\r\n        scrollState = {\r\n          start,\r\n          end: start + size,\r\n        }\r\n      } else if (isVertical) {\r\n        scrollState = {\r\n          start: el.scrollTop,\r\n          end: el.scrollTop + el.clientHeight,\r\n        }\r\n      } else {\r\n        scrollState = {\r\n          start: el.scrollLeft,\r\n          end: el.scrollLeft + el.clientWidth,\r\n        }\r\n      }\r\n\r\n      return scrollState\r\n    },\r\n\r\n    applyPageMode () {\r\n      if (this.pageMode) {\r\n        this.addListeners()\r\n      } else {\r\n        this.removeListeners()\r\n      }\r\n    },\r\n\r\n    addListeners () {\r\n      this.listenerTarget = this.getListenerTarget()\r\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {\r\n        passive: true,\r\n      } : false)\r\n      this.listenerTarget.addEventListener('resize', this.handleResize)\r\n    },\r\n\r\n    removeListeners () {\r\n      if (!this.listenerTarget) {\r\n        return\r\n      }\r\n\r\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\r\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\r\n\r\n      this.listenerTarget = null\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      let scroll\r\n      if (this.itemSize === null) {\r\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\r\n      } else {\r\n        scroll = index * this.itemSize\r\n      }\r\n      this.scrollToPosition(scroll)\r\n    },\r\n\r\n    scrollToPosition (position) {\r\n      if (this.direction === 'vertical') {\r\n        this.$el.scrollTop = position\r\n      } else {\r\n        this.$el.scrollLeft = position\r\n      }\r\n    },\r\n\r\n    itemsLimitError () {\r\n      setTimeout(() => {\r\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\r\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\r\n      })\r\n      throw new Error('Rendered items limit reached')\r\n    },\r\n\r\n    sortViews () {\r\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style>\r\n.vue-recycle-scroller {\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\r\n  overflow-y: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\r\n  overflow-x: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal {\r\n  display: flex;\r\n}\r\n\r\n.vue-recycle-scroller__slot {\r\n  flex: auto 0 0;\r\n}\r\n\r\n.vue-recycle-scroller__item-wrapper {\r\n  flex: 1;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  will-change: transform;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\r\n  height: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\r\n  height: 100%;\r\n}\r\n</style>\r\n","<template>\r\n  <RecycleScroller\r\n    ref=\"scroller\"\r\n    :items=\"itemsWithSize\"\r\n    :min-item-size=\"minItemSize\"\r\n    :direction=\"direction\"\r\n    key-field=\"id\"\r\n    v-bind=\"$attrs\"\r\n    @resize=\"onScrollerResize\"\r\n    @visible=\"onScrollerVisible\"\r\n    v-on=\"listeners\"\r\n  >\r\n    <template slot-scope=\"{ item: itemWithSize, index, active }\">\r\n      <slot\r\n        v-bind=\"{\r\n          item: itemWithSize.item,\r\n          index,\r\n          active,\r\n          itemWithSize\r\n        }\"\r\n      />\r\n    </template>\r\n    <template slot=\"before\">\r\n      <slot name=\"before\" />\r\n    </template>\r\n    <template slot=\"after\">\r\n      <slot name=\"after\" />\r\n    </template>\r\n  </RecycleScroller>\r\n</template>\r\n\r\n<script>\r\nimport RecycleScroller from './RecycleScroller.vue'\r\nimport { props, simpleArray } from './common'\r\n\r\nexport default {\r\n  name: 'DynamicScroller',\r\n\r\n  components: {\r\n    RecycleScroller,\r\n  },\r\n\r\n  inheritAttrs: false,\r\n\r\n  provide () {\r\n    if (typeof ResizeObserver !== 'undefined') {\r\n      this.$_resizeObserver = new ResizeObserver(entries => {\r\n        for (const entry of entries) {\r\n          if (entry.target) {\r\n            const event = new CustomEvent(\r\n              'resize',\r\n              {\r\n                detail: {\r\n                  contentRect: entry.contentRect,\r\n                },\r\n              },\r\n            )\r\n            entry.target.dispatchEvent(event)\r\n          }\r\n        }\r\n      })\r\n    }\r\n\r\n    return {\r\n      vscrollData: this.vscrollData,\r\n      vscrollParent: this,\r\n      vscrollResizeObserver: this.$_resizeObserver,\r\n    }\r\n  },\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      required: true,\r\n    },\r\n  },\r\n\r\n  data () {\r\n    return {\r\n      vscrollData: {\r\n        active: true,\r\n        sizes: {},\r\n        validSizes: {},\r\n        keyField: this.keyField,\r\n        simpleArray: false,\r\n      },\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    simpleArray,\r\n\r\n    itemsWithSize () {\r\n      const result = []\r\n      const { items, keyField, simpleArray } = this\r\n      const sizes = this.vscrollData.sizes\r\n      for (let i = 0; i < items.length; i++) {\r\n        const item = items[i]\r\n        const id = simpleArray ? i : item[keyField]\r\n        let size = sizes[id]\r\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\r\n          size = 0\r\n        }\r\n        result.push({\r\n          item,\r\n          id,\r\n          size,\r\n        })\r\n      }\r\n      return result\r\n    },\r\n\r\n    listeners () {\r\n      const listeners = {}\r\n      for (const key in this.$listeners) {\r\n        if (key !== 'resize' && key !== 'visible') {\r\n          listeners[key] = this.$listeners[key]\r\n        }\r\n      }\r\n      return listeners\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.forceUpdate(false)\r\n    },\r\n\r\n    simpleArray: {\r\n      handler (value) {\r\n        this.vscrollData.simpleArray = value\r\n      },\r\n      immediate: true,\r\n    },\r\n\r\n    direction (value) {\r\n      this.forceUpdate(true)\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_updates = []\r\n    this.$_undefinedSizes = 0\r\n    this.$_undefinedMap = {}\r\n  },\r\n\r\n  activated () {\r\n    this.vscrollData.active = true\r\n  },\r\n\r\n  deactivated () {\r\n    this.vscrollData.active = false\r\n  },\r\n\r\n  methods: {\r\n    onScrollerResize () {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) {\r\n        this.forceUpdate()\r\n      }\r\n      this.$emit('resize')\r\n    },\r\n\r\n    onScrollerVisible () {\r\n      this.$emit('vscroll:update', { force: false })\r\n      this.$emit('visible')\r\n    },\r\n\r\n    forceUpdate (clear = true) {\r\n      if (clear || this.simpleArray) {\r\n        this.vscrollData.validSizes = {}\r\n      }\r\n      this.$emit('vscroll:update', { force: true })\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) scroller.scrollToItem(index)\r\n    },\r\n\r\n    getItemSize (item, index = undefined) {\r\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\r\n      return this.vscrollData.sizes[id] || 0\r\n    },\r\n\r\n    scrollToBottom () {\r\n      if (this.$_scrollingToBottom) return\r\n      this.$_scrollingToBottom = true\r\n      const el = this.$el\r\n      // Item is inserted to the DOM\r\n      this.$nextTick(() => {\r\n        el.scrollTop = el.scrollHeight + 5000\r\n        // Item sizes are computed\r\n        const cb = () => {\r\n          el.scrollTop = el.scrollHeight + 5000\r\n          requestAnimationFrame(() => {\r\n            el.scrollTop = el.scrollHeight + 5000\r\n            if (this.$_undefinedSizes === 0) {\r\n              this.$_scrollingToBottom = false\r\n            } else {\r\n              requestAnimationFrame(cb)\r\n            }\r\n          })\r\n        }\r\n        requestAnimationFrame(cb)\r\n      })\r\n    },\r\n  },\r\n}\r\n</script>\r\n","<template>\r\n  <RecycleScroller\r\n    ref=\"scroller\"\r\n    :items=\"itemsWithSize\"\r\n    :min-item-size=\"minItemSize\"\r\n    :direction=\"direction\"\r\n    key-field=\"id\"\r\n    v-bind=\"$attrs\"\r\n    @resize=\"onScrollerResize\"\r\n    @visible=\"onScrollerVisible\"\r\n    v-on=\"listeners\"\r\n  >\r\n    <template slot-scope=\"{ item: itemWithSize, index, active }\">\r\n      <slot\r\n        v-bind=\"{\r\n          item: itemWithSize.item,\r\n          index,\r\n          active,\r\n          itemWithSize\r\n        }\"\r\n      />\r\n    </template>\r\n    <template slot=\"before\">\r\n      <slot name=\"before\" />\r\n    </template>\r\n    <template slot=\"after\">\r\n      <slot name=\"after\" />\r\n    </template>\r\n  </RecycleScroller>\r\n</template>\r\n\r\n<script>\r\nimport RecycleScroller from './RecycleScroller.vue'\r\nimport { props, simpleArray } from './common'\r\n\r\nexport default {\r\n  name: 'DynamicScroller',\r\n\r\n  components: {\r\n    RecycleScroller,\r\n  },\r\n\r\n  inheritAttrs: false,\r\n\r\n  provide () {\r\n    if (typeof ResizeObserver !== 'undefined') {\r\n      this.$_resizeObserver = new ResizeObserver(entries => {\r\n        for (const entry of entries) {\r\n          if (entry.target) {\r\n            const event = new CustomEvent(\r\n              'resize',\r\n              {\r\n                detail: {\r\n                  contentRect: entry.contentRect,\r\n                },\r\n              },\r\n            )\r\n            entry.target.dispatchEvent(event)\r\n          }\r\n        }\r\n      })\r\n    }\r\n\r\n    return {\r\n      vscrollData: this.vscrollData,\r\n      vscrollParent: this,\r\n      vscrollResizeObserver: this.$_resizeObserver,\r\n    }\r\n  },\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      required: true,\r\n    },\r\n  },\r\n\r\n  data () {\r\n    return {\r\n      vscrollData: {\r\n        active: true,\r\n        sizes: {},\r\n        validSizes: {},\r\n        keyField: this.keyField,\r\n        simpleArray: false,\r\n      },\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    simpleArray,\r\n\r\n    itemsWithSize () {\r\n      const result = []\r\n      const { items, keyField, simpleArray } = this\r\n      const sizes = this.vscrollData.sizes\r\n      for (let i = 0; i < items.length; i++) {\r\n        const item = items[i]\r\n        const id = simpleArray ? i : item[keyField]\r\n        let size = sizes[id]\r\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\r\n          size = 0\r\n        }\r\n        result.push({\r\n          item,\r\n          id,\r\n          size,\r\n        })\r\n      }\r\n      return result\r\n    },\r\n\r\n    listeners () {\r\n      const listeners = {}\r\n      for (const key in this.$listeners) {\r\n        if (key !== 'resize' && key !== 'visible') {\r\n          listeners[key] = this.$listeners[key]\r\n        }\r\n      }\r\n      return listeners\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.forceUpdate(false)\r\n    },\r\n\r\n    simpleArray: {\r\n      handler (value) {\r\n        this.vscrollData.simpleArray = value\r\n      },\r\n      immediate: true,\r\n    },\r\n\r\n    direction (value) {\r\n      this.forceUpdate(true)\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_updates = []\r\n    this.$_undefinedSizes = 0\r\n    this.$_undefinedMap = {}\r\n  },\r\n\r\n  activated () {\r\n    this.vscrollData.active = true\r\n  },\r\n\r\n  deactivated () {\r\n    this.vscrollData.active = false\r\n  },\r\n\r\n  methods: {\r\n    onScrollerResize () {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) {\r\n        this.forceUpdate()\r\n      }\r\n      this.$emit('resize')\r\n    },\r\n\r\n    onScrollerVisible () {\r\n      this.$emit('vscroll:update', { force: false })\r\n      this.$emit('visible')\r\n    },\r\n\r\n    forceUpdate (clear = true) {\r\n      if (clear || this.simpleArray) {\r\n        this.vscrollData.validSizes = {}\r\n      }\r\n      this.$emit('vscroll:update', { force: true })\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) scroller.scrollToItem(index)\r\n    },\r\n\r\n    getItemSize (item, index = undefined) {\r\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\r\n      return this.vscrollData.sizes[id] || 0\r\n    },\r\n\r\n    scrollToBottom () {\r\n      if (this.$_scrollingToBottom) return\r\n      this.$_scrollingToBottom = true\r\n      const el = this.$el\r\n      // Item is inserted to the DOM\r\n      this.$nextTick(() => {\r\n        el.scrollTop = el.scrollHeight + 5000\r\n        // Item sizes are computed\r\n        const cb = () => {\r\n          el.scrollTop = el.scrollHeight + 5000\r\n          requestAnimationFrame(() => {\r\n            el.scrollTop = el.scrollHeight + 5000\r\n            if (this.$_undefinedSizes === 0) {\r\n              this.$_scrollingToBottom = false\r\n            } else {\r\n              requestAnimationFrame(cb)\r\n            }\r\n          })\r\n        }\r\n        requestAnimationFrame(cb)\r\n      })\r\n    },\r\n  },\r\n}\r\n</script>\r\n","<script>\r\nexport default {\r\n  name: 'DynamicScrollerItem',\r\n\r\n  inject: [\r\n    'vscrollData',\r\n    'vscrollParent',\r\n    'vscrollResizeObserver',\r\n  ],\r\n\r\n  props: {\r\n    // eslint-disable-next-line vue/require-prop-types\r\n    item: {\r\n      required: true,\r\n    },\r\n\r\n    watchData: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    /**\r\n     * Indicates if the view is actively used to display an item.\r\n     */\r\n    active: {\r\n      type: Boolean,\r\n      required: true,\r\n    },\r\n\r\n    index: {\r\n      type: Number,\r\n      default: undefined,\r\n    },\r\n\r\n    sizeDependencies: {\r\n      type: [Array, Object],\r\n      default: null,\r\n    },\r\n\r\n    emitResize: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    tag: {\r\n      type: String,\r\n      default: 'div',\r\n    },\r\n  },\r\n\r\n  computed: {\r\n    id () {\r\n      return this.vscrollData.simpleArray ? this.index : this.item[this.vscrollData.keyField]\r\n    },\r\n\r\n    size () {\r\n      return (this.vscrollData.validSizes[this.id] && this.vscrollData.sizes[this.id]) || 0\r\n    },\r\n\r\n    finalActive () {\r\n      return this.active && this.vscrollData.active\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    watchData: 'updateWatchData',\r\n\r\n    id () {\r\n      if (!this.size) {\r\n        this.onDataUpdate()\r\n      }\r\n    },\r\n\r\n    finalActive (value) {\r\n      if (!this.size) {\r\n        if (value) {\r\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\r\n            this.vscrollParent.$_undefinedSizes++\r\n            this.vscrollParent.$_undefinedMap[this.id] = true\r\n          }\r\n        } else {\r\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\r\n            this.vscrollParent.$_undefinedSizes--\r\n            this.vscrollParent.$_undefinedMap[this.id] = false\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.vscrollResizeObserver) {\r\n        if (value) {\r\n          this.observeSize()\r\n        } else {\r\n          this.unobserveSize()\r\n        }\r\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\r\n        this.updateSize()\r\n      }\r\n    },\r\n  },\r\n\r\n  created () {\r\n    if (this.$isServer) return\r\n\r\n    this.$_forceNextVScrollUpdate = null\r\n    this.updateWatchData()\r\n\r\n    if (!this.vscrollResizeObserver) {\r\n      for (const k in this.sizeDependencies) {\r\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate)\r\n      }\r\n\r\n      this.vscrollParent.$on('vscroll:update', this.onVscrollUpdate)\r\n      this.vscrollParent.$on('vscroll:update-size', this.onVscrollUpdateSize)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    if (this.vscrollData.active) {\r\n      this.updateSize()\r\n      this.observeSize()\r\n    }\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.vscrollParent.$off('vscroll:update', this.onVscrollUpdate)\r\n    this.vscrollParent.$off('vscroll:update-size', this.onVscrollUpdateSize)\r\n    this.unobserveSize()\r\n  },\r\n\r\n  methods: {\r\n    updateSize () {\r\n      if (this.finalActive) {\r\n        if (this.$_pendingSizeUpdate !== this.id) {\r\n          this.$_pendingSizeUpdate = this.id\r\n          this.$_forceNextVScrollUpdate = null\r\n          this.$_pendingVScrollUpdate = null\r\n          this.computeSize(this.id)\r\n        }\r\n      } else {\r\n        this.$_forceNextVScrollUpdate = this.id\r\n      }\r\n    },\r\n\r\n    updateWatchData () {\r\n      if (this.watchData) {\r\n        this.$_watchData = this.$watch('data', () => {\r\n          this.onDataUpdate()\r\n        }, {\r\n          deep: true,\r\n        })\r\n      } else if (this.$_watchData) {\r\n        this.$_watchData()\r\n        this.$_watchData = null\r\n      }\r\n    },\r\n\r\n    onVscrollUpdate ({ force }) {\r\n      // If not active, sechedule a size update when it becomes active\r\n      if (!this.finalActive && force) {\r\n        this.$_pendingVScrollUpdate = this.id\r\n      }\r\n\r\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\r\n        this.updateSize()\r\n      }\r\n    },\r\n\r\n    onDataUpdate () {\r\n      this.updateSize()\r\n    },\r\n\r\n    computeSize (id) {\r\n      this.$nextTick(() => {\r\n        if (this.id === id) {\r\n          const width = this.$el.offsetWidth\r\n          const height = this.$el.offsetHeight\r\n          this.applySize(width, height)\r\n        }\r\n        this.$_pendingSizeUpdate = null\r\n      })\r\n    },\r\n\r\n    applySize (width, height) {\r\n      const size = Math.round(this.vscrollParent.direction === 'vertical' ? height : width)\r\n      if (size && this.size !== size) {\r\n        if (this.vscrollParent.$_undefinedMap[this.id]) {\r\n          this.vscrollParent.$_undefinedSizes--\r\n          this.vscrollParent.$_undefinedMap[this.id] = undefined\r\n        }\r\n        this.$set(this.vscrollData.sizes, this.id, size)\r\n        this.$set(this.vscrollData.validSizes, this.id, true)\r\n        if (this.emitResize) this.$emit('resize', this.id)\r\n      }\r\n    },\r\n\r\n    observeSize () {\r\n      if (!this.vscrollResizeObserver) return\r\n      this.vscrollResizeObserver.observe(this.$el.parentNode)\r\n      this.$el.parentNode.addEventListener('resize', this.onResize)\r\n    },\r\n\r\n    unobserveSize () {\r\n      if (!this.vscrollResizeObserver) return\r\n      this.vscrollResizeObserver.unobserve(this.$el.parentNode)\r\n      this.$el.parentNode.removeEventListener('resize', this.onResize)\r\n    },\r\n\r\n    onResize (event) {\r\n      const { width, height } = event.detail.contentRect\r\n      this.applySize(width, height)\r\n    },\r\n  },\r\n\r\n  render (h) {\r\n    console.log('render', h);\r\n    return h(this.tag, this.$slots.default)\r\n  },\r\n}\r\n</script>\r\n","import { reactive } from 'vue'\r\n\r\nexport default function ({\r\n  idProp = vm => vm.item.id,\r\n} = {}) {\r\n  const store = reactive({})\r\n\r\n  // @vue/component\r\n  return {\r\n    data () {\r\n      return {\r\n        idState: null,\r\n      }\r\n    },\r\n\r\n    created () {\r\n      this.$_id = null\r\n      if (typeof idProp === 'function') {\r\n        this.$_getId = () => idProp.call(this, this)\r\n      } else {\r\n        this.$_getId = () => this[idProp]\r\n      }\r\n      this.$watch(this.$_getId, {\r\n        handler (value) {\r\n          this.$nextTick(() => {\r\n            this.$_id = value\r\n          })\r\n        },\r\n        immediate: true,\r\n      })\r\n      this.$_updateIdState()\r\n    },\r\n\r\n    beforeUpdate () {\r\n      this.$_updateIdState()\r\n    },\r\n\r\n    methods: {\r\n      /**\r\n       * Initialize an idState\r\n       * @param {number|string} id Unique id for the data\r\n       */\r\n      $_idStateInit (id) {\r\n        const factory = this.$options.idState\r\n        if (typeof factory === 'function') {\r\n          const data = factory.call(this, this)\r\n          store[id] = data\r\n          this.$_id = id\r\n          return data\r\n        } else {\r\n          throw new Error('[mixin IdState] Missing `idState` function on component definition.')\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Ensure idState is created and up-to-date\r\n       */\r\n      $_updateIdState () {\r\n        const id = this.$_getId()\r\n        if (id == null) {\r\n          console.warn(`No id found for IdState with idProp: '${idProp}'.`)\r\n        }\r\n        if (id !== this.$_id) {\r\n          if (!store[id]) {\r\n            this.$_idStateInit(id)\r\n          }\r\n          this.idState = store[id]\r\n        }\r\n      },\r\n    },\r\n  }\r\n}\r\n","import config from './config'\r\n\r\nimport RecycleScroller from './components/RecycleScroller.vue'\r\nimport DynamicScroller from './components/DynamicScroller.vue'\r\nimport DynamicScrollerItem from './components/DynamicScrollerItem.vue'\r\n\r\nexport { default as IdState } from './mixins/IdState'\r\n\r\nexport {\r\n  RecycleScroller,\r\n  DynamicScroller,\r\n  DynamicScrollerItem,\r\n}\r\n\r\nfunction registerComponents (Vue, prefix) {\r\n  Vue.component(`${prefix}recycle-scroller`, RecycleScroller)\r\n  Vue.component(`${prefix}RecycleScroller`, RecycleScroller)\r\n  Vue.component(`${prefix}dynamic-scroller`, DynamicScroller)\r\n  Vue.component(`${prefix}DynamicScroller`, DynamicScroller)\r\n  Vue.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\r\n  Vue.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\r\n}\r\n\r\nconst plugin = {\r\n  // eslint-disable-next-line no-undef\r\n  version: VERSION,\r\n  install (Vue, options) {\r\n    const finalOptions = Object.assign({}, {\r\n      installComponents: true,\r\n      componentsPrefix: '',\r\n    }, options)\r\n\r\n    for (const key in finalOptions) {\r\n      if (typeof finalOptions[key] !== 'undefined') {\r\n        config[key] = finalOptions[key]\r\n      }\r\n    }\r\n\r\n    if (finalOptions.installComponents) {\r\n      registerComponents(Vue, finalOptions.componentsPrefix)\r\n    }\r\n  },\r\n}\r\n\r\nexport default plugin\r\n\r\n// Auto-install\r\nlet GlobalVue = null\r\nif (typeof window !== 'undefined') {\r\n  GlobalVue = window.Vue\r\n} else if (typeof global !== 'undefined') {\r\n  GlobalVue = global.Vue\r\n}\r\nif (GlobalVue) {\r\n  GlobalVue.use(plugin)\r\n}\r\n"],"names":["itemsLimit","_typeof","obj","Symbol","_typeof2","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","arr2","iter","toString","call","from","makeMap","str","expectsLowerCase","map","create","list","split","val","toLowerCase","GLOBALS_WHITE_LISTED","isGloballyWhitelisted","specialBooleanAttrs","isSpecialBooleanAttr","normalizeStyle","value","res","item","normalized","isString","parseStringStyle","isObject","listDelimiterRE","propertyDelimiterRE","cssText","ret","forEach","tmp","trim","normalizeClass","name","EMPTY_OBJ","process","env","NODE_ENV","freeze","EMPTY_ARR","NOOP","onRE","isOn","test","isModelListener","startsWith","extend","assign","remove","el","indexOf","splice","hasOwnProperty","hasOwn","isMap","toTypeString","isSet","isFunction","isSymbol","isPromise","then","catch","objectToString","toRawType","slice","isIntegerKey","parseInt","cacheStringFunction","fn","cache","hit","camelizeRE","camelize","replace","_","c","toUpperCase","hyphenateRE","hyphenate","capitalize","charAt","hasChanged","oldValue","_globalThis","getGlobalThis","globalThis","self","window","global","targetMap","WeakMap","effectStack","activeEffect","ITERATE_KEY","MAP_KEY_ITERATE_KEY","isEffect","_isEffect","effect","options","raw","createReactiveEffect","lazy","stop","active","cleanup","onStop","uid","reactiveEffect","scheduler","undefined","includes","enableTracking","push","pop","resetTracking","id","allowRecurse","deps","delete","shouldTrack","trackStack","pauseTracking","last","track","type","depsMap","get","set","Map","dep","Set","has","add","onTrack","trigger","newValue","oldTarget","effects","effectsToAdd","run","onTrigger","builtInSymbols","getOwnPropertyNames","filter","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","method","toRaw","l","args","apply","isReadonly","shallow","receiver","readonlyMap","reactiveMap","targetIsArray","Reflect","isRef","shouldUnwrap","readonly","reactive","createSetter","shallowSet","hadKey","Number","result","deleteProperty","ownKeys","mutableHandlers","readonlyHandlers","console","warn","String","shallowReactiveHandlers","shallowReadonlyHandlers","toReactive","toReadonly","toShallow","getProto","v","getPrototypeOf","get$1","isShallow","rawTarget","rawKey","wrap","has$1","size","proto","set$1","checkIdentityKeys","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","targetIsMap","isPair","isKeyOnly","innerIterator","next","done","createReadonlyMethod","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","iteratorMethods","createInstrumentationGetter","instrumentations","mutableCollectionHandlers","readonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","r","Boolean","__v_isRef","stack","pushWarningContext","vnode","popWarningContext","msg","component","appWarnHandler","appContext","config","warnHandler","trace","getComponentTrace","callWithErrorHandling","join","formatComponentName","warnArgs","formatTrace","currentVNode","normalizedStack","recurseCount","parentInstance","parent","logs","entry","formatTraceEntry","postfix","isRoot","open","close","formatProps","keys","formatProp","JSON","stringify","ErrorTypeStrings","err","handleError","callWithAsyncErrorHandling","values","throwInDev","contextVNode","cur","exposedInstance","errorInfo","errorCapturedHooks","ec","appErrorHandler","errorHandler","logError","info","error","isFlushing","isFlushPending","queue","flushIndex","pendingPreFlushCbs","activePreFlushCbs","preFlushIndex","pendingPostFlushCbs","activePostFlushCbs","postFlushIndex","resolvedPromise","Promise","resolve","currentFlushPromise","currentPreFlushParentJob","RECURSION_LIMIT","nextTick","p","bind","queueJob","job","queueFlush","flushJobs","queueCb","cb","activeQueue","pendingQueue","index","queuePreFlushCb","queuePostFlushCb","flushPreFlushCbs","seen","parentJob","checkRecursiveUpdates","flushPostFlushCbs","deduped","sort","a","b","getId","Infinity","count","Error","hmrDirtyComponents","globalObject","__VUE_HMR_RUNTIME__","createRecord","tryWrap","rerender","reload","isClassComponent","__vccOpts","instances","newRender","record","render","renderCache","update","newComp","location","arg","e","setDevtoolsHook","hook","currentRenderingInstance","markAttrsAccessed","filterSingleRoot","children","singleRoot","child","isVNode","Comment","isSuspense","__isSuspense","normalizeSuspenseChildren","shapeFlag","content","fallback","normalizeSuspenseSlot","default","normalizeVNode","s","singleChild","queueEffectWithSuspense","suspense","pendingBranch","isRenderingCompiledSlot","setCompiledSlotRendering","n","currentScopeId","INITIAL_WATCHER_VALUE","doWatch","source","immediate","deep","flush","currentInstance","warnInvalidSource","getter","forceTrigger","_shallow","traverse","isUnmounted","onInvalidate","baseGetter","runner","queuePostRenderEffect","isMounted","recordInstanceBoundEffect","instanceWatch","publicThis","isTeleport","__isTeleport","NULL_DYNAMIC_COMPONENT","Fragment","Text","Static","currentBlock","__v_isVNode","createVNodeWithArgsTransform","_createVNode","InternalObjectKey","normalizeKey","normalizeRef","ref","createVNode","patchFlag","dynamicProps","isBlockNode","cloned","cloneVNode","normalizeChildren","klass","class","style","ssContent","ssFallback","extraProps","mergeRef","mergedProps","mergeProps","concat","scopeId","targetAnchor","staticCount","dynamicChildren","dirs","transition","anchor","createTextVNode","text","flag","slot","_c","slotFlag","_ctx","toMerge","existing","incoming","isInBeforeCreate","resolveMergedOptions","__merged","mixins","extendsOptions","extends","globalMixins","m","mergeOptions","to","strats","optionMergeStrategies","getPublicInstance","publicPropertiesMap","$","$el","$data","data","$props","$attrs","attrs","$slots","slots","$refs","refs","$parent","$root","root","$emit","emit","$options","__VUE_OPTIONS_API__","$forceUpdate","$nextTick","$watch","PublicInstanceProxyHandlers","ctx","setupState","accessCache","normalizedProps","propsOptions","publicGetter","cssModule","globalProperties","__cssModules","RuntimeCompiledPublicInstanceProxyHandlers","unscopables","classifyRE","classify","Component","displayName","__file","match","inferFromRegistry","registry","components","ssrContextKey","initCustomFormatter","vueStyle","numberStyle","stringStyle","keywordStyle","formatter","header","__isVue","genRefFlag","formatValue","hasBody","body","formatInstance","blocks","createInstanceBlock","computed","extractKeys","injected","object","asRaw","Comp","extracted","isKeyOfType","opts","some","devtoolsFormatters","svgNS","doc","document","tempContainer","tempSVGContainer","nodeOps","insert","insertBefore","parentNode","removeChild","createElement","tag","isSVG","is","createElementNS","createText","createTextNode","createComment","setText","node","nodeValue","setElementText","textContent","nextSibling","querySelector","selector","setScopeId","setAttribute","cloneNode","insertStaticContent","temp","innerHTML","first","firstChild","patchClass","transitionClasses","_vtc","className","patchStyle","prev","removeAttribute","setStyle","importantRE","setProperty","prefixed","autoPrefix","prefixes","prefixCache","rawName","cached","xlinkNS","patchAttr","removeAttributeNS","setAttributeNS","isBoolean","patchDOMProp","prevChildren","parentComponent","parentSuspense","unmountChildren","tagName","_value","_getNow","Date","now","createEvent","timeStamp","performance","cachedNow","reset","getNow","addEventListener","event","handler","removeEventListener","patchEvent","prevValue","nextValue","invokers","_vei","existingInvoker","parseName","invoker","createInvoker","optionsModifierRE","initialValue","attached","patchStopImmediatePropagation","originalStop","stopImmediatePropagation","_stopped","nativeOnRE","forcePatchProp","patchProp","shouldSetAsProp","_trueValue","_falseValue","rendererOptions","initDev","__VUE__","__VUE_DEVTOOLS_GLOBAL_HOOK__","processOptions","throttle","delay","arguments","timeout","lastState","currentArgs","throttled","state","_len","_key","leading","clearTimeout","setTimeout","_clear","deepEqual","val1","val2","VisibilityState","observer","frozen","createObserver","_this","destroyObserver","once","_ref","throttleOptions","_leading","oldResult","IntersectionObserver","entries","intersectingEntry","find","isIntersecting","intersectionRatio","threshold","intersection","observe","disconnect","_ref2","_vue_visibilityState","_ref3","unbind","ObserveVisibility","beforeMount","updated","unmounted","install","Vue","directive","plugin","version","GlobalVue","use","this","items","required","keyField","direction","validator","simpleArray","supportsPassive","ResizeObserver","directives","itemSize","minItemSize","sizeField","typeField","buffer","pageMode","prerender","emitUpdate","pool","totalSize","ready","hoverKey","sizes","accumulator","field","computedMinSize","current","$_computedMinItemSize","watch","updateVisibleItems","applyPageMode","created","$_startIndex","$_endIndex","$_views","$_unusedViews","$_scrollDirty","$_lastUpdateScrollPosition","$_prerender","mounted","beforeUnmount","removeListeners","methods","addView","view","shallowReactive","position","nr","used","unuseView","fake","unusedViews","unusedPool","handleResize","handleScroll","requestAnimationFrame","continuous","$_refreshTimout","handleVisibilityChange","isVisible","boundingClientRect","width","height","checkItem","checkPositionDiff","views","startIndex","endIndex","scroll","getScroll","positionDiff","start","end","h","oldI","Math","ceil","itemsLimitError","$_continuous","findIndex","unusedIndex","$_sortTimer","sortViews","getListenerTarget","ScrollParent","documentElement","isVertical","scrollState","bounds","getBoundingClientRect","boundsSize","top","left","innerHeight","innerWidth","scrollTop","clientHeight","scrollLeft","clientWidth","addListeners","listenerTarget","passive","scrollToItem","scrollToPosition","log","viewA","viewB","_createBlock","before","_hoisted_1","_renderSlot","onMouseenter","onMouseleave","after","_hoisted_2","onNotify","RecycleScroller","inheritAttrs","provide","$_resizeObserver","CustomEvent","detail","contentRect","dispatchEvent","vscrollData","vscrollParent","vscrollResizeObserver","validSizes","itemsWithSize","$_undefinedMap","listeners","$listeners","forceUpdate","$_updates","$_undefinedSizes","activated","deactivated","onScrollerResize","scroller","onScrollerVisible","force","getItemSize","scrollToBottom","$_scrollingToBottom","scrollHeight","_mergeProps","onResize","onVisible","_toHandlers","_hoisted_3","inject","watchData","sizeDependencies","emitResize","finalActive","onDataUpdate","observeSize","unobserveSize","$_pendingVScrollUpdate","updateSize","$isServer","$_forceNextVScrollUpdate","updateWatchData","k","$on","onVscrollUpdate","onVscrollUpdateSize","$off","$_pendingSizeUpdate","computeSize","$_watchData","offsetWidth","offsetHeight","applySize","round","$set","unobserve","idProp","vm","store","idState","$_id","$_getId","$_updateIdState","beforeUpdate","$_idStateInit","factory","registerComponents","prefix","DynamicScroller","DynamicScrollerItem","VERSION","finalOptions","installComponents","componentsPrefix"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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"}