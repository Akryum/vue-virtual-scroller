{"version":3,"file":"vue-virtual-scroller.min.js","sources":["../src/config.js","../../vue-resize/dist/vue-resize.esm.js","../../vue-observe-visibility/dist/vue-observe-visibility.esm.js","../node_modules/scrollparent/scrollparent.js","../src/components/common.js","../src/utils.js","../src/components/RecycleScroller.vue","../src/components/RecycleScroller.vue?vue&type=template&id=093a936d&lang.js","../src/components/DynamicScroller.vue","../src/components/DynamicScroller.vue?vue&type=template&id=76e15f19&lang.js","../src/components/DynamicScrollerItem.vue","../src/index.js","../src/mixins/IdState.js"],"sourcesContent":["export default {\r\n  itemsLimit: 1000,\r\n}\r\n","/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            res += normalizeClass(value[i]) + ' ';\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst NOOP = () => { };\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if ((process.env.NODE_ENV !== 'production') && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key)\r\n            ? builtInSymbols.has(key)\r\n            : key === `__proto__` || key === `__v_isRef`) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    target.add(value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    pauseTracking();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    resetTracking();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (isString(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (isRef(value)) {\r\n        value = formatProp(key, toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (isFunction(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n    [\"c\" /* CREATED */]: 'created hook',\r\n    [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n    [\"m\" /* MOUNTED */]: 'mounted hook',\r\n    [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n    [\"u\" /* UPDATED */]: 'updated',\r\n    [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n    [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n    [\"a\" /* ACTIVATED */]: 'activated hook',\r\n    [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n    [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n    [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n    [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n    [0 /* SETUP_FUNCTION */]: 'setup function',\r\n    [1 /* RENDER_FUNCTION */]: 'render function',\r\n    [2 /* WATCH_GETTER */]: 'watcher getter',\r\n    [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n    [7 /* VNODE_HOOK */]: 'vnode hook',\r\n    [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n    [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n    [12 /* FUNCTION_REF */]: 'ref function',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (isFunction(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && isPromise(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = (process.env.NODE_ENV !== 'production') ? ErrorTypeStrings[type] : type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const info = ErrorTypeStrings[type];\r\n        if (contextVNode) {\r\n            pushWarningContext(contextVNode);\r\n        }\r\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\r\n        if (contextVNode) {\r\n            popWarningContext();\r\n        }\r\n        // crash in dev by default so it's more noticeable\r\n        if (throwInDev) {\r\n            throw err;\r\n        }\r\n        else {\r\n            console.error(err);\r\n        }\r\n    }\r\n    else {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        queue.push(job);\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!isArray(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex]);\r\n            }\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex]);\r\n            }\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        seen = seen || new Map();\r\n    }\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkRecursiveUpdates(seen, job);\r\n                }\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length || pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            throw new Error(`Maximum recursive updates exceeded. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\nconst hmrDirtyComponents = new Set();\r\n// Expose the HMR runtime on the global object\r\n// This makes it entirely tree-shakable without polluting the exports and makes\r\n// it easier to be used in toolings like vue-loader\r\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n// to be set so that its instances can be registered / removed.\r\nif ((process.env.NODE_ENV !== 'production')) {\r\n    const globalObject = typeof global !== 'undefined'\r\n        ? global\r\n        : typeof self !== 'undefined'\r\n            ? self\r\n            : typeof window !== 'undefined'\r\n                ? window\r\n                : {};\r\n    globalObject.__VUE_HMR_RUNTIME__ = {\r\n        createRecord: tryWrap(createRecord),\r\n        rerender: tryWrap(rerender),\r\n        reload: tryWrap(reload)\r\n    };\r\n}\r\nconst map = new Map();\r\nfunction createRecord(id, component) {\r\n    if (!component) {\r\n        warn(`HMR API usage is out of date.\\n` +\r\n            `Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ` +\r\n            `depdendency that handles Vue SFC compilation.`);\r\n        component = {};\r\n    }\r\n    if (map.has(id)) {\r\n        return false;\r\n    }\r\n    map.set(id, {\r\n        component: isClassComponent(component) ? component.__vccOpts : component,\r\n        instances: new Set()\r\n    });\r\n    return true;\r\n}\r\nfunction rerender(id, newRender) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    if (newRender)\r\n        record.component.render = newRender;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    Array.from(record.instances).forEach(instance => {\r\n        if (newRender) {\r\n            instance.render = newRender;\r\n        }\r\n        instance.renderCache = [];\r\n        instance.update();\r\n    });\r\n}\r\nfunction reload(id, newComp) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    const { component, instances } = record;\r\n    if (!hmrDirtyComponents.has(component)) {\r\n        // 1. Update existing comp definition to match new one\r\n        newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;\r\n        extend(component, newComp);\r\n        for (const key in component) {\r\n            if (!(key in newComp)) {\r\n                delete component[key];\r\n            }\r\n        }\r\n        // 2. Mark component dirty. This forces the renderer to replace the component\r\n        // on patch.\r\n        hmrDirtyComponents.add(component);\r\n        // 3. Make sure to unmark the component after the reload.\r\n        queuePostFlushCb(() => {\r\n            hmrDirtyComponents.delete(component);\r\n        });\r\n    }\r\n    Array.from(instances).forEach(instance => {\r\n        if (instance.parent) {\r\n            // 4. Force the parent instance to re-render. This will cause all updated\r\n            // components to be unmounted and re-mounted. Queue the update so that we\r\n            // don't end up forcing the same parent to re-render multiple times.\r\n            queueJob(instance.parent.update);\r\n        }\r\n        else if (instance.appContext.reload) {\r\n            // root instance mounted via createApp() has a reload method\r\n            instance.appContext.reload();\r\n        }\r\n        else if (typeof window !== 'undefined') {\r\n            // root instance inside tree created via raw render(). Force reload.\r\n            window.location.reload();\r\n        }\r\n        else {\r\n            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\r\n        }\r\n    });\r\n}\r\nfunction tryWrap(fn) {\r\n    return (id, arg) => {\r\n        try {\r\n            return fn(id, arg);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\r\n                `Full reload required.`);\r\n        }\r\n    };\r\n}\nfunction setDevtoolsHook(hook) {\r\n}\r\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nfunction setCurrentRenderingInstance(instance) {\r\n    currentRenderingInstance = instance;\r\n}\r\nfunction markAttrsAccessed() {\r\n}\r\nfunction filterSingleRoot(children) {\r\n    let singleRoot;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (isVNode(child)) {\r\n            // ignore user comment\r\n            if (child.type !== Comment || child.children === 'v-if') {\r\n                if (singleRoot) {\r\n                    // has more than 1 non-comment child, return now\r\n                    return;\r\n                }\r\n                else {\r\n                    singleRoot = child;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    return singleRoot;\r\n}\r\n\nconst isSuspense = (type) => type.__isSuspense;\r\nfunction normalizeSuspenseChildren(vnode) {\r\n    const { shapeFlag, children } = vnode;\r\n    let content;\r\n    let fallback;\r\n    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        content = normalizeSuspenseSlot(children.default);\r\n        fallback = normalizeSuspenseSlot(children.fallback);\r\n    }\r\n    else {\r\n        content = normalizeSuspenseSlot(children);\r\n        fallback = normalizeVNode(null);\r\n    }\r\n    return {\r\n        content,\r\n        fallback\r\n    };\r\n}\r\nfunction normalizeSuspenseSlot(s) {\r\n    if (isFunction(s)) {\r\n        s = s();\r\n    }\r\n    if (isArray(s)) {\r\n        const singleChild = filterSingleRoot(s);\r\n        if ((process.env.NODE_ENV !== 'production') && !singleChild) {\r\n            warn(`<Suspense> slots expect a single root node.`);\r\n        }\r\n        s = singleChild;\r\n    }\r\n    return normalizeVNode(s);\r\n}\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if (isArray(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\n\nlet isRenderingCompiledSlot = 0;\r\nconst setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);\r\n\n/**\r\n * Wrap a slot function to memoize current rendering instance\r\n * @private\r\n */\r\nfunction withCtx(fn, ctx = currentRenderingInstance) {\r\n    if (!ctx)\r\n        return fn;\r\n    const renderFnWithContext = (...args) => {\r\n        // If a user calls a compiled slot inside a template expression (#1745), it\r\n        // can mess up block tracking, so by default we need to push a null block to\r\n        // avoid that. This isn't necessary if rendering a compiled `<slot>`.\r\n        if (!isRenderingCompiledSlot) {\r\n            openBlock(true /* null block that disables tracking */);\r\n        }\r\n        const owner = currentRenderingInstance;\r\n        setCurrentRenderingInstance(ctx);\r\n        const res = fn(...args);\r\n        setCurrentRenderingInstance(owner);\r\n        if (!isRenderingCompiledSlot) {\r\n            closeBlock();\r\n        }\r\n        return res;\r\n    };\r\n    renderFnWithContext._c = true;\r\n    return renderFnWithContext;\r\n}\n\n// SFC scoped style ID management.\r\nlet currentScopeId = null;\r\nconst scopeIdStack = [];\r\n/**\r\n * @private\r\n */\r\nfunction pushScopeId(id) {\r\n    scopeIdStack.push((currentScopeId = id));\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction popScopeId() {\r\n    scopeIdStack.pop();\r\n    currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction withScopeId(id) {\r\n    return ((fn) => withCtx(function () {\r\n        pushScopeId(id);\r\n        const res = fn.apply(this, arguments);\r\n        popScopeId();\r\n        return res;\r\n    }));\r\n}\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ, instance = currentInstance) {\r\n    if ((process.env.NODE_ENV !== 'production') && !cb) {\r\n        if (immediate !== undefined) {\r\n            warn(`watch() \"immediate\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n        if (deep !== undefined) {\r\n            warn(`watch() \"deep\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n    }\r\n    const warnInvalidSource = (s) => {\r\n        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n            `a reactive object, or an array of these types.`);\r\n    };\r\n    let getter;\r\n    let forceTrigger = false;\r\n    if (isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = !!source._shallow;\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        getter = () => source.map(s => {\r\n            if (isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (isFunction(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);\r\n            }\r\n            else {\r\n                (process.env.NODE_ENV !== 'production') && warnInvalidSource(s);\r\n            }\r\n        });\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = NOOP;\r\n        (process.env.NODE_ENV !== 'production') && warnInvalidSource(source);\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    const onInvalidate = (fn) => {\r\n        cleanup = runner.options.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!runner.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = runner();\r\n            if (deep || forceTrigger || hasChanged(newValue, oldValue)) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onInvalidate\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            runner();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = job;\r\n    }\r\n    else if (flush === 'post') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: 'pre'\r\n        scheduler = () => {\r\n            if (!instance || instance.isMounted) {\r\n                queuePreFlushCb(job);\r\n            }\r\n            else {\r\n                // with 'pre' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    const runner = effect(getter, {\r\n        lazy: true,\r\n        onTrack,\r\n        onTrigger,\r\n        scheduler\r\n    });\r\n    recordInstanceBoundEffect(runner, instance);\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = runner();\r\n        }\r\n    }\r\n    else if (flush === 'post') {\r\n        queuePostRenderEffect(runner, instance && instance.suspense);\r\n    }\r\n    else {\r\n        runner();\r\n    }\r\n    return () => {\r\n        stop(runner);\r\n        if (instance) {\r\n            remove(instance.effects, runner);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, cb, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = isString(source)\r\n        ? () => publicThis[source]\r\n        : source.bind(publicThis);\r\n    return doWatch(getter, cb.bind(publicThis), options, this);\r\n}\r\nfunction traverse(value, seen = new Set()) {\r\n    if (!isObject(value) || seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (isSet(value) || isMap(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\nconst queuePostRenderEffect =  queueEffectWithSuspense\r\n    ;\r\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n\nconst Fragment = Symbol((process.env.NODE_ENV !== 'production') ? 'Fragment' : undefined);\r\nconst Text = Symbol((process.env.NODE_ENV !== 'production') ? 'Text' : undefined);\r\nconst Comment = Symbol((process.env.NODE_ENV !== 'production') ? 'Comment' : undefined);\r\nconst Static = Symbol((process.env.NODE_ENV !== 'production') ? 'Static' : undefined);\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nconst blockStack = [];\r\nlet currentBlock = null;\r\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock('div', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\r\nfunction openBlock(disableTracking = false) {\r\n    blockStack.push((currentBlock = disableTracking ? null : []));\r\n}\r\nfunction closeBlock() {\r\n    blockStack.pop();\r\n    currentBlock = blockStack[blockStack.length - 1] || null;\r\n}\r\n/**\r\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n * A block root keeps track of dynamic nodes within the block in the\r\n * `dynamicChildren` array.\r\n *\r\n * @private\r\n */\r\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\r\n    const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */);\r\n    // save current block children on the block vnode\r\n    vnode.dynamicChildren = currentBlock || EMPTY_ARR;\r\n    // close block\r\n    closeBlock();\r\n    // a block is always going to be patched, so track it as a child of its\r\n    // parent block\r\n    if ( currentBlock) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nconst createVNodeWithArgsTransform = (...args) => {\r\n    return _createVNode(...( args));\r\n};\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref }) => {\r\n    return (ref != null\r\n        ? isString(ref) || isRef(ref) || isFunction(ref)\r\n            ? { i: currentRenderingInstance, r: ref }\r\n            : ref\r\n        : null);\r\n};\r\nconst createVNode = ((process.env.NODE_ENV !== 'production')\r\n    ? createVNodeWithArgsTransform\r\n    : _createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        if ((process.env.NODE_ENV !== 'production') && !type) {\r\n            warn(`Invalid vnode type when creating vnode: ${type}.`);\r\n        }\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is=\"vnode\"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        if (isProxy(props) || InternalObjectKey in props) {\r\n            props = extend({}, props);\r\n        }\r\n        let { class: klass, style } = props;\r\n        if (klass && !isString(klass)) {\r\n            props.class = normalizeClass(klass);\r\n        }\r\n        if (isObject(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isProxy(style) && !isArray(style)) {\r\n                style = extend({}, style);\r\n            }\r\n            props.style = normalizeStyle(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = isString(type)\r\n        ? 1 /* ELEMENT */\r\n        :  isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : isObject(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : isFunction(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    if ((process.env.NODE_ENV !== 'production') && shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {\r\n        type = toRaw(type);\r\n        warn(`Vue received a Component which was made a reactive object. This can ` +\r\n            `lead to unnecessary performance overhead, and should be avoided by ` +\r\n            `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\r\n            `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\r\n    }\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        children: null,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    // validate key\r\n    if ((process.env.NODE_ENV !== 'production') && vnode.key !== vnode.key) {\r\n        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\r\n    }\r\n    normalizeChildren(vnode, children);\r\n    // normalize suspense children\r\n    if ( shapeFlag & 128 /* SUSPENSE */) {\r\n        const { content, fallback } = normalizeSuspenseChildren(vnode);\r\n        vnode.ssContent = content;\r\n        vnode.ssFallback = fallback;\r\n    }\r\n    if (\r\n        // avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn't need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    return {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? isArray(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        children: vnode.children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: perserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn't affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\nfunction normalizeVNode(child) {\r\n    if (child == null || typeof child === 'boolean') {\r\n        // empty placeholder\r\n        return createVNode(Comment);\r\n    }\r\n    else if (isArray(child)) {\r\n        // fragment\r\n        return createVNode(Fragment, null, child);\r\n    }\r\n    else if (typeof child === 'object') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return child.el === null ? child : cloneVNode(child);\r\n    }\r\n    else {\r\n        // strings and numbers\r\n        return createVNode(Text, null, String(child));\r\n    }\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (isArray(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && setCompiledSlotRendering(1);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && setCompiledSlotRendering(-1);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent's slot type.\r\n                if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n                else {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (isFunction(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = extend({}, args[0]);\r\n    for (let i = 1; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = normalizeClass([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = normalizeStyle([ret.style, toMerge.style]);\r\n            }\r\n            else if (isOn(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (existing !== incoming) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, toMerge[key])\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== '') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\nlet isInBeforeCreate = false;\r\nfunction resolveMergedOptions(instance) {\r\n    const raw = instance.type;\r\n    const { __merged, mixins, extends: extendsOptions } = raw;\r\n    if (__merged)\r\n        return __merged;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (!globalMixins.length && !mixins && !extendsOptions)\r\n        return raw;\r\n    const options = {};\r\n    globalMixins.forEach(m => mergeOptions(options, m, instance));\r\n    mergeOptions(options, raw, instance);\r\n    return (raw.__merged = options);\r\n}\r\nfunction mergeOptions(to, from, instance) {\r\n    const strats = instance.appContext.config.optionMergeStrategies;\r\n    const { mixins, extends: extendsOptions } = from;\r\n    extendsOptions && mergeOptions(to, extendsOptions, instance);\r\n    mixins &&\r\n        mixins.forEach((m) => mergeOptions(to, m, instance));\r\n    for (const key in from) {\r\n        if (strats && hasOwn(strats, key)) {\r\n            to[key] = strats[key](to[key], from[key], instance.proxy, key);\r\n        }\r\n        else {\r\n            to[key] = from[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => i && (i.proxy ? i.proxy : getPublicInstance(i.parent));\r\nconst publicPropertiesMap = extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.props) : i.props),\r\n    $attrs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.attrs) : i.attrs),\r\n    $slots: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.slots) : i.slots),\r\n    $refs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.refs) : i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => i.root && i.root.proxy,\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => () => queueJob(i.update),\r\n    $nextTick: i => nextTick.bind(i.proxy),\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)\r\n});\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // let @vue/reactivity know it should never observe Vue public instances.\r\n        if (key === \"__v_skip\" /* SKIP */) {\r\n            return true;\r\n        }\r\n        // for internal formatters to know that this is a Vue instance\r\n        if ((process.env.NODE_ENV !== 'production') && key === '__isVue') {\r\n            return true;\r\n        }\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== '$') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 0 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 1 /* DATA */:\r\n                        return data[key];\r\n                    case 3 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 2 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n                accessCache[key] = 0 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n                accessCache[key] = 1 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                hasOwn(normalizedProps, key)) {\r\n                accessCache[key] = 2 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n                accessCache[key] = 3 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (!__VUE_OPTIONS_API__ || !isInBeforeCreate) {\r\n                accessCache[key] = 4 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === '$attrs') {\r\n                track(instance, \"get\" /* GET */, key);\r\n                (process.env.NODE_ENV !== 'production') && markAttrsAccessed();\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 3 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // global properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            hasOwn(globalProperties, key))) {\r\n            return globalProperties[key];\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production') &&\r\n            currentRenderingInstance &&\r\n            (!isString(key) ||\r\n                // #1091 avoid internal isRef/isVNode checks on component instance leading\r\n                // to infinite warning loop\r\n                key.indexOf('__v') !== 0)) {\r\n            if (data !== EMPTY_OBJ &&\r\n                (key[0] === '$' || key[0] === '_') &&\r\n                hasOwn(data, key)) {\r\n                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +\r\n                    `character (\"$\" or \"_\") and is not proxied on the render context.`);\r\n            }\r\n            else {\r\n                warn(`Property ${JSON.stringify(key)} was accessed during render ` +\r\n                    `but is not defined on instance.`);\r\n            }\r\n        }\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n            setupState[key] = value;\r\n        }\r\n        else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n            data[key] = value;\r\n        }\r\n        else if (key in instance.props) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate prop \"${key}\". Props are readonly.`, instance);\r\n            return false;\r\n        }\r\n        if (key[0] === '$' && key.slice(1) in instance) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate public property \"${key}\". ` +\r\n                    `Properties starting with $ are reserved and readonly.`, instance);\r\n            return false;\r\n        }\r\n        else {\r\n            if ((process.env.NODE_ENV !== 'production') && key in instance.appContext.config.globalProperties) {\r\n                Object.defineProperty(ctx, key, {\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    value\r\n                });\r\n            }\r\n            else {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (accessCache[key] !== undefined ||\r\n            (data !== EMPTY_OBJ && hasOwn(data, key)) ||\r\n            (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\r\n            hasOwn(ctx, key) ||\r\n            hasOwn(publicPropertiesMap, key) ||\r\n            hasOwn(appContext.config.globalProperties, key));\r\n    }\r\n};\r\nif ((process.env.NODE_ENV !== 'production') && !false) {\r\n    PublicInstanceProxyHandlers.ownKeys = (target) => {\r\n        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +\r\n            `The keys will be empty in production mode to avoid performance overhead.`);\r\n        return Reflect.ownKeys(target);\r\n    };\r\n}\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== '_' && !isGloballyWhitelisted(key);\r\n        if ((process.env.NODE_ENV !== 'production') && !has && PublicInstanceProxyHandlers.has(_, key)) {\r\n            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\r\n        }\r\n        return has;\r\n    }\r\n});\r\nlet currentInstance = null;\r\n// record effects created during a component's setup() so that they can be\r\n// stopped when the component unmounts\r\nfunction recordInstanceBoundEffect(effect, instance = currentInstance) {\r\n    if (instance) {\r\n        (instance.effects || (instance.effects = [])).push(effect);\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = isFunction(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return isFunction(value) && '__vccOpts' in value;\r\n}\n\nconst ssrContextKey = Symbol((process.env.NODE_ENV !== 'production') ? `ssrContext` : ``);\r\n\nfunction initCustomFormatter() {\r\n    /* eslint-disable no-restricted-globals */\r\n    if (!(process.env.NODE_ENV !== 'production') || typeof window === 'undefined') {\r\n        return;\r\n    }\r\n    const vueStyle = { style: 'color:#3ba776' };\r\n    const numberStyle = { style: 'color:#0b1bc9' };\r\n    const stringStyle = { style: 'color:#b62e24' };\r\n    const keywordStyle = { style: 'color:#9d288c' };\r\n    // custom formatter for Chrome\r\n    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n    const formatter = {\r\n        header(obj) {\r\n            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n            if (!isObject(obj)) {\r\n                return null;\r\n            }\r\n            if (obj.__isVue) {\r\n                return ['div', vueStyle, `VueInstance`];\r\n            }\r\n            else if (isRef(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, genRefFlag(obj)],\r\n                    '<',\r\n                    formatValue(obj.value),\r\n                    `>`\r\n                ];\r\n            }\r\n            else if (isReactive(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Reactive'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    `>${isReadonly(obj) ? ` (readonly)` : ``}`\r\n                ];\r\n            }\r\n            else if (isReadonly(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Readonly'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    '>'\r\n                ];\r\n            }\r\n            return null;\r\n        },\r\n        hasBody(obj) {\r\n            return obj && obj.__isVue;\r\n        },\r\n        body(obj) {\r\n            if (obj && obj.__isVue) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ...formatInstance(obj.$)\r\n                ];\r\n            }\r\n        }\r\n    };\r\n    function formatInstance(instance) {\r\n        const blocks = [];\r\n        if (instance.type.props && instance.props) {\r\n            blocks.push(createInstanceBlock('props', toRaw(instance.props)));\r\n        }\r\n        if (instance.setupState !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('setup', instance.setupState));\r\n        }\r\n        if (instance.data !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('data', toRaw(instance.data)));\r\n        }\r\n        const computed = extractKeys(instance, 'computed');\r\n        if (computed) {\r\n            blocks.push(createInstanceBlock('computed', computed));\r\n        }\r\n        const injected = extractKeys(instance, 'inject');\r\n        if (injected) {\r\n            blocks.push(createInstanceBlock('injected', injected));\r\n        }\r\n        blocks.push([\r\n            'div',\r\n            {},\r\n            [\r\n                'span',\r\n                {\r\n                    style: keywordStyle.style + ';opacity:0.66'\r\n                },\r\n                '$ (internal): '\r\n            ],\r\n            ['object', { object: instance }]\r\n        ]);\r\n        return blocks;\r\n    }\r\n    function createInstanceBlock(type, target) {\r\n        target = extend({}, target);\r\n        if (!Object.keys(target).length) {\r\n            return ['span', {}];\r\n        }\r\n        return [\r\n            'div',\r\n            { style: 'line-height:1.25em;margin-bottom:0.6em' },\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'color:#476582'\r\n                },\r\n                type\r\n            ],\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'padding-left:1.25em'\r\n                },\r\n                ...Object.keys(target).map(key => {\r\n                    return [\r\n                        'div',\r\n                        {},\r\n                        ['span', keywordStyle, key + ': '],\r\n                        formatValue(target[key], false)\r\n                    ];\r\n                })\r\n            ]\r\n        ];\r\n    }\r\n    function formatValue(v, asRaw = true) {\r\n        if (typeof v === 'number') {\r\n            return ['span', numberStyle, v];\r\n        }\r\n        else if (typeof v === 'string') {\r\n            return ['span', stringStyle, JSON.stringify(v)];\r\n        }\r\n        else if (typeof v === 'boolean') {\r\n            return ['span', keywordStyle, v];\r\n        }\r\n        else if (isObject(v)) {\r\n            return ['object', { object: asRaw ? toRaw(v) : v }];\r\n        }\r\n        else {\r\n            return ['span', stringStyle, String(v)];\r\n        }\r\n    }\r\n    function extractKeys(instance, type) {\r\n        const Comp = instance.type;\r\n        if (isFunction(Comp)) {\r\n            return;\r\n        }\r\n        const extracted = {};\r\n        for (const key in instance.ctx) {\r\n            if (isKeyOfType(Comp, key, type)) {\r\n                extracted[key] = instance.ctx[key];\r\n            }\r\n        }\r\n        return extracted;\r\n    }\r\n    function isKeyOfType(Comp, key, type) {\r\n        const opts = Comp[type];\r\n        if ((isArray(opts) && opts.includes(key)) ||\r\n            (isObject(opts) && key in opts)) {\r\n            return true;\r\n        }\r\n        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n            return true;\r\n        }\r\n        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n            return true;\r\n        }\r\n    }\r\n    function genRefFlag(v) {\r\n        if (v._shallow) {\r\n            return `ShallowRef`;\r\n        }\r\n        if (v.effect) {\r\n            return `ComputedRef`;\r\n        }\r\n        return `Ref`;\r\n    }\r\n    if (window.devtoolsFormatters) {\r\n        window.devtoolsFormatters.push(formatter);\r\n    }\r\n    else {\r\n        window.devtoolsFormatters = [formatter];\r\n    }\r\n}\n\nfunction initDev() {\r\n    const target = getGlobalThis();\r\n    target.__VUE__ = true;\r\n    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);\r\n    {\r\n        initCustomFormatter();\r\n    }\r\n}\n\n// This entry exports the runtime only, and is built as\r\n(process.env.NODE_ENV !== 'production') && initDev();\n\nfunction getInternetExplorerVersion() {\n  var ua = window.navigator.userAgent;\n  var msie = ua.indexOf('MSIE ');\n\n  if (msie > 0) {\n    // IE 10 or older => return version number\n    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n  }\n\n  var trident = ua.indexOf('Trident/');\n\n  if (trident > 0) {\n    // IE 11 => return version number\n    var rv = ua.indexOf('rv:');\n    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n  }\n\n  var edge = ua.indexOf('Edge/');\n\n  if (edge > 0) {\n    // Edge (IE 12+) => return version number\n    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n  } // other browser\n\n\n  return -1;\n}\n\nvar isIE;\n\nfunction initCompat() {\n  if (!initCompat.init) {\n    initCompat.init = true;\n    isIE = getInternetExplorerVersion() !== -1;\n  }\n}\n\nvar script = {\n  name: 'ResizeObserver',\n  mounted: function mounted() {\n    var _this = this;\n\n    initCompat();\n    nextTick(function () {\n      _this._w = _this.$el.offsetWidth;\n      _this._h = _this.$el.offsetHeight;\n    });\n    var object = document.createElement('object');\n    this._resizeObject = object;\n    object.setAttribute('aria-hidden', 'true');\n    object.setAttribute('tabindex', -1);\n    object.onload = this.addResizeHandlers;\n    object.type = 'text/html';\n\n    if (isIE) {\n      this.$el.appendChild(object);\n    }\n\n    object.data = 'about:blank';\n\n    if (!isIE) {\n      this.$el.appendChild(object);\n    }\n  },\n  beforeUnmount: function beforeUnmount() {\n    this.removeResizeHandlers();\n  },\n  methods: {\n    compareAndNotify: function compareAndNotify() {\n      if (this._w !== this.$el.offsetWidth || this._h !== this.$el.offsetHeight) {\n        this._w = this.$el.offsetWidth;\n        this._h = this.$el.offsetHeight;\n        this.$emit('notify', {\n          width: this._w,\n          height: this._h\n        });\n      }\n    },\n    addResizeHandlers: function addResizeHandlers() {\n      this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify);\n\n      this.compareAndNotify();\n    },\n    removeResizeHandlers: function removeResizeHandlers() {\n      if (this._resizeObject && this._resizeObject.onload) {\n        if (!isIE && this._resizeObject.contentDocument) {\n          this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify);\n        }\n\n        this.$el.removeChild(this._resizeObject);\n        this._resizeObject.onload = null;\n        this._resizeObject = null;\n      }\n    }\n  }\n};\n\nvar _withId = /*#__PURE__*/withScopeId(\"data-v-b329ee4c\");\n\npushScopeId(\"data-v-b329ee4c\");\n\nvar _hoisted_1 = {\n  class: \"resize-observer\",\n  tabindex: \"-1\"\n};\n\npopScopeId();\n\nvar render = /*#__PURE__*/_withId(function (_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createBlock(\"div\", _hoisted_1);\n});\n\nscript.render = render;\nscript.__scopeId = \"data-v-b329ee4c\";\nscript.__file = \"src/components/ResizeObserver.vue\";\n\nfunction install(Vue) {\n  Vue.component('resize-observer', script);\n  Vue.component('ResizeObserver', script);\n}\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"0.5.0\",\n  install: install\n};\n\nvar GlobalVue = null;\n\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\n\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n\nexport default plugin;\nexport { script as ResizeObserver, install };\n//# sourceMappingURL=vue-resize.esm.js.map\n","function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            res += normalizeClass(value[i]) + ' ';\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst NOOP = () => { };\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if ((process.env.NODE_ENV !== 'production') && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key)\r\n            ? builtInSymbols.has(key)\r\n            : key === `__proto__` || key === `__v_isRef`) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    target.add(value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    pauseTracking();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    resetTracking();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (isString(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (isRef(value)) {\r\n        value = formatProp(key, toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (isFunction(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n    [\"c\" /* CREATED */]: 'created hook',\r\n    [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n    [\"m\" /* MOUNTED */]: 'mounted hook',\r\n    [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n    [\"u\" /* UPDATED */]: 'updated',\r\n    [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n    [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n    [\"a\" /* ACTIVATED */]: 'activated hook',\r\n    [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n    [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n    [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n    [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n    [0 /* SETUP_FUNCTION */]: 'setup function',\r\n    [1 /* RENDER_FUNCTION */]: 'render function',\r\n    [2 /* WATCH_GETTER */]: 'watcher getter',\r\n    [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n    [7 /* VNODE_HOOK */]: 'vnode hook',\r\n    [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n    [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n    [12 /* FUNCTION_REF */]: 'ref function',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (isFunction(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && isPromise(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = (process.env.NODE_ENV !== 'production') ? ErrorTypeStrings[type] : type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const info = ErrorTypeStrings[type];\r\n        if (contextVNode) {\r\n            pushWarningContext(contextVNode);\r\n        }\r\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\r\n        if (contextVNode) {\r\n            popWarningContext();\r\n        }\r\n        // crash in dev by default so it's more noticeable\r\n        if (throwInDev) {\r\n            throw err;\r\n        }\r\n        else {\r\n            console.error(err);\r\n        }\r\n    }\r\n    else {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        queue.push(job);\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!isArray(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex]);\r\n            }\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex]);\r\n            }\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        seen = seen || new Map();\r\n    }\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkRecursiveUpdates(seen, job);\r\n                }\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length || pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            throw new Error(`Maximum recursive updates exceeded. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\nconst hmrDirtyComponents = new Set();\r\n// Expose the HMR runtime on the global object\r\n// This makes it entirely tree-shakable without polluting the exports and makes\r\n// it easier to be used in toolings like vue-loader\r\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n// to be set so that its instances can be registered / removed.\r\nif ((process.env.NODE_ENV !== 'production')) {\r\n    const globalObject = typeof global !== 'undefined'\r\n        ? global\r\n        : typeof self !== 'undefined'\r\n            ? self\r\n            : typeof window !== 'undefined'\r\n                ? window\r\n                : {};\r\n    globalObject.__VUE_HMR_RUNTIME__ = {\r\n        createRecord: tryWrap(createRecord),\r\n        rerender: tryWrap(rerender),\r\n        reload: tryWrap(reload)\r\n    };\r\n}\r\nconst map = new Map();\r\nfunction createRecord(id, component) {\r\n    if (!component) {\r\n        warn(`HMR API usage is out of date.\\n` +\r\n            `Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ` +\r\n            `depdendency that handles Vue SFC compilation.`);\r\n        component = {};\r\n    }\r\n    if (map.has(id)) {\r\n        return false;\r\n    }\r\n    map.set(id, {\r\n        component: isClassComponent(component) ? component.__vccOpts : component,\r\n        instances: new Set()\r\n    });\r\n    return true;\r\n}\r\nfunction rerender(id, newRender) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    if (newRender)\r\n        record.component.render = newRender;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    Array.from(record.instances).forEach(instance => {\r\n        if (newRender) {\r\n            instance.render = newRender;\r\n        }\r\n        instance.renderCache = [];\r\n        instance.update();\r\n    });\r\n}\r\nfunction reload(id, newComp) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    const { component, instances } = record;\r\n    if (!hmrDirtyComponents.has(component)) {\r\n        // 1. Update existing comp definition to match new one\r\n        newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;\r\n        extend(component, newComp);\r\n        for (const key in component) {\r\n            if (!(key in newComp)) {\r\n                delete component[key];\r\n            }\r\n        }\r\n        // 2. Mark component dirty. This forces the renderer to replace the component\r\n        // on patch.\r\n        hmrDirtyComponents.add(component);\r\n        // 3. Make sure to unmark the component after the reload.\r\n        queuePostFlushCb(() => {\r\n            hmrDirtyComponents.delete(component);\r\n        });\r\n    }\r\n    Array.from(instances).forEach(instance => {\r\n        if (instance.parent) {\r\n            // 4. Force the parent instance to re-render. This will cause all updated\r\n            // components to be unmounted and re-mounted. Queue the update so that we\r\n            // don't end up forcing the same parent to re-render multiple times.\r\n            queueJob(instance.parent.update);\r\n        }\r\n        else if (instance.appContext.reload) {\r\n            // root instance mounted via createApp() has a reload method\r\n            instance.appContext.reload();\r\n        }\r\n        else if (typeof window !== 'undefined') {\r\n            // root instance inside tree created via raw render(). Force reload.\r\n            window.location.reload();\r\n        }\r\n        else {\r\n            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\r\n        }\r\n    });\r\n}\r\nfunction tryWrap(fn) {\r\n    return (id, arg) => {\r\n        try {\r\n            return fn(id, arg);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\r\n                `Full reload required.`);\r\n        }\r\n    };\r\n}\nfunction setDevtoolsHook(hook) {\r\n}\r\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nfunction markAttrsAccessed() {\r\n}\r\nfunction filterSingleRoot(children) {\r\n    let singleRoot;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (isVNode(child)) {\r\n            // ignore user comment\r\n            if (child.type !== Comment || child.children === 'v-if') {\r\n                if (singleRoot) {\r\n                    // has more than 1 non-comment child, return now\r\n                    return;\r\n                }\r\n                else {\r\n                    singleRoot = child;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    return singleRoot;\r\n}\r\n\nconst isSuspense = (type) => type.__isSuspense;\r\nfunction normalizeSuspenseChildren(vnode) {\r\n    const { shapeFlag, children } = vnode;\r\n    let content;\r\n    let fallback;\r\n    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        content = normalizeSuspenseSlot(children.default);\r\n        fallback = normalizeSuspenseSlot(children.fallback);\r\n    }\r\n    else {\r\n        content = normalizeSuspenseSlot(children);\r\n        fallback = normalizeVNode(null);\r\n    }\r\n    return {\r\n        content,\r\n        fallback\r\n    };\r\n}\r\nfunction normalizeSuspenseSlot(s) {\r\n    if (isFunction(s)) {\r\n        s = s();\r\n    }\r\n    if (isArray(s)) {\r\n        const singleChild = filterSingleRoot(s);\r\n        if ((process.env.NODE_ENV !== 'production') && !singleChild) {\r\n            warn(`<Suspense> slots expect a single root node.`);\r\n        }\r\n        s = singleChild;\r\n    }\r\n    return normalizeVNode(s);\r\n}\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if (isArray(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\n\nlet isRenderingCompiledSlot = 0;\r\nconst setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);\r\n\n// SFC scoped style ID management.\r\nlet currentScopeId = null;\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ, instance = currentInstance) {\r\n    if ((process.env.NODE_ENV !== 'production') && !cb) {\r\n        if (immediate !== undefined) {\r\n            warn(`watch() \"immediate\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n        if (deep !== undefined) {\r\n            warn(`watch() \"deep\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n    }\r\n    const warnInvalidSource = (s) => {\r\n        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n            `a reactive object, or an array of these types.`);\r\n    };\r\n    let getter;\r\n    let forceTrigger = false;\r\n    if (isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = !!source._shallow;\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        getter = () => source.map(s => {\r\n            if (isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (isFunction(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);\r\n            }\r\n            else {\r\n                (process.env.NODE_ENV !== 'production') && warnInvalidSource(s);\r\n            }\r\n        });\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = NOOP;\r\n        (process.env.NODE_ENV !== 'production') && warnInvalidSource(source);\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    const onInvalidate = (fn) => {\r\n        cleanup = runner.options.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!runner.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = runner();\r\n            if (deep || forceTrigger || hasChanged(newValue, oldValue)) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onInvalidate\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            runner();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = job;\r\n    }\r\n    else if (flush === 'post') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: 'pre'\r\n        scheduler = () => {\r\n            if (!instance || instance.isMounted) {\r\n                queuePreFlushCb(job);\r\n            }\r\n            else {\r\n                // with 'pre' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    const runner = effect(getter, {\r\n        lazy: true,\r\n        onTrack,\r\n        onTrigger,\r\n        scheduler\r\n    });\r\n    recordInstanceBoundEffect(runner, instance);\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = runner();\r\n        }\r\n    }\r\n    else if (flush === 'post') {\r\n        queuePostRenderEffect(runner, instance && instance.suspense);\r\n    }\r\n    else {\r\n        runner();\r\n    }\r\n    return () => {\r\n        stop(runner);\r\n        if (instance) {\r\n            remove(instance.effects, runner);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, cb, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = isString(source)\r\n        ? () => publicThis[source]\r\n        : source.bind(publicThis);\r\n    return doWatch(getter, cb.bind(publicThis), options, this);\r\n}\r\nfunction traverse(value, seen = new Set()) {\r\n    if (!isObject(value) || seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (isSet(value) || isMap(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\nconst queuePostRenderEffect =  queueEffectWithSuspense\r\n    ;\r\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n\nconst Fragment = Symbol((process.env.NODE_ENV !== 'production') ? 'Fragment' : undefined);\r\nconst Text = Symbol((process.env.NODE_ENV !== 'production') ? 'Text' : undefined);\r\nconst Comment = Symbol((process.env.NODE_ENV !== 'production') ? 'Comment' : undefined);\r\nconst Static = Symbol((process.env.NODE_ENV !== 'production') ? 'Static' : undefined);\r\nlet currentBlock = null;\r\n// Whether we should be tracking dynamic child nodes inside a block.\r\n// Only tracks when this value is > 0\r\n// We are not using a simple boolean because this value may need to be\r\n// incremented/decremented by nested usage of v-once (see below)\r\nlet shouldTrack$1 = 1;\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nlet vnodeArgsTransformer;\r\nconst createVNodeWithArgsTransform = (...args) => {\r\n    return _createVNode(...(vnodeArgsTransformer\r\n        ? vnodeArgsTransformer(args, currentRenderingInstance)\r\n        : args));\r\n};\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref }) => {\r\n    return (ref != null\r\n        ? isString(ref) || isRef(ref) || isFunction(ref)\r\n            ? { i: currentRenderingInstance, r: ref }\r\n            : ref\r\n        : null);\r\n};\r\nconst createVNode = ((process.env.NODE_ENV !== 'production')\r\n    ? createVNodeWithArgsTransform\r\n    : _createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        if ((process.env.NODE_ENV !== 'production') && !type) {\r\n            warn(`Invalid vnode type when creating vnode: ${type}.`);\r\n        }\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is=\"vnode\"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        if (isProxy(props) || InternalObjectKey in props) {\r\n            props = extend({}, props);\r\n        }\r\n        let { class: klass, style } = props;\r\n        if (klass && !isString(klass)) {\r\n            props.class = normalizeClass(klass);\r\n        }\r\n        if (isObject(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isProxy(style) && !isArray(style)) {\r\n                style = extend({}, style);\r\n            }\r\n            props.style = normalizeStyle(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = isString(type)\r\n        ? 1 /* ELEMENT */\r\n        :  isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : isObject(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : isFunction(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    if ((process.env.NODE_ENV !== 'production') && shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {\r\n        type = toRaw(type);\r\n        warn(`Vue received a Component which was made a reactive object. This can ` +\r\n            `lead to unnecessary performance overhead, and should be avoided by ` +\r\n            `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\r\n            `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\r\n    }\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        children: null,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    // validate key\r\n    if ((process.env.NODE_ENV !== 'production') && vnode.key !== vnode.key) {\r\n        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\r\n    }\r\n    normalizeChildren(vnode, children);\r\n    // normalize suspense children\r\n    if ( shapeFlag & 128 /* SUSPENSE */) {\r\n        const { content, fallback } = normalizeSuspenseChildren(vnode);\r\n        vnode.ssContent = content;\r\n        vnode.ssFallback = fallback;\r\n    }\r\n    if (shouldTrack$1 > 0 &&\r\n        // avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn't need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    return {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? isArray(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        children: vnode.children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: perserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn't affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\nfunction normalizeVNode(child) {\r\n    if (child == null || typeof child === 'boolean') {\r\n        // empty placeholder\r\n        return createVNode(Comment);\r\n    }\r\n    else if (isArray(child)) {\r\n        // fragment\r\n        return createVNode(Fragment, null, child);\r\n    }\r\n    else if (typeof child === 'object') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return child.el === null ? child : cloneVNode(child);\r\n    }\r\n    else {\r\n        // strings and numbers\r\n        return createVNode(Text, null, String(child));\r\n    }\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (isArray(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && setCompiledSlotRendering(1);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && setCompiledSlotRendering(-1);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent's slot type.\r\n                if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n                else {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (isFunction(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = extend({}, args[0]);\r\n    for (let i = 1; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = normalizeClass([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = normalizeStyle([ret.style, toMerge.style]);\r\n            }\r\n            else if (isOn(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (existing !== incoming) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, toMerge[key])\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== '') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\nlet isInBeforeCreate = false;\r\nfunction resolveMergedOptions(instance) {\r\n    const raw = instance.type;\r\n    const { __merged, mixins, extends: extendsOptions } = raw;\r\n    if (__merged)\r\n        return __merged;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (!globalMixins.length && !mixins && !extendsOptions)\r\n        return raw;\r\n    const options = {};\r\n    globalMixins.forEach(m => mergeOptions(options, m, instance));\r\n    mergeOptions(options, raw, instance);\r\n    return (raw.__merged = options);\r\n}\r\nfunction mergeOptions(to, from, instance) {\r\n    const strats = instance.appContext.config.optionMergeStrategies;\r\n    const { mixins, extends: extendsOptions } = from;\r\n    extendsOptions && mergeOptions(to, extendsOptions, instance);\r\n    mixins &&\r\n        mixins.forEach((m) => mergeOptions(to, m, instance));\r\n    for (const key in from) {\r\n        if (strats && hasOwn(strats, key)) {\r\n            to[key] = strats[key](to[key], from[key], instance.proxy, key);\r\n        }\r\n        else {\r\n            to[key] = from[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => i && (i.proxy ? i.proxy : getPublicInstance(i.parent));\r\nconst publicPropertiesMap = extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.props) : i.props),\r\n    $attrs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.attrs) : i.attrs),\r\n    $slots: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.slots) : i.slots),\r\n    $refs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.refs) : i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => i.root && i.root.proxy,\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => () => queueJob(i.update),\r\n    $nextTick: i => nextTick.bind(i.proxy),\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)\r\n});\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // let @vue/reactivity know it should never observe Vue public instances.\r\n        if (key === \"__v_skip\" /* SKIP */) {\r\n            return true;\r\n        }\r\n        // for internal formatters to know that this is a Vue instance\r\n        if ((process.env.NODE_ENV !== 'production') && key === '__isVue') {\r\n            return true;\r\n        }\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== '$') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 0 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 1 /* DATA */:\r\n                        return data[key];\r\n                    case 3 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 2 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n                accessCache[key] = 0 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n                accessCache[key] = 1 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                hasOwn(normalizedProps, key)) {\r\n                accessCache[key] = 2 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n                accessCache[key] = 3 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (!__VUE_OPTIONS_API__ || !isInBeforeCreate) {\r\n                accessCache[key] = 4 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === '$attrs') {\r\n                track(instance, \"get\" /* GET */, key);\r\n                (process.env.NODE_ENV !== 'production') && markAttrsAccessed();\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 3 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // global properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            hasOwn(globalProperties, key))) {\r\n            return globalProperties[key];\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production') &&\r\n            currentRenderingInstance &&\r\n            (!isString(key) ||\r\n                // #1091 avoid internal isRef/isVNode checks on component instance leading\r\n                // to infinite warning loop\r\n                key.indexOf('__v') !== 0)) {\r\n            if (data !== EMPTY_OBJ &&\r\n                (key[0] === '$' || key[0] === '_') &&\r\n                hasOwn(data, key)) {\r\n                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +\r\n                    `character (\"$\" or \"_\") and is not proxied on the render context.`);\r\n            }\r\n            else {\r\n                warn(`Property ${JSON.stringify(key)} was accessed during render ` +\r\n                    `but is not defined on instance.`);\r\n            }\r\n        }\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n            setupState[key] = value;\r\n        }\r\n        else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n            data[key] = value;\r\n        }\r\n        else if (key in instance.props) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate prop \"${key}\". Props are readonly.`, instance);\r\n            return false;\r\n        }\r\n        if (key[0] === '$' && key.slice(1) in instance) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate public property \"${key}\". ` +\r\n                    `Properties starting with $ are reserved and readonly.`, instance);\r\n            return false;\r\n        }\r\n        else {\r\n            if ((process.env.NODE_ENV !== 'production') && key in instance.appContext.config.globalProperties) {\r\n                Object.defineProperty(ctx, key, {\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    value\r\n                });\r\n            }\r\n            else {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (accessCache[key] !== undefined ||\r\n            (data !== EMPTY_OBJ && hasOwn(data, key)) ||\r\n            (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\r\n            hasOwn(ctx, key) ||\r\n            hasOwn(publicPropertiesMap, key) ||\r\n            hasOwn(appContext.config.globalProperties, key));\r\n    }\r\n};\r\nif ((process.env.NODE_ENV !== 'production') && !false) {\r\n    PublicInstanceProxyHandlers.ownKeys = (target) => {\r\n        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +\r\n            `The keys will be empty in production mode to avoid performance overhead.`);\r\n        return Reflect.ownKeys(target);\r\n    };\r\n}\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== '_' && !isGloballyWhitelisted(key);\r\n        if ((process.env.NODE_ENV !== 'production') && !has && PublicInstanceProxyHandlers.has(_, key)) {\r\n            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\r\n        }\r\n        return has;\r\n    }\r\n});\r\nlet currentInstance = null;\r\n// record effects created during a component's setup() so that they can be\r\n// stopped when the component unmounts\r\nfunction recordInstanceBoundEffect(effect, instance = currentInstance) {\r\n    if (instance) {\r\n        (instance.effects || (instance.effects = [])).push(effect);\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = isFunction(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return isFunction(value) && '__vccOpts' in value;\r\n}\n\nconst ssrContextKey = Symbol((process.env.NODE_ENV !== 'production') ? `ssrContext` : ``);\r\n\nfunction initCustomFormatter() {\r\n    /* eslint-disable no-restricted-globals */\r\n    if (!(process.env.NODE_ENV !== 'production') || typeof window === 'undefined') {\r\n        return;\r\n    }\r\n    const vueStyle = { style: 'color:#3ba776' };\r\n    const numberStyle = { style: 'color:#0b1bc9' };\r\n    const stringStyle = { style: 'color:#b62e24' };\r\n    const keywordStyle = { style: 'color:#9d288c' };\r\n    // custom formatter for Chrome\r\n    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n    const formatter = {\r\n        header(obj) {\r\n            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n            if (!isObject(obj)) {\r\n                return null;\r\n            }\r\n            if (obj.__isVue) {\r\n                return ['div', vueStyle, `VueInstance`];\r\n            }\r\n            else if (isRef(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, genRefFlag(obj)],\r\n                    '<',\r\n                    formatValue(obj.value),\r\n                    `>`\r\n                ];\r\n            }\r\n            else if (isReactive(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Reactive'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    `>${isReadonly(obj) ? ` (readonly)` : ``}`\r\n                ];\r\n            }\r\n            else if (isReadonly(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Readonly'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    '>'\r\n                ];\r\n            }\r\n            return null;\r\n        },\r\n        hasBody(obj) {\r\n            return obj && obj.__isVue;\r\n        },\r\n        body(obj) {\r\n            if (obj && obj.__isVue) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ...formatInstance(obj.$)\r\n                ];\r\n            }\r\n        }\r\n    };\r\n    function formatInstance(instance) {\r\n        const blocks = [];\r\n        if (instance.type.props && instance.props) {\r\n            blocks.push(createInstanceBlock('props', toRaw(instance.props)));\r\n        }\r\n        if (instance.setupState !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('setup', instance.setupState));\r\n        }\r\n        if (instance.data !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('data', toRaw(instance.data)));\r\n        }\r\n        const computed = extractKeys(instance, 'computed');\r\n        if (computed) {\r\n            blocks.push(createInstanceBlock('computed', computed));\r\n        }\r\n        const injected = extractKeys(instance, 'inject');\r\n        if (injected) {\r\n            blocks.push(createInstanceBlock('injected', injected));\r\n        }\r\n        blocks.push([\r\n            'div',\r\n            {},\r\n            [\r\n                'span',\r\n                {\r\n                    style: keywordStyle.style + ';opacity:0.66'\r\n                },\r\n                '$ (internal): '\r\n            ],\r\n            ['object', { object: instance }]\r\n        ]);\r\n        return blocks;\r\n    }\r\n    function createInstanceBlock(type, target) {\r\n        target = extend({}, target);\r\n        if (!Object.keys(target).length) {\r\n            return ['span', {}];\r\n        }\r\n        return [\r\n            'div',\r\n            { style: 'line-height:1.25em;margin-bottom:0.6em' },\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'color:#476582'\r\n                },\r\n                type\r\n            ],\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'padding-left:1.25em'\r\n                },\r\n                ...Object.keys(target).map(key => {\r\n                    return [\r\n                        'div',\r\n                        {},\r\n                        ['span', keywordStyle, key + ': '],\r\n                        formatValue(target[key], false)\r\n                    ];\r\n                })\r\n            ]\r\n        ];\r\n    }\r\n    function formatValue(v, asRaw = true) {\r\n        if (typeof v === 'number') {\r\n            return ['span', numberStyle, v];\r\n        }\r\n        else if (typeof v === 'string') {\r\n            return ['span', stringStyle, JSON.stringify(v)];\r\n        }\r\n        else if (typeof v === 'boolean') {\r\n            return ['span', keywordStyle, v];\r\n        }\r\n        else if (isObject(v)) {\r\n            return ['object', { object: asRaw ? toRaw(v) : v }];\r\n        }\r\n        else {\r\n            return ['span', stringStyle, String(v)];\r\n        }\r\n    }\r\n    function extractKeys(instance, type) {\r\n        const Comp = instance.type;\r\n        if (isFunction(Comp)) {\r\n            return;\r\n        }\r\n        const extracted = {};\r\n        for (const key in instance.ctx) {\r\n            if (isKeyOfType(Comp, key, type)) {\r\n                extracted[key] = instance.ctx[key];\r\n            }\r\n        }\r\n        return extracted;\r\n    }\r\n    function isKeyOfType(Comp, key, type) {\r\n        const opts = Comp[type];\r\n        if ((isArray(opts) && opts.includes(key)) ||\r\n            (isObject(opts) && key in opts)) {\r\n            return true;\r\n        }\r\n        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n            return true;\r\n        }\r\n        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n            return true;\r\n        }\r\n    }\r\n    function genRefFlag(v) {\r\n        if (v._shallow) {\r\n            return `ShallowRef`;\r\n        }\r\n        if (v.effect) {\r\n            return `ComputedRef`;\r\n        }\r\n        return `Ref`;\r\n    }\r\n    if (window.devtoolsFormatters) {\r\n        window.devtoolsFormatters.push(formatter);\r\n    }\r\n    else {\r\n        window.devtoolsFormatters = [formatter];\r\n    }\r\n}\n\nconst svgNS = 'http://www.w3.org/2000/svg';\r\nconst doc = (typeof document !== 'undefined' ? document : null);\r\nlet tempContainer;\r\nlet tempSVGContainer;\r\nconst nodeOps = {\r\n    insert: (child, parent, anchor) => {\r\n        parent.insertBefore(child, anchor || null);\r\n    },\r\n    remove: child => {\r\n        const parent = child.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(child);\r\n        }\r\n    },\r\n    createElement: (tag, isSVG, is) => isSVG\r\n        ? doc.createElementNS(svgNS, tag)\r\n        : doc.createElement(tag, is ? { is } : undefined),\r\n    createText: text => doc.createTextNode(text),\r\n    createComment: text => doc.createComment(text),\r\n    setText: (node, text) => {\r\n        node.nodeValue = text;\r\n    },\r\n    setElementText: (el, text) => {\r\n        el.textContent = text;\r\n    },\r\n    parentNode: node => node.parentNode,\r\n    nextSibling: node => node.nextSibling,\r\n    querySelector: selector => doc.querySelector(selector),\r\n    setScopeId(el, id) {\r\n        el.setAttribute(id, '');\r\n    },\r\n    cloneNode(el) {\r\n        return el.cloneNode(true);\r\n    },\r\n    // __UNSAFE__\r\n    // Reason: innerHTML.\r\n    // Static content here can only come from compiled templates.\r\n    // As long as the user only uses trusted templates, this is safe.\r\n    insertStaticContent(content, parent, anchor, isSVG) {\r\n        const temp = isSVG\r\n            ? tempSVGContainer ||\r\n                (tempSVGContainer = doc.createElementNS(svgNS, 'svg'))\r\n            : tempContainer || (tempContainer = doc.createElement('div'));\r\n        temp.innerHTML = content;\r\n        const first = temp.firstChild;\r\n        let node = first;\r\n        let last = node;\r\n        while (node) {\r\n            last = node;\r\n            nodeOps.insert(node, parent, anchor);\r\n            node = temp.firstChild;\r\n        }\r\n        return [first, last];\r\n    }\r\n};\n\n// compiler should normalize class + :class bindings on the same element\r\n// into a single binding ['staticClass', dynamic]\r\nfunction patchClass(el, value, isSVG) {\r\n    if (value == null) {\r\n        value = '';\r\n    }\r\n    if (isSVG) {\r\n        el.setAttribute('class', value);\r\n    }\r\n    else {\r\n        // directly setting className should be faster than setAttribute in theory\r\n        // if this is an element during a transition, take the temporary transition\r\n        // classes into account.\r\n        const transitionClasses = el._vtc;\r\n        if (transitionClasses) {\r\n            value = (value\r\n                ? [value, ...transitionClasses]\r\n                : [...transitionClasses]).join(' ');\r\n        }\r\n        el.className = value;\r\n    }\r\n}\n\nfunction patchStyle(el, prev, next) {\r\n    const style = el.style;\r\n    if (!next) {\r\n        el.removeAttribute('style');\r\n    }\r\n    else if (isString(next)) {\r\n        if (prev !== next) {\r\n            style.cssText = next;\r\n        }\r\n    }\r\n    else {\r\n        for (const key in next) {\r\n            setStyle(style, key, next[key]);\r\n        }\r\n        if (prev && !isString(prev)) {\r\n            for (const key in prev) {\r\n                if (next[key] == null) {\r\n                    setStyle(style, key, '');\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nconst importantRE = /\\s*!important$/;\r\nfunction setStyle(style, name, val) {\r\n    if (isArray(val)) {\r\n        val.forEach(v => setStyle(style, name, v));\r\n    }\r\n    else {\r\n        if (name.startsWith('--')) {\r\n            // custom property definition\r\n            style.setProperty(name, val);\r\n        }\r\n        else {\r\n            const prefixed = autoPrefix(style, name);\r\n            if (importantRE.test(val)) {\r\n                // !important\r\n                style.setProperty(hyphenate(prefixed), val.replace(importantRE, ''), 'important');\r\n            }\r\n            else {\r\n                style[prefixed] = val;\r\n            }\r\n        }\r\n    }\r\n}\r\nconst prefixes = ['Webkit', 'Moz', 'ms'];\r\nconst prefixCache = {};\r\nfunction autoPrefix(style, rawName) {\r\n    const cached = prefixCache[rawName];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    let name = camelize(rawName);\r\n    if (name !== 'filter' && name in style) {\r\n        return (prefixCache[rawName] = name);\r\n    }\r\n    name = capitalize(name);\r\n    for (let i = 0; i < prefixes.length; i++) {\r\n        const prefixed = prefixes[i] + name;\r\n        if (prefixed in style) {\r\n            return (prefixCache[rawName] = prefixed);\r\n        }\r\n    }\r\n    return rawName;\r\n}\n\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\r\nfunction patchAttr(el, key, value, isSVG) {\r\n    if (isSVG && key.startsWith('xlink:')) {\r\n        if (value == null) {\r\n            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\r\n        }\r\n        else {\r\n            el.setAttributeNS(xlinkNS, key, value);\r\n        }\r\n    }\r\n    else {\r\n        // note we are only checking boolean attributes that don't have a\r\n        // corresponding dom prop of the same name here.\r\n        const isBoolean = isSpecialBooleanAttr(key);\r\n        if (value == null || (isBoolean && value === false)) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            el.setAttribute(key, isBoolean ? '' : value);\r\n        }\r\n    }\r\n}\n\n// __UNSAFE__\r\n// functions. The user is responsible for using them with only trusted content.\r\nfunction patchDOMProp(el, key, value, \r\n// the following args are passed only due to potential innerHTML/textContent\r\n// overriding existing VNodes, in which case the old tree must be properly\r\n// unmounted.\r\nprevChildren, parentComponent, parentSuspense, unmountChildren) {\r\n    if (key === 'innerHTML' || key === 'textContent') {\r\n        if (prevChildren) {\r\n            unmountChildren(prevChildren, parentComponent, parentSuspense);\r\n        }\r\n        el[key] = value == null ? '' : value;\r\n        return;\r\n    }\r\n    if (key === 'value' && el.tagName !== 'PROGRESS') {\r\n        // store value as _value as well since\r\n        // non-string values will be stringified.\r\n        el._value = value;\r\n        const newValue = value == null ? '' : value;\r\n        if (el.value !== newValue) {\r\n            el.value = newValue;\r\n        }\r\n        return;\r\n    }\r\n    if (value === '' || value == null) {\r\n        const type = typeof el[key];\r\n        if (value === '' && type === 'boolean') {\r\n            // e.g. <select multiple> compiles to { multiple: '' }\r\n            el[key] = true;\r\n            return;\r\n        }\r\n        else if (value == null && type === 'string') {\r\n            // e.g. <div :id=\"null\">\r\n            el[key] = '';\r\n            el.removeAttribute(key);\r\n            return;\r\n        }\r\n        else if (type === 'number') {\r\n            // e.g. <img :width=\"null\">\r\n            el[key] = 0;\r\n            el.removeAttribute(key);\r\n            return;\r\n        }\r\n    }\r\n    // some properties perform value validation and throw\r\n    try {\r\n        el[key] = value;\r\n    }\r\n    catch (e) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`Failed setting prop \"${key}\" on <${el.tagName.toLowerCase()}>: ` +\r\n                `value ${value} is invalid.`, e);\r\n        }\r\n    }\r\n}\n\n// Async edge case fix requires storing an event listener's attach timestamp.\r\nlet _getNow = Date.now;\r\n// Determine what event timestamp the browser is using. Annoyingly, the\r\n// timestamp can either be hi-res (relative to page load) or low-res\r\n// (relative to UNIX epoch), so in order to compare time we have to use the\r\n// same timestamp type when saving the flush timestamp.\r\nif (typeof document !== 'undefined' &&\r\n    _getNow() > document.createEvent('Event').timeStamp) {\r\n    // if the low-res timestamp which is bigger than the event timestamp\r\n    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\r\n    // and we need to use the hi-res version for event listeners as well.\r\n    _getNow = () => performance.now();\r\n}\r\n// To avoid the overhead of repeatedly calling performance.now(), we cache\r\n// and use the same timestamp for all event listeners attached in the same tick.\r\nlet cachedNow = 0;\r\nconst p = Promise.resolve();\r\nconst reset = () => {\r\n    cachedNow = 0;\r\n};\r\nconst getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));\r\nfunction addEventListener(el, event, handler, options) {\r\n    el.addEventListener(event, handler, options);\r\n}\r\nfunction removeEventListener(el, event, handler, options) {\r\n    el.removeEventListener(event, handler, options);\r\n}\r\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\r\n    // vei = vue event invokers\r\n    const invokers = el._vei || (el._vei = {});\r\n    const existingInvoker = invokers[rawName];\r\n    if (nextValue && existingInvoker) {\r\n        // patch\r\n        existingInvoker.value = nextValue;\r\n    }\r\n    else {\r\n        const [name, options] = parseName(rawName);\r\n        if (nextValue) {\r\n            // add\r\n            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));\r\n            addEventListener(el, name, invoker, options);\r\n        }\r\n        else if (existingInvoker) {\r\n            // remove\r\n            removeEventListener(el, name, existingInvoker, options);\r\n            invokers[rawName] = undefined;\r\n        }\r\n    }\r\n}\r\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\r\nfunction parseName(name) {\r\n    let options;\r\n    if (optionsModifierRE.test(name)) {\r\n        options = {};\r\n        let m;\r\n        while ((m = name.match(optionsModifierRE))) {\r\n            name = name.slice(0, name.length - m[0].length);\r\n            options[m[0].toLowerCase()] = true;\r\n        }\r\n    }\r\n    return [name.slice(2).toLowerCase(), options];\r\n}\r\nfunction createInvoker(initialValue, instance) {\r\n    const invoker = (e) => {\r\n        // async edge case #6566: inner click event triggers patch, event handler\r\n        // attached to outer element during patch, and triggered again. This\r\n        // happens because browsers fire microtask ticks between event propagation.\r\n        // the solution is simple: we save the timestamp when a handler is attached,\r\n        // and the handler would only fire if the event passed to it was fired\r\n        // AFTER it was attached.\r\n        const timeStamp = e.timeStamp || _getNow();\r\n        if (timeStamp >= invoker.attached - 1) {\r\n            callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);\r\n        }\r\n    };\r\n    invoker.value = initialValue;\r\n    invoker.attached = getNow();\r\n    return invoker;\r\n}\r\nfunction patchStopImmediatePropagation(e, value) {\r\n    if (isArray(value)) {\r\n        const originalStop = e.stopImmediatePropagation;\r\n        e.stopImmediatePropagation = () => {\r\n            originalStop.call(e);\r\n            e._stopped = true;\r\n        };\r\n        return value.map(fn => (e) => !e._stopped && fn(e));\r\n    }\r\n    else {\r\n        return value;\r\n    }\r\n}\n\nconst nativeOnRE = /^on[a-z]/;\r\nconst forcePatchProp = (_, key) => key === 'value';\r\nconst patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\r\n    switch (key) {\r\n        // special\r\n        case 'class':\r\n            patchClass(el, nextValue, isSVG);\r\n            break;\r\n        case 'style':\r\n            patchStyle(el, prevValue, nextValue);\r\n            break;\r\n        default:\r\n            if (isOn(key)) {\r\n                // ignore v-model listeners\r\n                if (!isModelListener(key)) {\r\n                    patchEvent(el, key, prevValue, nextValue, parentComponent);\r\n                }\r\n            }\r\n            else if (shouldSetAsProp(el, key, nextValue, isSVG)) {\r\n                patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\r\n            }\r\n            else {\r\n                // special case for <input v-model type=\"checkbox\"> with\r\n                // :true-value & :false-value\r\n                // store value as dom properties since non-string values will be\r\n                // stringified.\r\n                if (key === 'true-value') {\r\n                    el._trueValue = nextValue;\r\n                }\r\n                else if (key === 'false-value') {\r\n                    el._falseValue = nextValue;\r\n                }\r\n                patchAttr(el, key, nextValue, isSVG);\r\n            }\r\n            break;\r\n    }\r\n};\r\nfunction shouldSetAsProp(el, key, value, isSVG) {\r\n    if (isSVG) {\r\n        // most keys must be set as attribute on svg elements to work\r\n        // ...except innerHTML\r\n        if (key === 'innerHTML') {\r\n            return true;\r\n        }\r\n        // or native onclick with function values\r\n        if (key in el && nativeOnRE.test(key) && isFunction(value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // spellcheck and draggable are numerated attrs, however their\r\n    // corresponding DOM properties are actually booleans - this leads to\r\n    // setting it with a string \"false\" value leading it to be coerced to\r\n    // `true`, so we need to always treat them as attributes.\r\n    // Note that `contentEditable` doesn't have this problem: its DOM\r\n    // property is also enumerated string values.\r\n    if (key === 'spellcheck' || key === 'draggable') {\r\n        return false;\r\n    }\r\n    // #1787 form as an attribute must be a string, while it accepts an Element as\r\n    // a prop\r\n    if (key === 'form' && typeof value === 'string') {\r\n        return false;\r\n    }\r\n    // #1526 <input list> must be set as attribute\r\n    if (key === 'list' && el.tagName === 'INPUT') {\r\n        return false;\r\n    }\r\n    // native onclick with string value, must be set as attribute\r\n    if (nativeOnRE.test(key) && isString(value)) {\r\n        return false;\r\n    }\r\n    return key in el;\r\n}\n\nconst rendererOptions = extend({ patchProp, forcePatchProp }, nodeOps);\n\nfunction initDev() {\r\n    const target = getGlobalThis();\r\n    target.__VUE__ = true;\r\n    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);\r\n    {\r\n        initCustomFormatter();\r\n    }\r\n}\n\n// This entry exports the runtime only, and is built as\r\n(process.env.NODE_ENV !== 'production') && initDev();\n\nfunction processOptions(value) {\n  var options;\n\n  if (typeof value === 'function') {\n    // Simple options (callback-only)\n    options = {\n      callback: value\n    };\n  } else {\n    // Options object\n    options = value;\n  }\n\n  return options;\n}\nfunction throttle(callback, delay) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout;\n  var lastState;\n  var currentArgs;\n\n  var throttled = function throttled(state) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    currentArgs = args;\n    if (timeout && state === lastState) return;\n    var leading = options.leading;\n\n    if (typeof leading === 'function') {\n      leading = leading(state, lastState);\n    }\n\n    if ((!timeout || state !== lastState) && leading) {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n    }\n\n    lastState = state;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n      timeout = 0;\n    }, delay);\n  };\n\n  throttled._clear = function () {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return throttled;\n}\nfunction deepEqual(val1, val2) {\n  if (val1 === val2) return true;\n\n  if (_typeof(val1) === 'object') {\n    for (var key in val1) {\n      if (!deepEqual(val1[key], val2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar VisibilityState =\n/*#__PURE__*/\nfunction () {\n  function VisibilityState(el, options, vnode) {\n    _classCallCheck(this, VisibilityState);\n\n    this.el = el;\n    this.observer = null;\n    this.frozen = false;\n    this.createObserver(options, vnode);\n  }\n\n  _createClass(VisibilityState, [{\n    key: \"createObserver\",\n    value: function createObserver(options, vnode) {\n      var _this = this;\n\n      if (this.observer) {\n        this.destroyObserver();\n      }\n\n      if (this.frozen) return;\n      this.options = processOptions(options);\n\n      this.callback = function (result, entry) {\n        _this.options.callback(result, entry);\n\n        if (result && _this.options.once) {\n          _this.frozen = true;\n\n          _this.destroyObserver();\n        }\n      }; // Throttle\n\n\n      if (this.callback && this.options.throttle) {\n        var _ref = this.options.throttleOptions || {},\n            _leading = _ref.leading;\n\n        this.callback = throttle(this.callback, this.options.throttle, {\n          leading: function leading(state) {\n            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;\n          }\n        });\n      }\n\n      this.oldResult = undefined;\n      this.observer = new IntersectionObserver(function (entries) {\n        var entry = entries[0];\n\n        if (entries.length > 1) {\n          var intersectingEntry = entries.find(function (e) {\n            return e.isIntersecting;\n          });\n\n          if (intersectingEntry) {\n            entry = intersectingEntry;\n          }\n        }\n\n        if (_this.callback) {\n          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.\n          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;\n          if (result === _this.oldResult) return;\n          _this.oldResult = result;\n\n          _this.callback(result, entry);\n        }\n      }, this.options.intersection); // Wait for the element to be in document\n\n      nextTick(function () {\n        if (_this.observer) {\n          _this.observer.observe(_this.el);\n        }\n      });\n    }\n  }, {\n    key: \"destroyObserver\",\n    value: function destroyObserver() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      } // Cancel throttled call\n\n\n      if (this.callback && this.callback._clear) {\n        this.callback._clear();\n\n        this.callback = null;\n      }\n    }\n  }, {\n    key: \"threshold\",\n    get: function get() {\n      return this.options.intersection && this.options.intersection.threshold || 0;\n    }\n  }]);\n\n  return VisibilityState;\n}();\n\nfunction bind(el, _ref2, vnode) {\n  var value = _ref2.value;\n  if (!value) return;\n\n  if (typeof IntersectionObserver === 'undefined') {\n    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');\n  } else {\n    var state = new VisibilityState(el, value, vnode);\n    el._vue_visibilityState = state;\n  }\n}\n\nfunction update(el, _ref3, vnode) {\n  var value = _ref3.value,\n      oldValue = _ref3.oldValue;\n  if (deepEqual(value, oldValue)) return;\n  var state = el._vue_visibilityState;\n\n  if (!value) {\n    unbind(el);\n    return;\n  }\n\n  if (state) {\n    state.createObserver(value, vnode);\n  } else {\n    bind(el, {\n      value: value\n    }, vnode);\n  }\n}\n\nfunction unbind(el) {\n  var state = el._vue_visibilityState;\n\n  if (state) {\n    state.destroyObserver();\n    delete el._vue_visibilityState;\n  }\n}\n\nvar ObserveVisibility = {\n  beforeMount: bind,\n  updated: update,\n  unmounted: unbind\n};\n\nfunction install(Vue) {\n  Vue.directive('observe-visibility', ObserveVisibility);\n  /* -- Add more components here -- */\n}\n/* -- Plugin definition & Auto-install -- */\n\n/* You shouldn't have to modify the code below */\n// Plugin\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"0.4.6\",\n  install: install\n};\n\nvar GlobalVue = null;\n\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\n\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n\nexport default plugin;\nexport { ObserveVisibility, install };\n","(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    root.Scrollparent = factory();\n  }\n}(this, function () {\n  var regex = /(auto|scroll)/;\n\n  var parents = function (node, ps) {\n    if (node.parentNode === null) { return ps; }\n\n    return parents(node.parentNode, ps.concat([node]));\n  };\n\n  var style = function (node, prop) {\n    return getComputedStyle(node, null).getPropertyValue(prop);\n  };\n\n  var overflow = function (node) {\n    return style(node, \"overflow\") + style(node, \"overflow-y\") + style(node, \"overflow-x\");\n  };\n\n  var scroll = function (node) {\n   return regex.test(overflow(node));\n  };\n\n  var scrollParent = function (node) {\n    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n      return ;\n    }\n\n    var ps = parents(node.parentNode, []);\n\n    for (var i = 0; i < ps.length; i += 1) {\n      if (scroll(ps[i])) {\n        return ps[i];\n      }\n    }\n\n    return document.scrollingElement || document.documentElement;\n  };\n\n  return scrollParent;\n}));\n","export const props = {\r\n  items: {\r\n    type: Array,\r\n    required: true,\r\n  },\r\n\r\n  keyField: {\r\n    type: String,\r\n    default: 'id',\r\n  },\r\n\r\n  direction: {\r\n    type: String,\r\n    default: 'vertical',\r\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\r\n  },\r\n}\r\n\r\nexport function simpleArray () {\r\n  return this.items.length && typeof this.items[0] !== 'object'\r\n}\r\n","export let supportsPassive = false\r\n\r\nif (typeof window !== 'undefined') {\r\n  supportsPassive = false\r\n  try {\r\n    var opts = Object.defineProperty({}, 'passive', {\r\n      get () {\r\n        supportsPassive = true\r\n      },\r\n    })\r\n    window.addEventListener('test', null, opts)\r\n  } catch (e) {}\r\n}\r\n","<template>\r\n  <div\r\n    v-observe-visibility=\"handleVisibilityChange\"\r\n    class=\"vue-recycle-scroller\"\r\n    :class=\"{\r\n      ready,\r\n      'page-mode': pageMode,\r\n      [`direction-${direction}`]: true,\r\n    }\"\r\n    @scroll.passive=\"handleScroll\"\r\n  >\r\n    <div\r\n      v-if=\"$slots.before\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"before\"\r\n      />\r\n    </div>\r\n\r\n    <div\r\n      ref=\"wrapper\"\r\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\r\n      class=\"vue-recycle-scroller__item-wrapper\"\r\n    >\r\n      <div\r\n        v-for=\"view of pool\"\r\n        :key=\"view.nr.id\"\r\n        :style=\"ready ? { transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px)` } : null\"\r\n        class=\"vue-recycle-scroller__item-view\"\r\n        :class=\"{ hover: hoverKey === view.nr.key }\"\r\n        @mouseenter=\"hoverKey = view.nr.key\"\r\n        @mouseleave=\"hoverKey = null\"\r\n      >\r\n        <slot\r\n          :item=\"view.item\"\r\n          :index=\"view.nr.index\"\r\n          :active=\"view.nr.used\"\r\n        />\r\n      </div>\r\n    </div>\r\n\r\n    <div\r\n      v-if=\"$slots.after\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"after\"\r\n      />\r\n    </div>\r\n\r\n    <ResizeObserver @notify=\"handleResize\" />\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { shallowReactive } from 'vue';\r\nimport { ResizeObserver } from 'vue-resize'\r\nimport { ObserveVisibility } from 'vue-observe-visibility'\r\nimport ScrollParent from 'scrollparent'\r\nimport config from '../config'\r\nimport { props, simpleArray } from './common'\r\nimport { supportsPassive } from '../utils'\r\n\r\nlet uid = 0\r\n\r\nexport default {\r\n  name: 'RecycleScroller',\r\n\r\n  components: {\r\n    ResizeObserver,\r\n  },\r\n\r\n  directives: {\r\n    ObserveVisibility,\r\n  },\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    itemSize: {\r\n      type: Number,\r\n      default: null,\r\n    },\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      default: null,\r\n    },\r\n\r\n    sizeField: {\r\n      type: String,\r\n      default: 'size',\r\n    },\r\n\r\n    typeField: {\r\n      type: String,\r\n      default: 'type',\r\n    },\r\n\r\n    buffer: {\r\n      type: Number,\r\n      default: 200,\r\n    },\r\n\r\n    pageMode: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    prerender: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n\r\n    emitUpdate: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n  },\r\n\r\n  data () {\r\n    return {\r\n      pool: [],\r\n      totalSize: 0,\r\n      ready: false,\r\n      hoverKey: null,\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    sizes () {\r\n      if (this.itemSize === null) {\r\n        const sizes = {\r\n          '-1': { accumulator: 0 },\r\n        }\r\n        const items = this.items\r\n        const field = this.sizeField\r\n        const minItemSize = this.minItemSize\r\n        let computedMinSize = 10000\r\n        let accumulator = 0\r\n        let current\r\n        for (let i = 0, l = items.length; i < l; i++) {\r\n          current = items[i][field] || minItemSize\r\n          if (current < computedMinSize) {\r\n            computedMinSize = current\r\n          }\r\n          accumulator += current\r\n          sizes[i] = { accumulator, size: current }\r\n        }\r\n        // eslint-disable-next-line\r\n        this.$_computedMinItemSize = computedMinSize\r\n        return sizes\r\n      }\r\n      return []\r\n    },\r\n\r\n    simpleArray,\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.updateVisibleItems(true)\r\n    },\r\n\r\n    pageMode () {\r\n      this.applyPageMode()\r\n      this.updateVisibleItems(false)\r\n    },\r\n\r\n    sizes: {\r\n      handler () {\r\n        this.updateVisibleItems(false)\r\n      },\r\n      deep: true,\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_startIndex = 0\r\n    this.$_endIndex = 0\r\n    this.$_views = new Map()\r\n    this.$_unusedViews = new Map()\r\n    this.$_scrollDirty = false\r\n    this.$_lastUpdateScrollPosition = 0\r\n\r\n    // In SSR mode, we also prerender the same number of item for the first render\r\n    // to avoir mismatch between server and client templates\r\n    if (this.prerender) {\r\n      this.$_prerender = true\r\n      this.updateVisibleItems(false)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    this.applyPageMode()\r\n    this.$nextTick(() => {\r\n      // In SSR mode, render the real number of visible items\r\n      this.$_prerender = false\r\n      this.updateVisibleItems(true)\r\n      this.ready = true\r\n    })\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.removeListeners()\r\n  },\r\n\r\n  methods: {\r\n    addView (pool, index, item, key, type) {\r\n      const view = shallowReactive({\r\n        item,\r\n        position: 0,\r\n        nr: {\r\n          id: uid++,\r\n          index,\r\n          used: true,\r\n          key,\r\n          type,\r\n        },\r\n      })\r\n      pool.push(view)\r\n      return view\r\n    },\r\n\r\n    unuseView (view, fake = false) {\r\n      const unusedViews = this.$_unusedViews\r\n      const type = view.nr.type\r\n      let unusedPool = unusedViews.get(type)\r\n      if (!unusedPool) {\r\n        unusedPool = []\r\n        unusedViews.set(type, unusedPool)\r\n      }\r\n      unusedPool.push(view)\r\n      if (!fake) {\r\n        view.nr.used = false\r\n        view.position = -9999\r\n        this.$_views.delete(view.nr.key)\r\n      }\r\n    },\r\n\r\n    handleResize () {\r\n      this.$emit('resize')\r\n      if (this.ready) this.updateVisibleItems(false)\r\n    },\r\n\r\n    handleScroll (event) {\r\n      if (!this.$_scrollDirty) {\r\n        this.$_scrollDirty = true\r\n        requestAnimationFrame(() => {\r\n          this.$_scrollDirty = false\r\n          const { continuous } = this.updateVisibleItems(false, true)\r\n\r\n          // It seems sometimes chrome doesn't fire scroll event :/\r\n          // When non continous scrolling is ending, we force a refresh\r\n          if (!continuous) {\r\n            clearTimeout(this.$_refreshTimout)\r\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\r\n          }\r\n        })\r\n      }\r\n    },\r\n\r\n    handleVisibilityChange (isVisible, entry) {\r\n      if (this.ready) {\r\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\r\n          this.$emit('visible')\r\n          requestAnimationFrame(() => {\r\n            this.updateVisibleItems(false)\r\n          })\r\n        } else {\r\n          this.$emit('hidden')\r\n        }\r\n      }\r\n    },\r\n\r\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\r\n      const itemSize = this.itemSize\r\n      const minItemSize = this.$_computedMinItemSize\r\n      const typeField = this.typeField\r\n      const keyField = this.simpleArray ? null : this.keyField\r\n      const items = this.items\r\n      const count = items.length\r\n      const sizes = this.sizes\r\n      const views = this.$_views\r\n      const unusedViews = this.$_unusedViews\r\n      const pool = this.pool\r\n      let startIndex, endIndex\r\n      let totalSize\r\n\r\n      if (!count) {\r\n        startIndex = endIndex = totalSize = 0\r\n      } else if (this.$_prerender) {\r\n        startIndex = 0\r\n        endIndex = this.prerender\r\n        totalSize = null\r\n      } else {\r\n        const scroll = this.getScroll()\r\n\r\n        // Skip update if use hasn't scrolled enough\r\n        if (checkPositionDiff) {\r\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\r\n          if (positionDiff < 0) positionDiff = -positionDiff\r\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\r\n            return {\r\n              continuous: true,\r\n            }\r\n          }\r\n        }\r\n        this.$_lastUpdateScrollPosition = scroll.start\r\n\r\n        const buffer = this.buffer\r\n        scroll.start -= buffer\r\n        scroll.end += buffer\r\n\r\n        // Variable size mode\r\n        if (itemSize === null) {\r\n          let h\r\n          let a = 0\r\n          let b = count - 1\r\n          let i = ~~(count / 2)\r\n          let oldI\r\n\r\n          // Searching for startIndex\r\n          do {\r\n            oldI = i\r\n            h = sizes[i].accumulator\r\n            if (h < scroll.start) {\r\n              a = i\r\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\r\n              b = i\r\n            }\r\n            i = ~~((a + b) / 2)\r\n          } while (i !== oldI)\r\n          i < 0 && (i = 0)\r\n          startIndex = i\r\n\r\n          // For container style\r\n          totalSize = sizes[count - 1].accumulator\r\n\r\n          // Searching for endIndex\r\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\r\n          if (endIndex === -1) {\r\n            endIndex = items.length - 1\r\n          } else {\r\n            endIndex++\r\n            // Bounds\r\n            endIndex > count && (endIndex = count)\r\n          }\r\n        } else {\r\n          // Fixed size mode\r\n          startIndex = ~~(scroll.start / itemSize)\r\n          endIndex = Math.ceil(scroll.end / itemSize)\r\n\r\n          // Bounds\r\n          startIndex < 0 && (startIndex = 0)\r\n          endIndex > count && (endIndex = count)\r\n\r\n          totalSize = count * itemSize\r\n        }\r\n      }\r\n\r\n      if (endIndex - startIndex > config.itemsLimit) {\r\n        this.itemsLimitError()\r\n      }\r\n\r\n      this.totalSize = totalSize\r\n\r\n      let view\r\n\r\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\r\n\r\n      if (this.$_continuous !== continuous) {\r\n        if (continuous) {\r\n          views.clear()\r\n          unusedViews.clear()\r\n          for (let i = 0, l = pool.length; i < l; i++) {\r\n            view = pool[i]\r\n            this.unuseView(view)\r\n          }\r\n        }\r\n        this.$_continuous = continuous\r\n      } else if (continuous) {\r\n        for (let i = 0, l = pool.length; i < l; i++) {\r\n          view = pool[i]\r\n          if (view.nr.used) {\r\n            // Update view item index\r\n            if (checkItem) {\r\n              view.nr.index = items.findIndex(\r\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item,\r\n              )\r\n            }\r\n\r\n            // Check if index is still in visible range\r\n            if (\r\n              view.nr.index === -1 ||\r\n              view.nr.index < startIndex ||\r\n              view.nr.index >= endIndex\r\n            ) {\r\n              this.unuseView(view)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const unusedIndex = continuous ? null : new Map()\r\n\r\n      let item, type, unusedPool\r\n      let v\r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        item = items[i]\r\n        const key = keyField ? item[keyField] : item\r\n        if (key == null) {\r\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\r\n        }\r\n        view = views.get(key)\r\n\r\n        if (!itemSize && !sizes[i].size) {\r\n          if (view) this.unuseView(view)\r\n          continue\r\n        }\r\n\r\n        // No view assigned to item\r\n        if (!view) {\r\n          type = item[typeField]\r\n          unusedPool = unusedViews.get(type)\r\n\r\n          if (continuous) {\r\n            // Reuse existing view\r\n            if (unusedPool && unusedPool.length) {\r\n              view = unusedPool.pop()\r\n              view.item = item\r\n              view.nr.used = true\r\n              view.nr.index = i\r\n              view.nr.key = key\r\n              view.nr.type = type\r\n            } else {\r\n              view = this.addView(pool, i, item, key, type)\r\n            }\r\n          } else {\r\n            // Use existing view\r\n            // We don't care if they are already used\r\n            // because we are not in continous scrolling\r\n            v = unusedIndex.get(type) || 0\r\n\r\n            if (!unusedPool || v >= unusedPool.length) {\r\n              view = this.addView(pool, i, item, key, type)\r\n              this.unuseView(view, true)\r\n              unusedPool = unusedViews.get(type)\r\n            }\r\n\r\n            view = unusedPool[v]\r\n            view.item = item\r\n            view.nr.used = true\r\n            view.nr.index = i\r\n            view.nr.key = key\r\n            view.nr.type = type\r\n            unusedIndex.set(type, v + 1)\r\n            v++\r\n          }\r\n          views.set(key, view)\r\n        } else {\r\n          view.nr.used = true\r\n          view.item = item\r\n        }\r\n\r\n        // Update position\r\n        if (itemSize === null) {\r\n          view.position = sizes[i - 1].accumulator\r\n        } else {\r\n          view.position = i * itemSize\r\n        }\r\n      }\r\n\r\n      this.$_startIndex = startIndex\r\n      this.$_endIndex = endIndex\r\n\r\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex)\r\n\r\n      // After the user has finished scrolling\r\n      // Sort views so text selection is correct\r\n      clearTimeout(this.$_sortTimer)\r\n      this.$_sortTimer = setTimeout(this.sortViews, 300)\r\n\r\n      return {\r\n        continuous,\r\n      }\r\n    },\r\n\r\n    getListenerTarget () {\r\n      let target = ScrollParent(this.$el)\r\n      // Fix global scroll target for Chrome and Safari\r\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\r\n        target = window\r\n      }\r\n      return target\r\n    },\r\n\r\n    getScroll () {\r\n      const { $el: el, direction } = this\r\n      const isVertical = direction === 'vertical'\r\n      let scrollState\r\n\r\n      if (this.pageMode) {\r\n        const bounds = el.getBoundingClientRect()\r\n        const boundsSize = isVertical ? bounds.height : bounds.width\r\n        let start = -(isVertical ? bounds.top : bounds.left)\r\n        let size = isVertical ? window.innerHeight : window.innerWidth\r\n        if (start < 0) {\r\n          size += start\r\n          start = 0\r\n        }\r\n        if (start + size > boundsSize) {\r\n          size = boundsSize - start\r\n        }\r\n        scrollState = {\r\n          start,\r\n          end: start + size,\r\n        }\r\n      } else if (isVertical) {\r\n        scrollState = {\r\n          start: el.scrollTop,\r\n          end: el.scrollTop + el.clientHeight,\r\n        }\r\n      } else {\r\n        scrollState = {\r\n          start: el.scrollLeft,\r\n          end: el.scrollLeft + el.clientWidth,\r\n        }\r\n      }\r\n\r\n      return scrollState\r\n    },\r\n\r\n    applyPageMode () {\r\n      if (this.pageMode) {\r\n        this.addListeners()\r\n      } else {\r\n        this.removeListeners()\r\n      }\r\n    },\r\n\r\n    addListeners () {\r\n      this.listenerTarget = this.getListenerTarget()\r\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {\r\n        passive: true,\r\n      } : false)\r\n      this.listenerTarget.addEventListener('resize', this.handleResize)\r\n    },\r\n\r\n    removeListeners () {\r\n      if (!this.listenerTarget) {\r\n        return\r\n      }\r\n\r\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\r\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\r\n\r\n      this.listenerTarget = null\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      let scroll\r\n      if (this.itemSize === null) {\r\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\r\n      } else {\r\n        scroll = index * this.itemSize\r\n      }\r\n      this.scrollToPosition(scroll)\r\n    },\r\n\r\n    scrollToPosition (position) {\r\n      if (this.direction === 'vertical') {\r\n        this.$el.scrollTop = position\r\n      } else {\r\n        this.$el.scrollLeft = position\r\n      }\r\n    },\r\n\r\n    itemsLimitError () {\r\n      setTimeout(() => {\r\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\r\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\r\n      })\r\n      throw new Error('Rendered items limit reached')\r\n    },\r\n\r\n    sortViews () {\r\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style>\r\n.vue-recycle-scroller {\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\r\n  overflow-y: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\r\n  overflow-x: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal {\r\n  display: flex;\r\n}\r\n\r\n.vue-recycle-scroller__slot {\r\n  flex: auto 0 0;\r\n}\r\n\r\n.vue-recycle-scroller__item-wrapper {\r\n  flex: 1;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  will-change: transform;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\r\n  height: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\r\n  height: 100%;\r\n}\r\n</style>\r\n","<template>\r\n  <div\r\n    v-observe-visibility=\"handleVisibilityChange\"\r\n    class=\"vue-recycle-scroller\"\r\n    :class=\"{\r\n      ready,\r\n      'page-mode': pageMode,\r\n      [`direction-${direction}`]: true,\r\n    }\"\r\n    @scroll.passive=\"handleScroll\"\r\n  >\r\n    <div\r\n      v-if=\"$slots.before\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"before\"\r\n      />\r\n    </div>\r\n\r\n    <div\r\n      ref=\"wrapper\"\r\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\r\n      class=\"vue-recycle-scroller__item-wrapper\"\r\n    >\r\n      <div\r\n        v-for=\"view of pool\"\r\n        :key=\"view.nr.id\"\r\n        :style=\"ready ? { transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px)` } : null\"\r\n        class=\"vue-recycle-scroller__item-view\"\r\n        :class=\"{ hover: hoverKey === view.nr.key }\"\r\n        @mouseenter=\"hoverKey = view.nr.key\"\r\n        @mouseleave=\"hoverKey = null\"\r\n      >\r\n        <slot\r\n          :item=\"view.item\"\r\n          :index=\"view.nr.index\"\r\n          :active=\"view.nr.used\"\r\n        />\r\n      </div>\r\n    </div>\r\n\r\n    <div\r\n      v-if=\"$slots.after\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"after\"\r\n      />\r\n    </div>\r\n\r\n    <ResizeObserver @notify=\"handleResize\" />\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { shallowReactive } from 'vue';\r\nimport { ResizeObserver } from 'vue-resize'\r\nimport { ObserveVisibility } from 'vue-observe-visibility'\r\nimport ScrollParent from 'scrollparent'\r\nimport config from '../config'\r\nimport { props, simpleArray } from './common'\r\nimport { supportsPassive } from '../utils'\r\n\r\nlet uid = 0\r\n\r\nexport default {\r\n  name: 'RecycleScroller',\r\n\r\n  components: {\r\n    ResizeObserver,\r\n  },\r\n\r\n  directives: {\r\n    ObserveVisibility,\r\n  },\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    itemSize: {\r\n      type: Number,\r\n      default: null,\r\n    },\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      default: null,\r\n    },\r\n\r\n    sizeField: {\r\n      type: String,\r\n      default: 'size',\r\n    },\r\n\r\n    typeField: {\r\n      type: String,\r\n      default: 'type',\r\n    },\r\n\r\n    buffer: {\r\n      type: Number,\r\n      default: 200,\r\n    },\r\n\r\n    pageMode: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    prerender: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n\r\n    emitUpdate: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n  },\r\n\r\n  data () {\r\n    return {\r\n      pool: [],\r\n      totalSize: 0,\r\n      ready: false,\r\n      hoverKey: null,\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    sizes () {\r\n      if (this.itemSize === null) {\r\n        const sizes = {\r\n          '-1': { accumulator: 0 },\r\n        }\r\n        const items = this.items\r\n        const field = this.sizeField\r\n        const minItemSize = this.minItemSize\r\n        let computedMinSize = 10000\r\n        let accumulator = 0\r\n        let current\r\n        for (let i = 0, l = items.length; i < l; i++) {\r\n          current = items[i][field] || minItemSize\r\n          if (current < computedMinSize) {\r\n            computedMinSize = current\r\n          }\r\n          accumulator += current\r\n          sizes[i] = { accumulator, size: current }\r\n        }\r\n        // eslint-disable-next-line\r\n        this.$_computedMinItemSize = computedMinSize\r\n        return sizes\r\n      }\r\n      return []\r\n    },\r\n\r\n    simpleArray,\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.updateVisibleItems(true)\r\n    },\r\n\r\n    pageMode () {\r\n      this.applyPageMode()\r\n      this.updateVisibleItems(false)\r\n    },\r\n\r\n    sizes: {\r\n      handler () {\r\n        this.updateVisibleItems(false)\r\n      },\r\n      deep: true,\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_startIndex = 0\r\n    this.$_endIndex = 0\r\n    this.$_views = new Map()\r\n    this.$_unusedViews = new Map()\r\n    this.$_scrollDirty = false\r\n    this.$_lastUpdateScrollPosition = 0\r\n\r\n    // In SSR mode, we also prerender the same number of item for the first render\r\n    // to avoir mismatch between server and client templates\r\n    if (this.prerender) {\r\n      this.$_prerender = true\r\n      this.updateVisibleItems(false)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    this.applyPageMode()\r\n    this.$nextTick(() => {\r\n      // In SSR mode, render the real number of visible items\r\n      this.$_prerender = false\r\n      this.updateVisibleItems(true)\r\n      this.ready = true\r\n    })\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.removeListeners()\r\n  },\r\n\r\n  methods: {\r\n    addView (pool, index, item, key, type) {\r\n      const view = shallowReactive({\r\n        item,\r\n        position: 0,\r\n        nr: {\r\n          id: uid++,\r\n          index,\r\n          used: true,\r\n          key,\r\n          type,\r\n        },\r\n      })\r\n      pool.push(view)\r\n      return view\r\n    },\r\n\r\n    unuseView (view, fake = false) {\r\n      const unusedViews = this.$_unusedViews\r\n      const type = view.nr.type\r\n      let unusedPool = unusedViews.get(type)\r\n      if (!unusedPool) {\r\n        unusedPool = []\r\n        unusedViews.set(type, unusedPool)\r\n      }\r\n      unusedPool.push(view)\r\n      if (!fake) {\r\n        view.nr.used = false\r\n        view.position = -9999\r\n        this.$_views.delete(view.nr.key)\r\n      }\r\n    },\r\n\r\n    handleResize () {\r\n      this.$emit('resize')\r\n      if (this.ready) this.updateVisibleItems(false)\r\n    },\r\n\r\n    handleScroll (event) {\r\n      if (!this.$_scrollDirty) {\r\n        this.$_scrollDirty = true\r\n        requestAnimationFrame(() => {\r\n          this.$_scrollDirty = false\r\n          const { continuous } = this.updateVisibleItems(false, true)\r\n\r\n          // It seems sometimes chrome doesn't fire scroll event :/\r\n          // When non continous scrolling is ending, we force a refresh\r\n          if (!continuous) {\r\n            clearTimeout(this.$_refreshTimout)\r\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\r\n          }\r\n        })\r\n      }\r\n    },\r\n\r\n    handleVisibilityChange (isVisible, entry) {\r\n      if (this.ready) {\r\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\r\n          this.$emit('visible')\r\n          requestAnimationFrame(() => {\r\n            this.updateVisibleItems(false)\r\n          })\r\n        } else {\r\n          this.$emit('hidden')\r\n        }\r\n      }\r\n    },\r\n\r\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\r\n      const itemSize = this.itemSize\r\n      const minItemSize = this.$_computedMinItemSize\r\n      const typeField = this.typeField\r\n      const keyField = this.simpleArray ? null : this.keyField\r\n      const items = this.items\r\n      const count = items.length\r\n      const sizes = this.sizes\r\n      const views = this.$_views\r\n      const unusedViews = this.$_unusedViews\r\n      const pool = this.pool\r\n      let startIndex, endIndex\r\n      let totalSize\r\n\r\n      if (!count) {\r\n        startIndex = endIndex = totalSize = 0\r\n      } else if (this.$_prerender) {\r\n        startIndex = 0\r\n        endIndex = this.prerender\r\n        totalSize = null\r\n      } else {\r\n        const scroll = this.getScroll()\r\n\r\n        // Skip update if use hasn't scrolled enough\r\n        if (checkPositionDiff) {\r\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\r\n          if (positionDiff < 0) positionDiff = -positionDiff\r\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\r\n            return {\r\n              continuous: true,\r\n            }\r\n          }\r\n        }\r\n        this.$_lastUpdateScrollPosition = scroll.start\r\n\r\n        const buffer = this.buffer\r\n        scroll.start -= buffer\r\n        scroll.end += buffer\r\n\r\n        // Variable size mode\r\n        if (itemSize === null) {\r\n          let h\r\n          let a = 0\r\n          let b = count - 1\r\n          let i = ~~(count / 2)\r\n          let oldI\r\n\r\n          // Searching for startIndex\r\n          do {\r\n            oldI = i\r\n            h = sizes[i].accumulator\r\n            if (h < scroll.start) {\r\n              a = i\r\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\r\n              b = i\r\n            }\r\n            i = ~~((a + b) / 2)\r\n          } while (i !== oldI)\r\n          i < 0 && (i = 0)\r\n          startIndex = i\r\n\r\n          // For container style\r\n          totalSize = sizes[count - 1].accumulator\r\n\r\n          // Searching for endIndex\r\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\r\n          if (endIndex === -1) {\r\n            endIndex = items.length - 1\r\n          } else {\r\n            endIndex++\r\n            // Bounds\r\n            endIndex > count && (endIndex = count)\r\n          }\r\n        } else {\r\n          // Fixed size mode\r\n          startIndex = ~~(scroll.start / itemSize)\r\n          endIndex = Math.ceil(scroll.end / itemSize)\r\n\r\n          // Bounds\r\n          startIndex < 0 && (startIndex = 0)\r\n          endIndex > count && (endIndex = count)\r\n\r\n          totalSize = count * itemSize\r\n        }\r\n      }\r\n\r\n      if (endIndex - startIndex > config.itemsLimit) {\r\n        this.itemsLimitError()\r\n      }\r\n\r\n      this.totalSize = totalSize\r\n\r\n      let view\r\n\r\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\r\n\r\n      if (this.$_continuous !== continuous) {\r\n        if (continuous) {\r\n          views.clear()\r\n          unusedViews.clear()\r\n          for (let i = 0, l = pool.length; i < l; i++) {\r\n            view = pool[i]\r\n            this.unuseView(view)\r\n          }\r\n        }\r\n        this.$_continuous = continuous\r\n      } else if (continuous) {\r\n        for (let i = 0, l = pool.length; i < l; i++) {\r\n          view = pool[i]\r\n          if (view.nr.used) {\r\n            // Update view item index\r\n            if (checkItem) {\r\n              view.nr.index = items.findIndex(\r\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item,\r\n              )\r\n            }\r\n\r\n            // Check if index is still in visible range\r\n            if (\r\n              view.nr.index === -1 ||\r\n              view.nr.index < startIndex ||\r\n              view.nr.index >= endIndex\r\n            ) {\r\n              this.unuseView(view)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const unusedIndex = continuous ? null : new Map()\r\n\r\n      let item, type, unusedPool\r\n      let v\r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        item = items[i]\r\n        const key = keyField ? item[keyField] : item\r\n        if (key == null) {\r\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\r\n        }\r\n        view = views.get(key)\r\n\r\n        if (!itemSize && !sizes[i].size) {\r\n          if (view) this.unuseView(view)\r\n          continue\r\n        }\r\n\r\n        // No view assigned to item\r\n        if (!view) {\r\n          type = item[typeField]\r\n          unusedPool = unusedViews.get(type)\r\n\r\n          if (continuous) {\r\n            // Reuse existing view\r\n            if (unusedPool && unusedPool.length) {\r\n              view = unusedPool.pop()\r\n              view.item = item\r\n              view.nr.used = true\r\n              view.nr.index = i\r\n              view.nr.key = key\r\n              view.nr.type = type\r\n            } else {\r\n              view = this.addView(pool, i, item, key, type)\r\n            }\r\n          } else {\r\n            // Use existing view\r\n            // We don't care if they are already used\r\n            // because we are not in continous scrolling\r\n            v = unusedIndex.get(type) || 0\r\n\r\n            if (!unusedPool || v >= unusedPool.length) {\r\n              view = this.addView(pool, i, item, key, type)\r\n              this.unuseView(view, true)\r\n              unusedPool = unusedViews.get(type)\r\n            }\r\n\r\n            view = unusedPool[v]\r\n            view.item = item\r\n            view.nr.used = true\r\n            view.nr.index = i\r\n            view.nr.key = key\r\n            view.nr.type = type\r\n            unusedIndex.set(type, v + 1)\r\n            v++\r\n          }\r\n          views.set(key, view)\r\n        } else {\r\n          view.nr.used = true\r\n          view.item = item\r\n        }\r\n\r\n        // Update position\r\n        if (itemSize === null) {\r\n          view.position = sizes[i - 1].accumulator\r\n        } else {\r\n          view.position = i * itemSize\r\n        }\r\n      }\r\n\r\n      this.$_startIndex = startIndex\r\n      this.$_endIndex = endIndex\r\n\r\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex)\r\n\r\n      // After the user has finished scrolling\r\n      // Sort views so text selection is correct\r\n      clearTimeout(this.$_sortTimer)\r\n      this.$_sortTimer = setTimeout(this.sortViews, 300)\r\n\r\n      return {\r\n        continuous,\r\n      }\r\n    },\r\n\r\n    getListenerTarget () {\r\n      let target = ScrollParent(this.$el)\r\n      // Fix global scroll target for Chrome and Safari\r\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\r\n        target = window\r\n      }\r\n      return target\r\n    },\r\n\r\n    getScroll () {\r\n      const { $el: el, direction } = this\r\n      const isVertical = direction === 'vertical'\r\n      let scrollState\r\n\r\n      if (this.pageMode) {\r\n        const bounds = el.getBoundingClientRect()\r\n        const boundsSize = isVertical ? bounds.height : bounds.width\r\n        let start = -(isVertical ? bounds.top : bounds.left)\r\n        let size = isVertical ? window.innerHeight : window.innerWidth\r\n        if (start < 0) {\r\n          size += start\r\n          start = 0\r\n        }\r\n        if (start + size > boundsSize) {\r\n          size = boundsSize - start\r\n        }\r\n        scrollState = {\r\n          start,\r\n          end: start + size,\r\n        }\r\n      } else if (isVertical) {\r\n        scrollState = {\r\n          start: el.scrollTop,\r\n          end: el.scrollTop + el.clientHeight,\r\n        }\r\n      } else {\r\n        scrollState = {\r\n          start: el.scrollLeft,\r\n          end: el.scrollLeft + el.clientWidth,\r\n        }\r\n      }\r\n\r\n      return scrollState\r\n    },\r\n\r\n    applyPageMode () {\r\n      if (this.pageMode) {\r\n        this.addListeners()\r\n      } else {\r\n        this.removeListeners()\r\n      }\r\n    },\r\n\r\n    addListeners () {\r\n      this.listenerTarget = this.getListenerTarget()\r\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {\r\n        passive: true,\r\n      } : false)\r\n      this.listenerTarget.addEventListener('resize', this.handleResize)\r\n    },\r\n\r\n    removeListeners () {\r\n      if (!this.listenerTarget) {\r\n        return\r\n      }\r\n\r\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\r\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\r\n\r\n      this.listenerTarget = null\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      let scroll\r\n      if (this.itemSize === null) {\r\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\r\n      } else {\r\n        scroll = index * this.itemSize\r\n      }\r\n      this.scrollToPosition(scroll)\r\n    },\r\n\r\n    scrollToPosition (position) {\r\n      if (this.direction === 'vertical') {\r\n        this.$el.scrollTop = position\r\n      } else {\r\n        this.$el.scrollLeft = position\r\n      }\r\n    },\r\n\r\n    itemsLimitError () {\r\n      setTimeout(() => {\r\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\r\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\r\n      })\r\n      throw new Error('Rendered items limit reached')\r\n    },\r\n\r\n    sortViews () {\r\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style>\r\n.vue-recycle-scroller {\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\r\n  overflow-y: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\r\n  overflow-x: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal {\r\n  display: flex;\r\n}\r\n\r\n.vue-recycle-scroller__slot {\r\n  flex: auto 0 0;\r\n}\r\n\r\n.vue-recycle-scroller__item-wrapper {\r\n  flex: 1;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  will-change: transform;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\r\n  height: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\r\n  height: 100%;\r\n}\r\n</style>\r\n","<template>\r\n  <RecycleScroller\r\n    ref=\"scroller\"\r\n    :items=\"itemsWithSize\"\r\n    :min-item-size=\"minItemSize\"\r\n    :direction=\"direction\"\r\n    key-field=\"id\"\r\n    v-bind=\"$attrs\"\r\n    @resize=\"onScrollerResize\"\r\n    @visible=\"onScrollerVisible\"\r\n    v-on=\"listeners\"\r\n  >\r\n    <template slot-scope=\"{ item: itemWithSize, index, active }\">\r\n      <slot\r\n        v-bind=\"{\r\n          item: itemWithSize.item,\r\n          index,\r\n          active,\r\n          itemWithSize\r\n        }\"\r\n      />\r\n    </template>\r\n    <template slot=\"before\">\r\n      <slot name=\"before\" />\r\n    </template>\r\n    <template slot=\"after\">\r\n      <slot name=\"after\" />\r\n    </template>\r\n  </RecycleScroller>\r\n</template>\r\n\r\n<script>\r\nimport RecycleScroller from './RecycleScroller.vue'\r\nimport { props, simpleArray } from './common'\r\n\r\nexport default {\r\n  name: 'DynamicScroller',\r\n\r\n  components: {\r\n    RecycleScroller,\r\n  },\r\n\r\n  inheritAttrs: false,\r\n\r\n  provide () {\r\n    if (typeof ResizeObserver !== 'undefined') {\r\n      this.$_resizeObserver = new ResizeObserver(entries => {\r\n        for (const entry of entries) {\r\n          if (entry.target) {\r\n            const event = new CustomEvent(\r\n              'resize',\r\n              {\r\n                detail: {\r\n                  contentRect: entry.contentRect,\r\n                },\r\n              },\r\n            )\r\n            entry.target.dispatchEvent(event)\r\n          }\r\n        }\r\n      })\r\n    }\r\n\r\n    return {\r\n      vscrollData: this.vscrollData,\r\n      vscrollParent: this,\r\n      vscrollResizeObserver: this.$_resizeObserver,\r\n    }\r\n  },\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      required: true,\r\n    },\r\n  },\r\n\r\n  data () {\r\n    return {\r\n      vscrollData: {\r\n        active: true,\r\n        sizes: {},\r\n        validSizes: {},\r\n        keyField: this.keyField,\r\n        simpleArray: false,\r\n      },\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    simpleArray,\r\n\r\n    itemsWithSize () {\r\n      const result = []\r\n      const { items, keyField, simpleArray } = this\r\n      const sizes = this.vscrollData.sizes\r\n      for (let i = 0; i < items.length; i++) {\r\n        const item = items[i]\r\n        const id = simpleArray ? i : item[keyField]\r\n        let size = sizes[id]\r\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\r\n          size = 0\r\n        }\r\n        result.push({\r\n          item,\r\n          id,\r\n          size,\r\n        })\r\n      }\r\n      return result\r\n    },\r\n\r\n    listeners () {\r\n      const listeners = {}\r\n      for (const key in this.$listeners) {\r\n        if (key !== 'resize' && key !== 'visible') {\r\n          listeners[key] = this.$listeners[key]\r\n        }\r\n      }\r\n      return listeners\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.forceUpdate(false)\r\n    },\r\n\r\n    simpleArray: {\r\n      handler (value) {\r\n        this.vscrollData.simpleArray = value\r\n      },\r\n      immediate: true,\r\n    },\r\n\r\n    direction (value) {\r\n      this.forceUpdate(true)\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_updates = []\r\n    this.$_undefinedSizes = 0\r\n    this.$_undefinedMap = {}\r\n  },\r\n\r\n  activated () {\r\n    this.vscrollData.active = true\r\n  },\r\n\r\n  deactivated () {\r\n    this.vscrollData.active = false\r\n  },\r\n\r\n  methods: {\r\n    onScrollerResize () {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) {\r\n        this.forceUpdate()\r\n      }\r\n      this.$emit('resize')\r\n    },\r\n\r\n    onScrollerVisible () {\r\n      this.$emit('vscroll:update', { force: false })\r\n      this.$emit('visible')\r\n    },\r\n\r\n    forceUpdate (clear = true) {\r\n      if (clear || this.simpleArray) {\r\n        this.vscrollData.validSizes = {}\r\n      }\r\n      this.$emit('vscroll:update', { force: true })\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) scroller.scrollToItem(index)\r\n    },\r\n\r\n    getItemSize (item, index = undefined) {\r\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\r\n      return this.vscrollData.sizes[id] || 0\r\n    },\r\n\r\n    scrollToBottom () {\r\n      if (this.$_scrollingToBottom) return\r\n      this.$_scrollingToBottom = true\r\n      const el = this.$el\r\n      // Item is inserted to the DOM\r\n      this.$nextTick(() => {\r\n        el.scrollTop = el.scrollHeight + 5000\r\n        // Item sizes are computed\r\n        const cb = () => {\r\n          el.scrollTop = el.scrollHeight + 5000\r\n          requestAnimationFrame(() => {\r\n            el.scrollTop = el.scrollHeight + 5000\r\n            if (this.$_undefinedSizes === 0) {\r\n              this.$_scrollingToBottom = false\r\n            } else {\r\n              requestAnimationFrame(cb)\r\n            }\r\n          })\r\n        }\r\n        requestAnimationFrame(cb)\r\n      })\r\n    },\r\n  },\r\n}\r\n</script>\r\n","<template>\r\n  <RecycleScroller\r\n    ref=\"scroller\"\r\n    :items=\"itemsWithSize\"\r\n    :min-item-size=\"minItemSize\"\r\n    :direction=\"direction\"\r\n    key-field=\"id\"\r\n    v-bind=\"$attrs\"\r\n    @resize=\"onScrollerResize\"\r\n    @visible=\"onScrollerVisible\"\r\n    v-on=\"listeners\"\r\n  >\r\n    <template slot-scope=\"{ item: itemWithSize, index, active }\">\r\n      <slot\r\n        v-bind=\"{\r\n          item: itemWithSize.item,\r\n          index,\r\n          active,\r\n          itemWithSize\r\n        }\"\r\n      />\r\n    </template>\r\n    <template slot=\"before\">\r\n      <slot name=\"before\" />\r\n    </template>\r\n    <template slot=\"after\">\r\n      <slot name=\"after\" />\r\n    </template>\r\n  </RecycleScroller>\r\n</template>\r\n\r\n<script>\r\nimport RecycleScroller from './RecycleScroller.vue'\r\nimport { props, simpleArray } from './common'\r\n\r\nexport default {\r\n  name: 'DynamicScroller',\r\n\r\n  components: {\r\n    RecycleScroller,\r\n  },\r\n\r\n  inheritAttrs: false,\r\n\r\n  provide () {\r\n    if (typeof ResizeObserver !== 'undefined') {\r\n      this.$_resizeObserver = new ResizeObserver(entries => {\r\n        for (const entry of entries) {\r\n          if (entry.target) {\r\n            const event = new CustomEvent(\r\n              'resize',\r\n              {\r\n                detail: {\r\n                  contentRect: entry.contentRect,\r\n                },\r\n              },\r\n            )\r\n            entry.target.dispatchEvent(event)\r\n          }\r\n        }\r\n      })\r\n    }\r\n\r\n    return {\r\n      vscrollData: this.vscrollData,\r\n      vscrollParent: this,\r\n      vscrollResizeObserver: this.$_resizeObserver,\r\n    }\r\n  },\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      required: true,\r\n    },\r\n  },\r\n\r\n  data () {\r\n    return {\r\n      vscrollData: {\r\n        active: true,\r\n        sizes: {},\r\n        validSizes: {},\r\n        keyField: this.keyField,\r\n        simpleArray: false,\r\n      },\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    simpleArray,\r\n\r\n    itemsWithSize () {\r\n      const result = []\r\n      const { items, keyField, simpleArray } = this\r\n      const sizes = this.vscrollData.sizes\r\n      for (let i = 0; i < items.length; i++) {\r\n        const item = items[i]\r\n        const id = simpleArray ? i : item[keyField]\r\n        let size = sizes[id]\r\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\r\n          size = 0\r\n        }\r\n        result.push({\r\n          item,\r\n          id,\r\n          size,\r\n        })\r\n      }\r\n      return result\r\n    },\r\n\r\n    listeners () {\r\n      const listeners = {}\r\n      for (const key in this.$listeners) {\r\n        if (key !== 'resize' && key !== 'visible') {\r\n          listeners[key] = this.$listeners[key]\r\n        }\r\n      }\r\n      return listeners\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.forceUpdate(false)\r\n    },\r\n\r\n    simpleArray: {\r\n      handler (value) {\r\n        this.vscrollData.simpleArray = value\r\n      },\r\n      immediate: true,\r\n    },\r\n\r\n    direction (value) {\r\n      this.forceUpdate(true)\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_updates = []\r\n    this.$_undefinedSizes = 0\r\n    this.$_undefinedMap = {}\r\n  },\r\n\r\n  activated () {\r\n    this.vscrollData.active = true\r\n  },\r\n\r\n  deactivated () {\r\n    this.vscrollData.active = false\r\n  },\r\n\r\n  methods: {\r\n    onScrollerResize () {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) {\r\n        this.forceUpdate()\r\n      }\r\n      this.$emit('resize')\r\n    },\r\n\r\n    onScrollerVisible () {\r\n      this.$emit('vscroll:update', { force: false })\r\n      this.$emit('visible')\r\n    },\r\n\r\n    forceUpdate (clear = true) {\r\n      if (clear || this.simpleArray) {\r\n        this.vscrollData.validSizes = {}\r\n      }\r\n      this.$emit('vscroll:update', { force: true })\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) scroller.scrollToItem(index)\r\n    },\r\n\r\n    getItemSize (item, index = undefined) {\r\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\r\n      return this.vscrollData.sizes[id] || 0\r\n    },\r\n\r\n    scrollToBottom () {\r\n      if (this.$_scrollingToBottom) return\r\n      this.$_scrollingToBottom = true\r\n      const el = this.$el\r\n      // Item is inserted to the DOM\r\n      this.$nextTick(() => {\r\n        el.scrollTop = el.scrollHeight + 5000\r\n        // Item sizes are computed\r\n        const cb = () => {\r\n          el.scrollTop = el.scrollHeight + 5000\r\n          requestAnimationFrame(() => {\r\n            el.scrollTop = el.scrollHeight + 5000\r\n            if (this.$_undefinedSizes === 0) {\r\n              this.$_scrollingToBottom = false\r\n            } else {\r\n              requestAnimationFrame(cb)\r\n            }\r\n          })\r\n        }\r\n        requestAnimationFrame(cb)\r\n      })\r\n    },\r\n  },\r\n}\r\n</script>\r\n","<script>\r\nexport default {\r\n  name: 'DynamicScrollerItem',\r\n\r\n  inject: [\r\n    'vscrollData',\r\n    'vscrollParent',\r\n    'vscrollResizeObserver',\r\n  ],\r\n\r\n  props: {\r\n    // eslint-disable-next-line vue/require-prop-types\r\n    item: {\r\n      required: true,\r\n    },\r\n\r\n    watchData: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    /**\r\n     * Indicates if the view is actively used to display an item.\r\n     */\r\n    active: {\r\n      type: Boolean,\r\n      required: true,\r\n    },\r\n\r\n    index: {\r\n      type: Number,\r\n      default: undefined,\r\n    },\r\n\r\n    sizeDependencies: {\r\n      type: [Array, Object],\r\n      default: null,\r\n    },\r\n\r\n    emitResize: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    tag: {\r\n      type: String,\r\n      default: 'div',\r\n    },\r\n  },\r\n\r\n  computed: {\r\n    id () {\r\n      return this.vscrollData.simpleArray ? this.index : this.item[this.vscrollData.keyField]\r\n    },\r\n\r\n    size () {\r\n      return (this.vscrollData.validSizes[this.id] && this.vscrollData.sizes[this.id]) || 0\r\n    },\r\n\r\n    finalActive () {\r\n      return this.active && this.vscrollData.active\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    watchData: 'updateWatchData',\r\n\r\n    id () {\r\n      if (!this.size) {\r\n        this.onDataUpdate()\r\n      }\r\n    },\r\n\r\n    finalActive (value) {\r\n      if (!this.size) {\r\n        if (value) {\r\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\r\n            this.vscrollParent.$_undefinedSizes++\r\n            this.vscrollParent.$_undefinedMap[this.id] = true\r\n          }\r\n        } else {\r\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\r\n            this.vscrollParent.$_undefinedSizes--\r\n            this.vscrollParent.$_undefinedMap[this.id] = false\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.vscrollResizeObserver) {\r\n        if (value) {\r\n          this.observeSize()\r\n        } else {\r\n          this.unobserveSize()\r\n        }\r\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\r\n        this.updateSize()\r\n      }\r\n    },\r\n  },\r\n\r\n  created () {\r\n    if (this.$isServer) return\r\n\r\n    this.$_forceNextVScrollUpdate = null\r\n    this.updateWatchData()\r\n\r\n    if (!this.vscrollResizeObserver) {\r\n      for (const k in this.sizeDependencies) {\r\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate)\r\n      }\r\n\r\n      this.vscrollParent.$on('vscroll:update', this.onVscrollUpdate)\r\n      this.vscrollParent.$on('vscroll:update-size', this.onVscrollUpdateSize)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    if (this.vscrollData.active) {\r\n      this.updateSize()\r\n      this.observeSize()\r\n    }\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.vscrollParent.$off('vscroll:update', this.onVscrollUpdate)\r\n    this.vscrollParent.$off('vscroll:update-size', this.onVscrollUpdateSize)\r\n    this.unobserveSize()\r\n  },\r\n\r\n  methods: {\r\n    updateSize () {\r\n      if (this.finalActive) {\r\n        if (this.$_pendingSizeUpdate !== this.id) {\r\n          this.$_pendingSizeUpdate = this.id\r\n          this.$_forceNextVScrollUpdate = null\r\n          this.$_pendingVScrollUpdate = null\r\n          this.computeSize(this.id)\r\n        }\r\n      } else {\r\n        this.$_forceNextVScrollUpdate = this.id\r\n      }\r\n    },\r\n\r\n    updateWatchData () {\r\n      if (this.watchData) {\r\n        this.$_watchData = this.$watch('data', () => {\r\n          this.onDataUpdate()\r\n        }, {\r\n          deep: true,\r\n        })\r\n      } else if (this.$_watchData) {\r\n        this.$_watchData()\r\n        this.$_watchData = null\r\n      }\r\n    },\r\n\r\n    onVscrollUpdate ({ force }) {\r\n      // If not active, sechedule a size update when it becomes active\r\n      if (!this.finalActive && force) {\r\n        this.$_pendingVScrollUpdate = this.id\r\n      }\r\n\r\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\r\n        this.updateSize()\r\n      }\r\n    },\r\n\r\n    onDataUpdate () {\r\n      this.updateSize()\r\n    },\r\n\r\n    computeSize (id) {\r\n      this.$nextTick(() => {\r\n        if (this.id === id) {\r\n          const width = this.$el.offsetWidth\r\n          const height = this.$el.offsetHeight\r\n          this.applySize(width, height)\r\n        }\r\n        this.$_pendingSizeUpdate = null\r\n      })\r\n    },\r\n\r\n    applySize (width, height) {\r\n      const size = Math.round(this.vscrollParent.direction === 'vertical' ? height : width)\r\n      if (size && this.size !== size) {\r\n        if (this.vscrollParent.$_undefinedMap[this.id]) {\r\n          this.vscrollParent.$_undefinedSizes--\r\n          this.vscrollParent.$_undefinedMap[this.id] = undefined\r\n        }\r\n        this.$set(this.vscrollData.sizes, this.id, size)\r\n        this.$set(this.vscrollData.validSizes, this.id, true)\r\n        if (this.emitResize) this.$emit('resize', this.id)\r\n      }\r\n    },\r\n\r\n    observeSize () {\r\n      if (!this.vscrollResizeObserver) return\r\n      this.vscrollResizeObserver.observe(this.$el.parentNode)\r\n      this.$el.parentNode.addEventListener('resize', this.onResize)\r\n    },\r\n\r\n    unobserveSize () {\r\n      if (!this.vscrollResizeObserver) return\r\n      this.vscrollResizeObserver.unobserve(this.$el.parentNode)\r\n      this.$el.parentNode.removeEventListener('resize', this.onResize)\r\n    },\r\n\r\n    onResize (event) {\r\n      const { width, height } = event.detail.contentRect\r\n      this.applySize(width, height)\r\n    },\r\n  },\r\n\r\n  render (h) {\r\n    console.log('render', h);\r\n    return h(this.tag, this.$slots.default)\r\n  },\r\n}\r\n</script>\r\n","import config from './config'\r\n\r\nimport RecycleScroller from './components/RecycleScroller.vue'\r\nimport DynamicScroller from './components/DynamicScroller.vue'\r\nimport DynamicScrollerItem from './components/DynamicScrollerItem.vue'\r\n\r\nexport { default as IdState } from './mixins/IdState'\r\n\r\nexport {\r\n  RecycleScroller,\r\n  DynamicScroller,\r\n  DynamicScrollerItem,\r\n}\r\n\r\nfunction registerComponents (Vue, prefix) {\r\n  Vue.component(`${prefix}recycle-scroller`, RecycleScroller)\r\n  Vue.component(`${prefix}RecycleScroller`, RecycleScroller)\r\n  Vue.component(`${prefix}dynamic-scroller`, DynamicScroller)\r\n  Vue.component(`${prefix}DynamicScroller`, DynamicScroller)\r\n  Vue.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\r\n  Vue.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\r\n}\r\n\r\nconst plugin = {\r\n  // eslint-disable-next-line no-undef\r\n  version: VERSION,\r\n  install (Vue, options) {\r\n    const finalOptions = Object.assign({}, {\r\n      installComponents: true,\r\n      componentsPrefix: '',\r\n    }, options)\r\n\r\n    for (const key in finalOptions) {\r\n      if (typeof finalOptions[key] !== 'undefined') {\r\n        config[key] = finalOptions[key]\r\n      }\r\n    }\r\n\r\n    if (finalOptions.installComponents) {\r\n      registerComponents(Vue, finalOptions.componentsPrefix)\r\n    }\r\n  },\r\n}\r\n\r\nexport default plugin\r\n\r\n// Auto-install\r\nlet GlobalVue = null\r\nif (typeof window !== 'undefined') {\r\n  GlobalVue = window.Vue\r\n} else if (typeof global !== 'undefined') {\r\n  GlobalVue = global.Vue\r\n}\r\nif (GlobalVue) {\r\n  GlobalVue.use(plugin)\r\n}\r\n","import { reactive } from 'vue'\r\n\r\nexport default function ({\r\n  idProp = vm => vm.item.id,\r\n} = {}) {\r\n  const store = reactive({})\r\n\r\n  // @vue/component\r\n  return {\r\n    data () {\r\n      return {\r\n        idState: null,\r\n      }\r\n    },\r\n\r\n    created () {\r\n      this.$_id = null\r\n      if (typeof idProp === 'function') {\r\n        this.$_getId = () => idProp.call(this, this)\r\n      } else {\r\n        this.$_getId = () => this[idProp]\r\n      }\r\n      this.$watch(this.$_getId, {\r\n        handler (value) {\r\n          this.$nextTick(() => {\r\n            this.$_id = value\r\n          })\r\n        },\r\n        immediate: true,\r\n      })\r\n      this.$_updateIdState()\r\n    },\r\n\r\n    beforeUpdate () {\r\n      this.$_updateIdState()\r\n    },\r\n\r\n    methods: {\r\n      /**\r\n       * Initialize an idState\r\n       * @param {number|string} id Unique id for the data\r\n       */\r\n      $_idStateInit (id) {\r\n        const factory = this.$options.idState\r\n        if (typeof factory === 'function') {\r\n          const data = factory.call(this, this)\r\n          store[id] = data\r\n          this.$_id = id\r\n          return data\r\n        } else {\r\n          throw new Error('[mixin IdState] Missing `idState` function on component definition.')\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Ensure idState is created and up-to-date\r\n       */\r\n      $_updateIdState () {\r\n        const id = this.$_getId()\r\n        if (id == null) {\r\n          console.warn(`No id found for IdState with idProp: '${idProp}'.`)\r\n        }\r\n        if (id !== this.$_id) {\r\n          if (!store[id]) {\r\n            this.$_idStateInit(id)\r\n          }\r\n          this.idState = store[id]\r\n        }\r\n      },\r\n    },\r\n  }\r\n}\r\n"],"names":["itemsLimit","makeMap","str","expectsLowerCase","map","Object","create","list","split","i","length","val","toLowerCase","isGloballyWhitelisted","normalizeStyle","value","isArray","res","item","normalized","isString","parseStringStyle","key","isObject","listDelimiterRE","propertyDelimiterRE","cssText","ret","forEach","tmp","trim","normalizeClass","name","fn","cache","_globalThis","EMPTY_OBJ","process","env","NODE_ENV","freeze","EMPTY_ARR","NOOP","onRE","isOn","test","extend","assign","remove","arr","el","indexOf","splice","hasOwnProperty","prototype","hasOwn","call","Array","isMap","toTypeString","isSet","isFunction","isSymbol","_typeof","objectToString","toString","toRawType","slice","isIntegerKey","parseInt","capitalize","charAt","toUpperCase","hasChanged","oldValue","then","catch","globalThis","self","window","global","obj","Symbol","_typeof2","iterator","constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","_toConsumableArray","arr2","_arrayWithoutHoles","iter","from","_iterableToArray","TypeError","_nonIterableSpread","isSpecialBooleanAttr","activeEffect","isModelListener","startsWith","cacheStringFunction","camelizeRE","camelize","replace","_","c","hyphenateRE","hyphenate","targetMap","WeakMap","effectStack","ITERATE_KEY","MAP_KEY_ITERATE_KEY","isEffect","_isEffect","effect","options","raw","createReactiveEffect","lazy","stop","active","cleanup","onStop","uid","scheduler","undefined","includes","trackStack","push","shouldTrack","pop","resetTracking","id","allowRecurse","deps","delete","pauseTracking","last","track","type","depsMap","get","set","Map","dep","Set","has","add","onTrack","trigger","newValue","oldTarget","effects","effectsToAdd","onTrigger","builtInSymbols","getOwnPropertyNames","filter","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","isReadonly","shallow","receiver","readonlyMap","reactiveMap","targetIsArray","Reflect","isRef","readonly","reactive","createSetter","toRaw","hadKey","Number","result","method","this","l","args","apply","mutableHandlers","deleteProperty","ownKeys","readonlyHandlers","console","warn","String","shallowReadonlyHandlers","toReactive","toReadonly","toShallow","getProto","v","getPrototypeOf","get$1","isShallow","rawTarget","rawKey","wrap","has$1","size","set$1","checkIdentityKeys","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","targetIsMap","isPair","isKeyOnly","innerIterator","next","done","createReadonlyMethod","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","createInstrumentationGetter","instrumentations","mutableCollectionHandlers","readonlyCollectionHandlers","createReactiveObject","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","isExtensible","rawType","targetTypeMap","proxy","Proxy","isReactive","isProxy","r","Boolean","__v_isRef","stack","pushWarningContext","vnode","popWarningContext","msg","instance","component","appWarnHandler","appContext","config","warnHandler","trace","getComponentTrace","callWithErrorHandling","join","formatComponentName","warnArgs","formatTrace","currentVNode","normalizedStack","recurseCount","parentInstance","parent","logs","entry","postfix","isRoot","open","close","keys","formatProp","JSON","stringify","formatProps","ErrorTypeStrings","err","handleError","callWithAsyncErrorHandling","values","throwInDev","contextVNode","cur","exposedInstance","errorInfo","errorCapturedHooks","ec","appErrorHandler","errorHandler","logError","info","error","isFlushing","isFlushPending","queue","flushIndex","pendingPreFlushCbs","activePreFlushCbs","preFlushIndex","pendingPostFlushCbs","activePostFlushCbs","postFlushIndex","resolvedPromise","Promise","resolve","currentFlushPromise","currentPreFlushParentJob","nextTick","p","bind","queueJob","job","queueFlush","flushJobs","queueCb","cb","activeQueue","pendingQueue","index","queuePreFlushCb","queuePostFlushCb","getId","Infinity","seen","flushPreFlushCbs","parentJob","checkRecursiveUpdates","sort","a","b","deduped","flushPostFlushCbs","count","Error","hmrDirtyComponents","__VUE_HMR_RUNTIME__","createRecord","tryWrap","isClassComponent","__vccOpts","instances","rerender","newRender","record","render","renderCache","update","reload","newComp","location","arg","e","isSuspense","__isSuspense","normalizeSuspenseChildren","content","fallback","shapeFlag","children","normalizeSuspenseSlot","default","normalizeVNode","s","singleChild","singleRoot","child","isVNode","Comment","filterSingleRoot","isRenderingCompiledSlot","setCompiledSlotRendering","n","INITIAL_WATCHER_VALUE","instanceWatch","source","publicThis","immediate","deep","flush","currentInstance","getter","warnInvalidSource","forceTrigger","_shallow","traverse","isUnmounted","onInvalidate","baseGetter","runner","queuePostRenderEffect","suspense","isMounted","recordInstanceBoundEffect","doWatch","pendingBranch","isTeleport","__isTeleport","NULL_DYNAMIC_COMPONENT","Fragment","Text","__v_isVNode","normalizeKey","normalizeRef","ref","createVNode","_createVNode","patchFlag","dynamicProps","cloned","cloneVNode","normalizeChildren","klass","class","style","ssContent","ssFallback","extraProps","mergeRef","mergedProps","mergeProps","concat","scopeId","targetAnchor","staticCount","dynamicChildren","dirs","transition","anchor","createTextVNode","text","flag","slot","_c","slotFlag","_ctx","arguments","toMerge","existing","incoming","mergeOptions","to","strats","optionMergeStrategies","mixins","extendsOptions","extends","m","publicPropertiesMap","$","$el","$data","data","$props","$attrs","attrs","$slots","slots","$refs","refs","$parent","getPublicInstance","$root","root","$emit","emit","$options","__VUE_OPTIONS_API__","__merged","globalMixins","resolveMergedOptions","$forceUpdate","$nextTick","$watch","PublicInstanceProxyHandlers","normalizedProps","ctx","setupState","accessCache","propsOptions","cssModule","globalProperties","publicGetter","__cssModules","unscopables","classifyRE","classify","Component","displayName","__file","match","inferFromRegistry","registry","components","initCustomFormatter","vueStyle","numberStyle","stringStyle","keywordStyle","formatter","header","__isVue","genRefFlag","formatValue","hasBody","body","blocks","createInstanceBlock","computed","extractKeys","injected","object","formatInstance","devtoolsFormatters","asRaw","Comp","extracted","isKeyOfType","opts","some","tempContainer","tempSVGContainer","svgNS","doc","document","nodeOps","insert","insertBefore","parentNode","removeChild","createElement","tag","isSVG","is","createElementNS","createText","createTextNode","createComment","setText","node","nodeValue","setElementText","textContent","nextSibling","querySelector","selector","setScopeId","setAttribute","cloneNode","insertStaticContent","temp","innerHTML","first","firstChild","patchClass","transitionClasses","_vtc","className","patchStyle","prev","setStyle","removeAttribute","importantRE","setProperty","prefixed","rawName","cached","prefixCache","prefixes","autoPrefix","xlinkNS","patchAttr","removeAttributeNS","setAttributeNS","isBoolean","patchDOMProp","prevChildren","parentComponent","parentSuspense","unmountChildren","tagName","_value","_getNow","Date","now","createEvent","timeStamp","performance","cachedNow","reset","addEventListener","event","handler","removeEventListener","patchEvent","prevValue","nextValue","invokers","_vei","existingInvoker","parseName","invoker","createInvoker","optionsModifierRE","initialValue","attached","originalStop","stopImmediatePropagation","_stopped","patchStopImmediatePropagation","nativeOnRE","shouldSetAsProp","patchProp","_trueValue","_falseValue","forcePatchProp","__VUE__","__VUE_DEVTOOLS_GLOBAL_HOOK__","initDev","VisibilityState","Constructor","_classCallCheck","observer","frozen","createObserver","protoProps","staticProps","_this","destroyObserver","once","throttle","_leading","throttleOptions","leading","delay","timeout","lastState","currentArgs","throttled","state","_len","_key","clearTimeout","setTimeout","_clear","oldResult","IntersectionObserver","entries","intersectingEntry","find","isIntersecting","intersectionRatio","threshold","intersection","observe","disconnect","_ref2","_vue_visibilityState","unbind","ObserveVisibility","beforeMount","updated","_ref3","deepEqual","val1","val2","unmounted","plugin","version","install","Vue","directive","GlobalVue","use","factory","regex","parents","ps","prop","getComputedStyle","getPropertyValue","scroll","overflow","HTMLElement","SVGElement","scrollingElement","documentElement","module","exports","Scrollparent","items","required","keyField","direction","validator","simpleArray","supportsPassive","ResizeObserver","directives","itemSize","minItemSize","sizeField","typeField","buffer","pageMode","prerender","emitUpdate","pool","totalSize","ready","hoverKey","sizes","current","accumulator","field","computedMinSize","$_computedMinItemSize","watch","updateVisibleItems","applyPageMode","created","$_startIndex","$_endIndex","$_views","$_unusedViews","$_scrollDirty","$_lastUpdateScrollPosition","$_prerender","mounted","beforeUnmount","removeListeners","methods","addView","view","shallowReactive","position","nr","used","unuseView","fake","unusedViews","unusedPool","handleResize","handleScroll","requestAnimationFrame","_this2","continuous","$_refreshTimout","handleVisibilityChange","isVisible","boundingClientRect","width","height","_this3","checkItem","startIndex","endIndex","checkPositionDiff","views","getScroll","positionDiff","start","end","oldI","Math","ceil","itemsLimitError","$_continuous","findIndex","unusedIndex","$_sortTimer","sortViews","getListenerTarget","ScrollParent","scrollState","isVertical","bounds","getBoundingClientRect","boundsSize","top","left","innerHeight","innerWidth","scrollTop","clientHeight","scrollLeft","clientWidth","addListeners","listenerTarget","passive","scrollToItem","scrollToPosition","log","_this4","viewA","viewB","_createBlock","before","_hoisted_1","_renderSlot","onMouseenter","onMouseleave","after","_hoisted_2","onNotify","RecycleScroller","inheritAttrs","provide","$_resizeObserver","CustomEvent","detail","contentRect","dispatchEvent","vscrollData","vscrollParent","vscrollResizeObserver","validSizes","itemsWithSize","$_undefinedMap","listeners","$listeners","forceUpdate","$_updates","$_undefinedSizes","activated","deactivated","onScrollerResize","scroller","onScrollerVisible","force","getItemSize","scrollToBottom","$_scrollingToBottom","scrollHeight","_mergeProps","onResize","onVisible","_toHandlers","_hoisted_3","inject","watchData","sizeDependencies","emitResize","finalActive","onDataUpdate","observeSize","unobserveSize","$_pendingVScrollUpdate","updateSize","$isServer","$_forceNextVScrollUpdate","updateWatchData","k","$on","onVscrollUpdate","onVscrollUpdateSize","$off","$_pendingSizeUpdate","computeSize","$_watchData","offsetWidth","offsetHeight","applySize","round","$set","unobserve","h","VERSION","finalOptions","installComponents","componentsPrefix","prefix","DynamicScroller","DynamicScrollerItem","registerComponents","idProp","vm","store","idState","$_id","$_getId","$_updateIdState","beforeUpdate","$_idStateInit"],"mappings":"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"}