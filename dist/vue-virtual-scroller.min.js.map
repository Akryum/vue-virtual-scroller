{"version":3,"file":"vue-virtual-scroller.min.js","sources":["../src/config.js","../node_modules/vue-resize/dist/vue-resize.esm.js","../node_modules/vue-observe-visibility/dist/vue-observe-visibility.esm.js","../node_modules/scrollparent/scrollparent.js","../src/components/common.js","../src/utils.js","../src/components/RecycleScroller.vue","../src/components/RecycleScroller.vue?vue&type=template&id=093a936d&lang.js","../src/components/DynamicScroller.vue","../src/components/DynamicScroller.vue?vue&type=template&id=76e15f19&lang.js","../src/components/DynamicScrollerItem.vue","../src/index.js","../src/mixins/IdState.js"],"sourcesContent":["export default {\r\n  itemsLimit: 1000,\r\n}\r\n","/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            res += normalizeClass(value[i]) + ' ';\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst NOOP = () => { };\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if ((process.env.NODE_ENV !== 'production') && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key)\r\n            ? builtInSymbols.has(key)\r\n            : key === `__proto__` || key === `__v_isRef`) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    target.add(value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    pauseTracking();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    resetTracking();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (isString(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (isRef(value)) {\r\n        value = formatProp(key, toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (isFunction(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n    [\"c\" /* CREATED */]: 'created hook',\r\n    [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n    [\"m\" /* MOUNTED */]: 'mounted hook',\r\n    [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n    [\"u\" /* UPDATED */]: 'updated',\r\n    [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n    [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n    [\"a\" /* ACTIVATED */]: 'activated hook',\r\n    [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n    [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n    [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n    [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n    [0 /* SETUP_FUNCTION */]: 'setup function',\r\n    [1 /* RENDER_FUNCTION */]: 'render function',\r\n    [2 /* WATCH_GETTER */]: 'watcher getter',\r\n    [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n    [7 /* VNODE_HOOK */]: 'vnode hook',\r\n    [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n    [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n    [12 /* FUNCTION_REF */]: 'ref function',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (isFunction(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && isPromise(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = (process.env.NODE_ENV !== 'production') ? ErrorTypeStrings[type] : type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const info = ErrorTypeStrings[type];\r\n        if (contextVNode) {\r\n            pushWarningContext(contextVNode);\r\n        }\r\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\r\n        if (contextVNode) {\r\n            popWarningContext();\r\n        }\r\n        // crash in dev by default so it's more noticeable\r\n        if (throwInDev) {\r\n            throw err;\r\n        }\r\n        else {\r\n            console.error(err);\r\n        }\r\n    }\r\n    else {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        queue.push(job);\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!isArray(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex]);\r\n            }\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex]);\r\n            }\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        seen = seen || new Map();\r\n    }\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkRecursiveUpdates(seen, job);\r\n                }\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length || pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            throw new Error(`Maximum recursive updates exceeded. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\nconst hmrDirtyComponents = new Set();\r\n// Expose the HMR runtime on the global object\r\n// This makes it entirely tree-shakable without polluting the exports and makes\r\n// it easier to be used in toolings like vue-loader\r\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n// to be set so that its instances can be registered / removed.\r\nif ((process.env.NODE_ENV !== 'production')) {\r\n    const globalObject = typeof global !== 'undefined'\r\n        ? global\r\n        : typeof self !== 'undefined'\r\n            ? self\r\n            : typeof window !== 'undefined'\r\n                ? window\r\n                : {};\r\n    globalObject.__VUE_HMR_RUNTIME__ = {\r\n        createRecord: tryWrap(createRecord),\r\n        rerender: tryWrap(rerender),\r\n        reload: tryWrap(reload)\r\n    };\r\n}\r\nconst map = new Map();\r\nfunction createRecord(id, component) {\r\n    if (!component) {\r\n        warn(`HMR API usage is out of date.\\n` +\r\n            `Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ` +\r\n            `depdendency that handles Vue SFC compilation.`);\r\n        component = {};\r\n    }\r\n    if (map.has(id)) {\r\n        return false;\r\n    }\r\n    map.set(id, {\r\n        component: isClassComponent(component) ? component.__vccOpts : component,\r\n        instances: new Set()\r\n    });\r\n    return true;\r\n}\r\nfunction rerender(id, newRender) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    if (newRender)\r\n        record.component.render = newRender;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    Array.from(record.instances).forEach(instance => {\r\n        if (newRender) {\r\n            instance.render = newRender;\r\n        }\r\n        instance.renderCache = [];\r\n        instance.update();\r\n    });\r\n}\r\nfunction reload(id, newComp) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    const { component, instances } = record;\r\n    if (!hmrDirtyComponents.has(component)) {\r\n        // 1. Update existing comp definition to match new one\r\n        newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;\r\n        extend(component, newComp);\r\n        for (const key in component) {\r\n            if (!(key in newComp)) {\r\n                delete component[key];\r\n            }\r\n        }\r\n        // 2. Mark component dirty. This forces the renderer to replace the component\r\n        // on patch.\r\n        hmrDirtyComponents.add(component);\r\n        // 3. Make sure to unmark the component after the reload.\r\n        queuePostFlushCb(() => {\r\n            hmrDirtyComponents.delete(component);\r\n        });\r\n    }\r\n    Array.from(instances).forEach(instance => {\r\n        if (instance.parent) {\r\n            // 4. Force the parent instance to re-render. This will cause all updated\r\n            // components to be unmounted and re-mounted. Queue the update so that we\r\n            // don't end up forcing the same parent to re-render multiple times.\r\n            queueJob(instance.parent.update);\r\n        }\r\n        else if (instance.appContext.reload) {\r\n            // root instance mounted via createApp() has a reload method\r\n            instance.appContext.reload();\r\n        }\r\n        else if (typeof window !== 'undefined') {\r\n            // root instance inside tree created via raw render(). Force reload.\r\n            window.location.reload();\r\n        }\r\n        else {\r\n            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\r\n        }\r\n    });\r\n}\r\nfunction tryWrap(fn) {\r\n    return (id, arg) => {\r\n        try {\r\n            return fn(id, arg);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\r\n                `Full reload required.`);\r\n        }\r\n    };\r\n}\nfunction setDevtoolsHook(hook) {\r\n}\r\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nfunction setCurrentRenderingInstance(instance) {\r\n    currentRenderingInstance = instance;\r\n}\r\nfunction markAttrsAccessed() {\r\n}\r\nfunction filterSingleRoot(children) {\r\n    let singleRoot;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (isVNode(child)) {\r\n            // ignore user comment\r\n            if (child.type !== Comment || child.children === 'v-if') {\r\n                if (singleRoot) {\r\n                    // has more than 1 non-comment child, return now\r\n                    return;\r\n                }\r\n                else {\r\n                    singleRoot = child;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    return singleRoot;\r\n}\r\n\nconst isSuspense = (type) => type.__isSuspense;\r\nfunction normalizeSuspenseChildren(vnode) {\r\n    const { shapeFlag, children } = vnode;\r\n    let content;\r\n    let fallback;\r\n    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        content = normalizeSuspenseSlot(children.default);\r\n        fallback = normalizeSuspenseSlot(children.fallback);\r\n    }\r\n    else {\r\n        content = normalizeSuspenseSlot(children);\r\n        fallback = normalizeVNode(null);\r\n    }\r\n    return {\r\n        content,\r\n        fallback\r\n    };\r\n}\r\nfunction normalizeSuspenseSlot(s) {\r\n    if (isFunction(s)) {\r\n        s = s();\r\n    }\r\n    if (isArray(s)) {\r\n        const singleChild = filterSingleRoot(s);\r\n        if ((process.env.NODE_ENV !== 'production') && !singleChild) {\r\n            warn(`<Suspense> slots expect a single root node.`);\r\n        }\r\n        s = singleChild;\r\n    }\r\n    return normalizeVNode(s);\r\n}\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if (isArray(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\n\nlet isRenderingCompiledSlot = 0;\r\nconst setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);\r\n\n/**\r\n * Wrap a slot function to memoize current rendering instance\r\n * @private\r\n */\r\nfunction withCtx(fn, ctx = currentRenderingInstance) {\r\n    if (!ctx)\r\n        return fn;\r\n    const renderFnWithContext = (...args) => {\r\n        // If a user calls a compiled slot inside a template expression (#1745), it\r\n        // can mess up block tracking, so by default we need to push a null block to\r\n        // avoid that. This isn't necessary if rendering a compiled `<slot>`.\r\n        if (!isRenderingCompiledSlot) {\r\n            openBlock(true /* null block that disables tracking */);\r\n        }\r\n        const owner = currentRenderingInstance;\r\n        setCurrentRenderingInstance(ctx);\r\n        const res = fn(...args);\r\n        setCurrentRenderingInstance(owner);\r\n        if (!isRenderingCompiledSlot) {\r\n            closeBlock();\r\n        }\r\n        return res;\r\n    };\r\n    renderFnWithContext._c = true;\r\n    return renderFnWithContext;\r\n}\n\n// SFC scoped style ID management.\r\nlet currentScopeId = null;\r\nconst scopeIdStack = [];\r\n/**\r\n * @private\r\n */\r\nfunction pushScopeId(id) {\r\n    scopeIdStack.push((currentScopeId = id));\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction popScopeId() {\r\n    scopeIdStack.pop();\r\n    currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction withScopeId(id) {\r\n    return ((fn) => withCtx(function () {\r\n        pushScopeId(id);\r\n        const res = fn.apply(this, arguments);\r\n        popScopeId();\r\n        return res;\r\n    }));\r\n}\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ, instance = currentInstance) {\r\n    if ((process.env.NODE_ENV !== 'production') && !cb) {\r\n        if (immediate !== undefined) {\r\n            warn(`watch() \"immediate\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n        if (deep !== undefined) {\r\n            warn(`watch() \"deep\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n    }\r\n    const warnInvalidSource = (s) => {\r\n        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n            `a reactive object, or an array of these types.`);\r\n    };\r\n    let getter;\r\n    let forceTrigger = false;\r\n    if (isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = !!source._shallow;\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        getter = () => source.map(s => {\r\n            if (isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (isFunction(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);\r\n            }\r\n            else {\r\n                (process.env.NODE_ENV !== 'production') && warnInvalidSource(s);\r\n            }\r\n        });\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = NOOP;\r\n        (process.env.NODE_ENV !== 'production') && warnInvalidSource(source);\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    const onInvalidate = (fn) => {\r\n        cleanup = runner.options.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!runner.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = runner();\r\n            if (deep || forceTrigger || hasChanged(newValue, oldValue)) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onInvalidate\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            runner();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = job;\r\n    }\r\n    else if (flush === 'post') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: 'pre'\r\n        scheduler = () => {\r\n            if (!instance || instance.isMounted) {\r\n                queuePreFlushCb(job);\r\n            }\r\n            else {\r\n                // with 'pre' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    const runner = effect(getter, {\r\n        lazy: true,\r\n        onTrack,\r\n        onTrigger,\r\n        scheduler\r\n    });\r\n    recordInstanceBoundEffect(runner, instance);\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = runner();\r\n        }\r\n    }\r\n    else if (flush === 'post') {\r\n        queuePostRenderEffect(runner, instance && instance.suspense);\r\n    }\r\n    else {\r\n        runner();\r\n    }\r\n    return () => {\r\n        stop(runner);\r\n        if (instance) {\r\n            remove(instance.effects, runner);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, cb, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = isString(source)\r\n        ? () => publicThis[source]\r\n        : source.bind(publicThis);\r\n    return doWatch(getter, cb.bind(publicThis), options, this);\r\n}\r\nfunction traverse(value, seen = new Set()) {\r\n    if (!isObject(value) || seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (isSet(value) || isMap(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\nconst queuePostRenderEffect =  queueEffectWithSuspense\r\n    ;\r\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n\nconst Fragment = Symbol((process.env.NODE_ENV !== 'production') ? 'Fragment' : undefined);\r\nconst Text = Symbol((process.env.NODE_ENV !== 'production') ? 'Text' : undefined);\r\nconst Comment = Symbol((process.env.NODE_ENV !== 'production') ? 'Comment' : undefined);\r\nconst Static = Symbol((process.env.NODE_ENV !== 'production') ? 'Static' : undefined);\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nconst blockStack = [];\r\nlet currentBlock = null;\r\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock('div', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\r\nfunction openBlock(disableTracking = false) {\r\n    blockStack.push((currentBlock = disableTracking ? null : []));\r\n}\r\nfunction closeBlock() {\r\n    blockStack.pop();\r\n    currentBlock = blockStack[blockStack.length - 1] || null;\r\n}\r\n/**\r\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n * A block root keeps track of dynamic nodes within the block in the\r\n * `dynamicChildren` array.\r\n *\r\n * @private\r\n */\r\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\r\n    const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */);\r\n    // save current block children on the block vnode\r\n    vnode.dynamicChildren = currentBlock || EMPTY_ARR;\r\n    // close block\r\n    closeBlock();\r\n    // a block is always going to be patched, so track it as a child of its\r\n    // parent block\r\n    if ( currentBlock) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nconst createVNodeWithArgsTransform = (...args) => {\r\n    return _createVNode(...( args));\r\n};\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref }) => {\r\n    return (ref != null\r\n        ? isString(ref) || isRef(ref) || isFunction(ref)\r\n            ? { i: currentRenderingInstance, r: ref }\r\n            : ref\r\n        : null);\r\n};\r\nconst createVNode = ((process.env.NODE_ENV !== 'production')\r\n    ? createVNodeWithArgsTransform\r\n    : _createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        if ((process.env.NODE_ENV !== 'production') && !type) {\r\n            warn(`Invalid vnode type when creating vnode: ${type}.`);\r\n        }\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is=\"vnode\"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        if (isProxy(props) || InternalObjectKey in props) {\r\n            props = extend({}, props);\r\n        }\r\n        let { class: klass, style } = props;\r\n        if (klass && !isString(klass)) {\r\n            props.class = normalizeClass(klass);\r\n        }\r\n        if (isObject(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isProxy(style) && !isArray(style)) {\r\n                style = extend({}, style);\r\n            }\r\n            props.style = normalizeStyle(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = isString(type)\r\n        ? 1 /* ELEMENT */\r\n        :  isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : isObject(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : isFunction(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    if ((process.env.NODE_ENV !== 'production') && shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {\r\n        type = toRaw(type);\r\n        warn(`Vue received a Component which was made a reactive object. This can ` +\r\n            `lead to unnecessary performance overhead, and should be avoided by ` +\r\n            `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\r\n            `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\r\n    }\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        children: null,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    // validate key\r\n    if ((process.env.NODE_ENV !== 'production') && vnode.key !== vnode.key) {\r\n        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\r\n    }\r\n    normalizeChildren(vnode, children);\r\n    // normalize suspense children\r\n    if ( shapeFlag & 128 /* SUSPENSE */) {\r\n        const { content, fallback } = normalizeSuspenseChildren(vnode);\r\n        vnode.ssContent = content;\r\n        vnode.ssFallback = fallback;\r\n    }\r\n    if (\r\n        // avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn't need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    return {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? isArray(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        children: vnode.children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: perserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn't affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\nfunction normalizeVNode(child) {\r\n    if (child == null || typeof child === 'boolean') {\r\n        // empty placeholder\r\n        return createVNode(Comment);\r\n    }\r\n    else if (isArray(child)) {\r\n        // fragment\r\n        return createVNode(Fragment, null, child);\r\n    }\r\n    else if (typeof child === 'object') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return child.el === null ? child : cloneVNode(child);\r\n    }\r\n    else {\r\n        // strings and numbers\r\n        return createVNode(Text, null, String(child));\r\n    }\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (isArray(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && setCompiledSlotRendering(1);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && setCompiledSlotRendering(-1);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent's slot type.\r\n                if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n                else {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (isFunction(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = extend({}, args[0]);\r\n    for (let i = 1; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = normalizeClass([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = normalizeStyle([ret.style, toMerge.style]);\r\n            }\r\n            else if (isOn(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (existing !== incoming) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, toMerge[key])\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== '') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\nlet isInBeforeCreate = false;\r\nfunction resolveMergedOptions(instance) {\r\n    const raw = instance.type;\r\n    const { __merged, mixins, extends: extendsOptions } = raw;\r\n    if (__merged)\r\n        return __merged;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (!globalMixins.length && !mixins && !extendsOptions)\r\n        return raw;\r\n    const options = {};\r\n    globalMixins.forEach(m => mergeOptions(options, m, instance));\r\n    mergeOptions(options, raw, instance);\r\n    return (raw.__merged = options);\r\n}\r\nfunction mergeOptions(to, from, instance) {\r\n    const strats = instance.appContext.config.optionMergeStrategies;\r\n    const { mixins, extends: extendsOptions } = from;\r\n    extendsOptions && mergeOptions(to, extendsOptions, instance);\r\n    mixins &&\r\n        mixins.forEach((m) => mergeOptions(to, m, instance));\r\n    for (const key in from) {\r\n        if (strats && hasOwn(strats, key)) {\r\n            to[key] = strats[key](to[key], from[key], instance.proxy, key);\r\n        }\r\n        else {\r\n            to[key] = from[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => i && (i.proxy ? i.proxy : getPublicInstance(i.parent));\r\nconst publicPropertiesMap = extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.props) : i.props),\r\n    $attrs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.attrs) : i.attrs),\r\n    $slots: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.slots) : i.slots),\r\n    $refs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.refs) : i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => i.root && i.root.proxy,\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => () => queueJob(i.update),\r\n    $nextTick: i => nextTick.bind(i.proxy),\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)\r\n});\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // let @vue/reactivity know it should never observe Vue public instances.\r\n        if (key === \"__v_skip\" /* SKIP */) {\r\n            return true;\r\n        }\r\n        // for internal formatters to know that this is a Vue instance\r\n        if ((process.env.NODE_ENV !== 'production') && key === '__isVue') {\r\n            return true;\r\n        }\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== '$') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 0 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 1 /* DATA */:\r\n                        return data[key];\r\n                    case 3 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 2 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n                accessCache[key] = 0 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n                accessCache[key] = 1 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                hasOwn(normalizedProps, key)) {\r\n                accessCache[key] = 2 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n                accessCache[key] = 3 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (!__VUE_OPTIONS_API__ || !isInBeforeCreate) {\r\n                accessCache[key] = 4 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === '$attrs') {\r\n                track(instance, \"get\" /* GET */, key);\r\n                (process.env.NODE_ENV !== 'production') && markAttrsAccessed();\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 3 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // global properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            hasOwn(globalProperties, key))) {\r\n            return globalProperties[key];\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production') &&\r\n            currentRenderingInstance &&\r\n            (!isString(key) ||\r\n                // #1091 avoid internal isRef/isVNode checks on component instance leading\r\n                // to infinite warning loop\r\n                key.indexOf('__v') !== 0)) {\r\n            if (data !== EMPTY_OBJ &&\r\n                (key[0] === '$' || key[0] === '_') &&\r\n                hasOwn(data, key)) {\r\n                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +\r\n                    `character (\"$\" or \"_\") and is not proxied on the render context.`);\r\n            }\r\n            else {\r\n                warn(`Property ${JSON.stringify(key)} was accessed during render ` +\r\n                    `but is not defined on instance.`);\r\n            }\r\n        }\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n            setupState[key] = value;\r\n        }\r\n        else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n            data[key] = value;\r\n        }\r\n        else if (key in instance.props) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate prop \"${key}\". Props are readonly.`, instance);\r\n            return false;\r\n        }\r\n        if (key[0] === '$' && key.slice(1) in instance) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate public property \"${key}\". ` +\r\n                    `Properties starting with $ are reserved and readonly.`, instance);\r\n            return false;\r\n        }\r\n        else {\r\n            if ((process.env.NODE_ENV !== 'production') && key in instance.appContext.config.globalProperties) {\r\n                Object.defineProperty(ctx, key, {\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    value\r\n                });\r\n            }\r\n            else {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (accessCache[key] !== undefined ||\r\n            (data !== EMPTY_OBJ && hasOwn(data, key)) ||\r\n            (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\r\n            hasOwn(ctx, key) ||\r\n            hasOwn(publicPropertiesMap, key) ||\r\n            hasOwn(appContext.config.globalProperties, key));\r\n    }\r\n};\r\nif ((process.env.NODE_ENV !== 'production') && !false) {\r\n    PublicInstanceProxyHandlers.ownKeys = (target) => {\r\n        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +\r\n            `The keys will be empty in production mode to avoid performance overhead.`);\r\n        return Reflect.ownKeys(target);\r\n    };\r\n}\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== '_' && !isGloballyWhitelisted(key);\r\n        if ((process.env.NODE_ENV !== 'production') && !has && PublicInstanceProxyHandlers.has(_, key)) {\r\n            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\r\n        }\r\n        return has;\r\n    }\r\n});\r\nlet currentInstance = null;\r\n// record effects created during a component's setup() so that they can be\r\n// stopped when the component unmounts\r\nfunction recordInstanceBoundEffect(effect, instance = currentInstance) {\r\n    if (instance) {\r\n        (instance.effects || (instance.effects = [])).push(effect);\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = isFunction(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return isFunction(value) && '__vccOpts' in value;\r\n}\n\nconst ssrContextKey = Symbol((process.env.NODE_ENV !== 'production') ? `ssrContext` : ``);\r\n\nfunction initCustomFormatter() {\r\n    /* eslint-disable no-restricted-globals */\r\n    if (!(process.env.NODE_ENV !== 'production') || typeof window === 'undefined') {\r\n        return;\r\n    }\r\n    const vueStyle = { style: 'color:#3ba776' };\r\n    const numberStyle = { style: 'color:#0b1bc9' };\r\n    const stringStyle = { style: 'color:#b62e24' };\r\n    const keywordStyle = { style: 'color:#9d288c' };\r\n    // custom formatter for Chrome\r\n    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n    const formatter = {\r\n        header(obj) {\r\n            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n            if (!isObject(obj)) {\r\n                return null;\r\n            }\r\n            if (obj.__isVue) {\r\n                return ['div', vueStyle, `VueInstance`];\r\n            }\r\n            else if (isRef(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, genRefFlag(obj)],\r\n                    '<',\r\n                    formatValue(obj.value),\r\n                    `>`\r\n                ];\r\n            }\r\n            else if (isReactive(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Reactive'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    `>${isReadonly(obj) ? ` (readonly)` : ``}`\r\n                ];\r\n            }\r\n            else if (isReadonly(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Readonly'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    '>'\r\n                ];\r\n            }\r\n            return null;\r\n        },\r\n        hasBody(obj) {\r\n            return obj && obj.__isVue;\r\n        },\r\n        body(obj) {\r\n            if (obj && obj.__isVue) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ...formatInstance(obj.$)\r\n                ];\r\n            }\r\n        }\r\n    };\r\n    function formatInstance(instance) {\r\n        const blocks = [];\r\n        if (instance.type.props && instance.props) {\r\n            blocks.push(createInstanceBlock('props', toRaw(instance.props)));\r\n        }\r\n        if (instance.setupState !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('setup', instance.setupState));\r\n        }\r\n        if (instance.data !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('data', toRaw(instance.data)));\r\n        }\r\n        const computed = extractKeys(instance, 'computed');\r\n        if (computed) {\r\n            blocks.push(createInstanceBlock('computed', computed));\r\n        }\r\n        const injected = extractKeys(instance, 'inject');\r\n        if (injected) {\r\n            blocks.push(createInstanceBlock('injected', injected));\r\n        }\r\n        blocks.push([\r\n            'div',\r\n            {},\r\n            [\r\n                'span',\r\n                {\r\n                    style: keywordStyle.style + ';opacity:0.66'\r\n                },\r\n                '$ (internal): '\r\n            ],\r\n            ['object', { object: instance }]\r\n        ]);\r\n        return blocks;\r\n    }\r\n    function createInstanceBlock(type, target) {\r\n        target = extend({}, target);\r\n        if (!Object.keys(target).length) {\r\n            return ['span', {}];\r\n        }\r\n        return [\r\n            'div',\r\n            { style: 'line-height:1.25em;margin-bottom:0.6em' },\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'color:#476582'\r\n                },\r\n                type\r\n            ],\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'padding-left:1.25em'\r\n                },\r\n                ...Object.keys(target).map(key => {\r\n                    return [\r\n                        'div',\r\n                        {},\r\n                        ['span', keywordStyle, key + ': '],\r\n                        formatValue(target[key], false)\r\n                    ];\r\n                })\r\n            ]\r\n        ];\r\n    }\r\n    function formatValue(v, asRaw = true) {\r\n        if (typeof v === 'number') {\r\n            return ['span', numberStyle, v];\r\n        }\r\n        else if (typeof v === 'string') {\r\n            return ['span', stringStyle, JSON.stringify(v)];\r\n        }\r\n        else if (typeof v === 'boolean') {\r\n            return ['span', keywordStyle, v];\r\n        }\r\n        else if (isObject(v)) {\r\n            return ['object', { object: asRaw ? toRaw(v) : v }];\r\n        }\r\n        else {\r\n            return ['span', stringStyle, String(v)];\r\n        }\r\n    }\r\n    function extractKeys(instance, type) {\r\n        const Comp = instance.type;\r\n        if (isFunction(Comp)) {\r\n            return;\r\n        }\r\n        const extracted = {};\r\n        for (const key in instance.ctx) {\r\n            if (isKeyOfType(Comp, key, type)) {\r\n                extracted[key] = instance.ctx[key];\r\n            }\r\n        }\r\n        return extracted;\r\n    }\r\n    function isKeyOfType(Comp, key, type) {\r\n        const opts = Comp[type];\r\n        if ((isArray(opts) && opts.includes(key)) ||\r\n            (isObject(opts) && key in opts)) {\r\n            return true;\r\n        }\r\n        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n            return true;\r\n        }\r\n        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n            return true;\r\n        }\r\n    }\r\n    function genRefFlag(v) {\r\n        if (v._shallow) {\r\n            return `ShallowRef`;\r\n        }\r\n        if (v.effect) {\r\n            return `ComputedRef`;\r\n        }\r\n        return `Ref`;\r\n    }\r\n    if (window.devtoolsFormatters) {\r\n        window.devtoolsFormatters.push(formatter);\r\n    }\r\n    else {\r\n        window.devtoolsFormatters = [formatter];\r\n    }\r\n}\n\nfunction initDev() {\r\n    const target = getGlobalThis();\r\n    target.__VUE__ = true;\r\n    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);\r\n    {\r\n        initCustomFormatter();\r\n    }\r\n}\n\n// This entry exports the runtime only, and is built as\r\n(process.env.NODE_ENV !== 'production') && initDev();\n\nfunction getInternetExplorerVersion() {\n  var ua = window.navigator.userAgent;\n  var msie = ua.indexOf('MSIE ');\n\n  if (msie > 0) {\n    // IE 10 or older => return version number\n    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n  }\n\n  var trident = ua.indexOf('Trident/');\n\n  if (trident > 0) {\n    // IE 11 => return version number\n    var rv = ua.indexOf('rv:');\n    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n  }\n\n  var edge = ua.indexOf('Edge/');\n\n  if (edge > 0) {\n    // Edge (IE 12+) => return version number\n    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n  } // other browser\n\n\n  return -1;\n}\n\nvar isIE;\n\nfunction initCompat() {\n  if (!initCompat.init) {\n    initCompat.init = true;\n    isIE = getInternetExplorerVersion() !== -1;\n  }\n}\n\nvar script = {\n  name: 'ResizeObserver',\n  mounted: function mounted() {\n    var _this = this;\n\n    initCompat();\n    nextTick(function () {\n      _this._w = _this.$el.offsetWidth;\n      _this._h = _this.$el.offsetHeight;\n    });\n    var object = document.createElement('object');\n    this._resizeObject = object;\n    object.setAttribute('aria-hidden', 'true');\n    object.setAttribute('tabindex', -1);\n    object.onload = this.addResizeHandlers;\n    object.type = 'text/html';\n\n    if (isIE) {\n      this.$el.appendChild(object);\n    }\n\n    object.data = 'about:blank';\n\n    if (!isIE) {\n      this.$el.appendChild(object);\n    }\n  },\n  beforeUnmount: function beforeUnmount() {\n    this.removeResizeHandlers();\n  },\n  methods: {\n    compareAndNotify: function compareAndNotify() {\n      if (this._w !== this.$el.offsetWidth || this._h !== this.$el.offsetHeight) {\n        this._w = this.$el.offsetWidth;\n        this._h = this.$el.offsetHeight;\n        this.$emit('notify', {\n          width: this._w,\n          height: this._h\n        });\n      }\n    },\n    addResizeHandlers: function addResizeHandlers() {\n      this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify);\n\n      this.compareAndNotify();\n    },\n    removeResizeHandlers: function removeResizeHandlers() {\n      if (this._resizeObject && this._resizeObject.onload) {\n        if (!isIE && this._resizeObject.contentDocument) {\n          this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify);\n        }\n\n        this.$el.removeChild(this._resizeObject);\n        this._resizeObject.onload = null;\n        this._resizeObject = null;\n      }\n    }\n  }\n};\n\nvar _withId = /*#__PURE__*/withScopeId(\"data-v-b329ee4c\");\n\npushScopeId(\"data-v-b329ee4c\");\n\nvar _hoisted_1 = {\n  class: \"resize-observer\",\n  tabindex: \"-1\"\n};\n\npopScopeId();\n\nvar render = /*#__PURE__*/_withId(function (_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createBlock(\"div\", _hoisted_1);\n});\n\nscript.render = render;\nscript.__scopeId = \"data-v-b329ee4c\";\nscript.__file = \"src/components/ResizeObserver.vue\";\n\nfunction install(Vue) {\n  Vue.component('resize-observer', script);\n  Vue.component('ResizeObserver', script);\n}\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"0.9.0-ropez.1\",\n  install: install\n};\n\nvar GlobalVue = null;\n\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\n\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n\nexport default plugin;\nexport { script as ResizeObserver, install };\n//# sourceMappingURL=vue-resize.esm.js.map\n","function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            res += normalizeClass(value[i]) + ' ';\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst NOOP = () => { };\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if ((process.env.NODE_ENV !== 'production') && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key)\r\n            ? builtInSymbols.has(key)\r\n            : key === `__proto__` || key === `__v_isRef`) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    target.add(value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    pauseTracking();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    resetTracking();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (isString(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (isRef(value)) {\r\n        value = formatProp(key, toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (isFunction(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n    [\"c\" /* CREATED */]: 'created hook',\r\n    [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n    [\"m\" /* MOUNTED */]: 'mounted hook',\r\n    [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n    [\"u\" /* UPDATED */]: 'updated',\r\n    [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n    [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n    [\"a\" /* ACTIVATED */]: 'activated hook',\r\n    [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n    [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n    [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n    [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n    [0 /* SETUP_FUNCTION */]: 'setup function',\r\n    [1 /* RENDER_FUNCTION */]: 'render function',\r\n    [2 /* WATCH_GETTER */]: 'watcher getter',\r\n    [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n    [7 /* VNODE_HOOK */]: 'vnode hook',\r\n    [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n    [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n    [12 /* FUNCTION_REF */]: 'ref function',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (isFunction(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && isPromise(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = (process.env.NODE_ENV !== 'production') ? ErrorTypeStrings[type] : type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const info = ErrorTypeStrings[type];\r\n        if (contextVNode) {\r\n            pushWarningContext(contextVNode);\r\n        }\r\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\r\n        if (contextVNode) {\r\n            popWarningContext();\r\n        }\r\n        // crash in dev by default so it's more noticeable\r\n        if (throwInDev) {\r\n            throw err;\r\n        }\r\n        else {\r\n            console.error(err);\r\n        }\r\n    }\r\n    else {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        queue.push(job);\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!isArray(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex]);\r\n            }\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            seen = seen || new Map();\r\n        }\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex]);\r\n            }\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        seen = seen || new Map();\r\n    }\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job) {\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkRecursiveUpdates(seen, job);\r\n                }\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length || pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            throw new Error(`Maximum recursive updates exceeded. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\nconst hmrDirtyComponents = new Set();\r\n// Expose the HMR runtime on the global object\r\n// This makes it entirely tree-shakable without polluting the exports and makes\r\n// it easier to be used in toolings like vue-loader\r\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n// to be set so that its instances can be registered / removed.\r\nif ((process.env.NODE_ENV !== 'production')) {\r\n    const globalObject = typeof global !== 'undefined'\r\n        ? global\r\n        : typeof self !== 'undefined'\r\n            ? self\r\n            : typeof window !== 'undefined'\r\n                ? window\r\n                : {};\r\n    globalObject.__VUE_HMR_RUNTIME__ = {\r\n        createRecord: tryWrap(createRecord),\r\n        rerender: tryWrap(rerender),\r\n        reload: tryWrap(reload)\r\n    };\r\n}\r\nconst map = new Map();\r\nfunction createRecord(id, component) {\r\n    if (!component) {\r\n        warn(`HMR API usage is out of date.\\n` +\r\n            `Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ` +\r\n            `depdendency that handles Vue SFC compilation.`);\r\n        component = {};\r\n    }\r\n    if (map.has(id)) {\r\n        return false;\r\n    }\r\n    map.set(id, {\r\n        component: isClassComponent(component) ? component.__vccOpts : component,\r\n        instances: new Set()\r\n    });\r\n    return true;\r\n}\r\nfunction rerender(id, newRender) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    if (newRender)\r\n        record.component.render = newRender;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    Array.from(record.instances).forEach(instance => {\r\n        if (newRender) {\r\n            instance.render = newRender;\r\n        }\r\n        instance.renderCache = [];\r\n        instance.update();\r\n    });\r\n}\r\nfunction reload(id, newComp) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    // Array.from creates a snapshot which avoids the set being mutated during\r\n    // updates\r\n    const { component, instances } = record;\r\n    if (!hmrDirtyComponents.has(component)) {\r\n        // 1. Update existing comp definition to match new one\r\n        newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;\r\n        extend(component, newComp);\r\n        for (const key in component) {\r\n            if (!(key in newComp)) {\r\n                delete component[key];\r\n            }\r\n        }\r\n        // 2. Mark component dirty. This forces the renderer to replace the component\r\n        // on patch.\r\n        hmrDirtyComponents.add(component);\r\n        // 3. Make sure to unmark the component after the reload.\r\n        queuePostFlushCb(() => {\r\n            hmrDirtyComponents.delete(component);\r\n        });\r\n    }\r\n    Array.from(instances).forEach(instance => {\r\n        if (instance.parent) {\r\n            // 4. Force the parent instance to re-render. This will cause all updated\r\n            // components to be unmounted and re-mounted. Queue the update so that we\r\n            // don't end up forcing the same parent to re-render multiple times.\r\n            queueJob(instance.parent.update);\r\n        }\r\n        else if (instance.appContext.reload) {\r\n            // root instance mounted via createApp() has a reload method\r\n            instance.appContext.reload();\r\n        }\r\n        else if (typeof window !== 'undefined') {\r\n            // root instance inside tree created via raw render(). Force reload.\r\n            window.location.reload();\r\n        }\r\n        else {\r\n            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\r\n        }\r\n    });\r\n}\r\nfunction tryWrap(fn) {\r\n    return (id, arg) => {\r\n        try {\r\n            return fn(id, arg);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\r\n                `Full reload required.`);\r\n        }\r\n    };\r\n}\nfunction setDevtoolsHook(hook) {\r\n}\r\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nfunction markAttrsAccessed() {\r\n}\r\nfunction filterSingleRoot(children) {\r\n    let singleRoot;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (isVNode(child)) {\r\n            // ignore user comment\r\n            if (child.type !== Comment || child.children === 'v-if') {\r\n                if (singleRoot) {\r\n                    // has more than 1 non-comment child, return now\r\n                    return;\r\n                }\r\n                else {\r\n                    singleRoot = child;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    return singleRoot;\r\n}\r\n\nconst isSuspense = (type) => type.__isSuspense;\r\nfunction normalizeSuspenseChildren(vnode) {\r\n    const { shapeFlag, children } = vnode;\r\n    let content;\r\n    let fallback;\r\n    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        content = normalizeSuspenseSlot(children.default);\r\n        fallback = normalizeSuspenseSlot(children.fallback);\r\n    }\r\n    else {\r\n        content = normalizeSuspenseSlot(children);\r\n        fallback = normalizeVNode(null);\r\n    }\r\n    return {\r\n        content,\r\n        fallback\r\n    };\r\n}\r\nfunction normalizeSuspenseSlot(s) {\r\n    if (isFunction(s)) {\r\n        s = s();\r\n    }\r\n    if (isArray(s)) {\r\n        const singleChild = filterSingleRoot(s);\r\n        if ((process.env.NODE_ENV !== 'production') && !singleChild) {\r\n            warn(`<Suspense> slots expect a single root node.`);\r\n        }\r\n        s = singleChild;\r\n    }\r\n    return normalizeVNode(s);\r\n}\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if (isArray(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\n\nlet isRenderingCompiledSlot = 0;\r\nconst setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);\r\n\n// SFC scoped style ID management.\r\nlet currentScopeId = null;\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ, instance = currentInstance) {\r\n    if ((process.env.NODE_ENV !== 'production') && !cb) {\r\n        if (immediate !== undefined) {\r\n            warn(`watch() \"immediate\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n        if (deep !== undefined) {\r\n            warn(`watch() \"deep\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n    }\r\n    const warnInvalidSource = (s) => {\r\n        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n            `a reactive object, or an array of these types.`);\r\n    };\r\n    let getter;\r\n    let forceTrigger = false;\r\n    if (isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = !!source._shallow;\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        getter = () => source.map(s => {\r\n            if (isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (isFunction(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);\r\n            }\r\n            else {\r\n                (process.env.NODE_ENV !== 'production') && warnInvalidSource(s);\r\n            }\r\n        });\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = NOOP;\r\n        (process.env.NODE_ENV !== 'production') && warnInvalidSource(source);\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    const onInvalidate = (fn) => {\r\n        cleanup = runner.options.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!runner.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = runner();\r\n            if (deep || forceTrigger || hasChanged(newValue, oldValue)) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onInvalidate\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            runner();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = job;\r\n    }\r\n    else if (flush === 'post') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: 'pre'\r\n        scheduler = () => {\r\n            if (!instance || instance.isMounted) {\r\n                queuePreFlushCb(job);\r\n            }\r\n            else {\r\n                // with 'pre' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    const runner = effect(getter, {\r\n        lazy: true,\r\n        onTrack,\r\n        onTrigger,\r\n        scheduler\r\n    });\r\n    recordInstanceBoundEffect(runner, instance);\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = runner();\r\n        }\r\n    }\r\n    else if (flush === 'post') {\r\n        queuePostRenderEffect(runner, instance && instance.suspense);\r\n    }\r\n    else {\r\n        runner();\r\n    }\r\n    return () => {\r\n        stop(runner);\r\n        if (instance) {\r\n            remove(instance.effects, runner);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, cb, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = isString(source)\r\n        ? () => publicThis[source]\r\n        : source.bind(publicThis);\r\n    return doWatch(getter, cb.bind(publicThis), options, this);\r\n}\r\nfunction traverse(value, seen = new Set()) {\r\n    if (!isObject(value) || seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (isSet(value) || isMap(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\nconst queuePostRenderEffect =  queueEffectWithSuspense\r\n    ;\r\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n\nconst Fragment = Symbol((process.env.NODE_ENV !== 'production') ? 'Fragment' : undefined);\r\nconst Text = Symbol((process.env.NODE_ENV !== 'production') ? 'Text' : undefined);\r\nconst Comment = Symbol((process.env.NODE_ENV !== 'production') ? 'Comment' : undefined);\r\nconst Static = Symbol((process.env.NODE_ENV !== 'production') ? 'Static' : undefined);\r\nlet currentBlock = null;\r\n// Whether we should be tracking dynamic child nodes inside a block.\r\n// Only tracks when this value is > 0\r\n// We are not using a simple boolean because this value may need to be\r\n// incremented/decremented by nested usage of v-once (see below)\r\nlet shouldTrack$1 = 1;\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nlet vnodeArgsTransformer;\r\nconst createVNodeWithArgsTransform = (...args) => {\r\n    return _createVNode(...(vnodeArgsTransformer\r\n        ? vnodeArgsTransformer(args, currentRenderingInstance)\r\n        : args));\r\n};\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref }) => {\r\n    return (ref != null\r\n        ? isString(ref) || isRef(ref) || isFunction(ref)\r\n            ? { i: currentRenderingInstance, r: ref }\r\n            : ref\r\n        : null);\r\n};\r\nconst createVNode = ((process.env.NODE_ENV !== 'production')\r\n    ? createVNodeWithArgsTransform\r\n    : _createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        if ((process.env.NODE_ENV !== 'production') && !type) {\r\n            warn(`Invalid vnode type when creating vnode: ${type}.`);\r\n        }\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is=\"vnode\"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        if (isProxy(props) || InternalObjectKey in props) {\r\n            props = extend({}, props);\r\n        }\r\n        let { class: klass, style } = props;\r\n        if (klass && !isString(klass)) {\r\n            props.class = normalizeClass(klass);\r\n        }\r\n        if (isObject(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isProxy(style) && !isArray(style)) {\r\n                style = extend({}, style);\r\n            }\r\n            props.style = normalizeStyle(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = isString(type)\r\n        ? 1 /* ELEMENT */\r\n        :  isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : isObject(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : isFunction(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    if ((process.env.NODE_ENV !== 'production') && shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {\r\n        type = toRaw(type);\r\n        warn(`Vue received a Component which was made a reactive object. This can ` +\r\n            `lead to unnecessary performance overhead, and should be avoided by ` +\r\n            `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\r\n            `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\r\n    }\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        children: null,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    // validate key\r\n    if ((process.env.NODE_ENV !== 'production') && vnode.key !== vnode.key) {\r\n        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\r\n    }\r\n    normalizeChildren(vnode, children);\r\n    // normalize suspense children\r\n    if ( shapeFlag & 128 /* SUSPENSE */) {\r\n        const { content, fallback } = normalizeSuspenseChildren(vnode);\r\n        vnode.ssContent = content;\r\n        vnode.ssFallback = fallback;\r\n    }\r\n    if (shouldTrack$1 > 0 &&\r\n        // avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn't need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    return {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? isArray(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        children: vnode.children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: perserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn't affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\nfunction normalizeVNode(child) {\r\n    if (child == null || typeof child === 'boolean') {\r\n        // empty placeholder\r\n        return createVNode(Comment);\r\n    }\r\n    else if (isArray(child)) {\r\n        // fragment\r\n        return createVNode(Fragment, null, child);\r\n    }\r\n    else if (typeof child === 'object') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return child.el === null ? child : cloneVNode(child);\r\n    }\r\n    else {\r\n        // strings and numbers\r\n        return createVNode(Text, null, String(child));\r\n    }\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (isArray(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && setCompiledSlotRendering(1);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && setCompiledSlotRendering(-1);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent's slot type.\r\n                if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n                else {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (isFunction(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = extend({}, args[0]);\r\n    for (let i = 1; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = normalizeClass([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = normalizeStyle([ret.style, toMerge.style]);\r\n            }\r\n            else if (isOn(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (existing !== incoming) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, toMerge[key])\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== '') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\nlet isInBeforeCreate = false;\r\nfunction resolveMergedOptions(instance) {\r\n    const raw = instance.type;\r\n    const { __merged, mixins, extends: extendsOptions } = raw;\r\n    if (__merged)\r\n        return __merged;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (!globalMixins.length && !mixins && !extendsOptions)\r\n        return raw;\r\n    const options = {};\r\n    globalMixins.forEach(m => mergeOptions(options, m, instance));\r\n    mergeOptions(options, raw, instance);\r\n    return (raw.__merged = options);\r\n}\r\nfunction mergeOptions(to, from, instance) {\r\n    const strats = instance.appContext.config.optionMergeStrategies;\r\n    const { mixins, extends: extendsOptions } = from;\r\n    extendsOptions && mergeOptions(to, extendsOptions, instance);\r\n    mixins &&\r\n        mixins.forEach((m) => mergeOptions(to, m, instance));\r\n    for (const key in from) {\r\n        if (strats && hasOwn(strats, key)) {\r\n            to[key] = strats[key](to[key], from[key], instance.proxy, key);\r\n        }\r\n        else {\r\n            to[key] = from[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => i && (i.proxy ? i.proxy : getPublicInstance(i.parent));\r\nconst publicPropertiesMap = extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.props) : i.props),\r\n    $attrs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.attrs) : i.attrs),\r\n    $slots: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.slots) : i.slots),\r\n    $refs: i => ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.refs) : i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => i.root && i.root.proxy,\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => () => queueJob(i.update),\r\n    $nextTick: i => nextTick.bind(i.proxy),\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)\r\n});\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // let @vue/reactivity know it should never observe Vue public instances.\r\n        if (key === \"__v_skip\" /* SKIP */) {\r\n            return true;\r\n        }\r\n        // for internal formatters to know that this is a Vue instance\r\n        if ((process.env.NODE_ENV !== 'production') && key === '__isVue') {\r\n            return true;\r\n        }\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== '$') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 0 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 1 /* DATA */:\r\n                        return data[key];\r\n                    case 3 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 2 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n                accessCache[key] = 0 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n                accessCache[key] = 1 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                hasOwn(normalizedProps, key)) {\r\n                accessCache[key] = 2 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n                accessCache[key] = 3 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (!__VUE_OPTIONS_API__ || !isInBeforeCreate) {\r\n                accessCache[key] = 4 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === '$attrs') {\r\n                track(instance, \"get\" /* GET */, key);\r\n                (process.env.NODE_ENV !== 'production') && markAttrsAccessed();\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 3 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // global properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            hasOwn(globalProperties, key))) {\r\n            return globalProperties[key];\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production') &&\r\n            currentRenderingInstance &&\r\n            (!isString(key) ||\r\n                // #1091 avoid internal isRef/isVNode checks on component instance leading\r\n                // to infinite warning loop\r\n                key.indexOf('__v') !== 0)) {\r\n            if (data !== EMPTY_OBJ &&\r\n                (key[0] === '$' || key[0] === '_') &&\r\n                hasOwn(data, key)) {\r\n                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +\r\n                    `character (\"$\" or \"_\") and is not proxied on the render context.`);\r\n            }\r\n            else {\r\n                warn(`Property ${JSON.stringify(key)} was accessed during render ` +\r\n                    `but is not defined on instance.`);\r\n            }\r\n        }\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n            setupState[key] = value;\r\n        }\r\n        else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n            data[key] = value;\r\n        }\r\n        else if (key in instance.props) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate prop \"${key}\". Props are readonly.`, instance);\r\n            return false;\r\n        }\r\n        if (key[0] === '$' && key.slice(1) in instance) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Attempting to mutate public property \"${key}\". ` +\r\n                    `Properties starting with $ are reserved and readonly.`, instance);\r\n            return false;\r\n        }\r\n        else {\r\n            if ((process.env.NODE_ENV !== 'production') && key in instance.appContext.config.globalProperties) {\r\n                Object.defineProperty(ctx, key, {\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    value\r\n                });\r\n            }\r\n            else {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (accessCache[key] !== undefined ||\r\n            (data !== EMPTY_OBJ && hasOwn(data, key)) ||\r\n            (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\r\n            hasOwn(ctx, key) ||\r\n            hasOwn(publicPropertiesMap, key) ||\r\n            hasOwn(appContext.config.globalProperties, key));\r\n    }\r\n};\r\nif ((process.env.NODE_ENV !== 'production') && !false) {\r\n    PublicInstanceProxyHandlers.ownKeys = (target) => {\r\n        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +\r\n            `The keys will be empty in production mode to avoid performance overhead.`);\r\n        return Reflect.ownKeys(target);\r\n    };\r\n}\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== '_' && !isGloballyWhitelisted(key);\r\n        if ((process.env.NODE_ENV !== 'production') && !has && PublicInstanceProxyHandlers.has(_, key)) {\r\n            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\r\n        }\r\n        return has;\r\n    }\r\n});\r\nlet currentInstance = null;\r\n// record effects created during a component's setup() so that they can be\r\n// stopped when the component unmounts\r\nfunction recordInstanceBoundEffect(effect, instance = currentInstance) {\r\n    if (instance) {\r\n        (instance.effects || (instance.effects = [])).push(effect);\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = isFunction(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return isFunction(value) && '__vccOpts' in value;\r\n}\n\nconst ssrContextKey = Symbol((process.env.NODE_ENV !== 'production') ? `ssrContext` : ``);\r\n\nfunction initCustomFormatter() {\r\n    /* eslint-disable no-restricted-globals */\r\n    if (!(process.env.NODE_ENV !== 'production') || typeof window === 'undefined') {\r\n        return;\r\n    }\r\n    const vueStyle = { style: 'color:#3ba776' };\r\n    const numberStyle = { style: 'color:#0b1bc9' };\r\n    const stringStyle = { style: 'color:#b62e24' };\r\n    const keywordStyle = { style: 'color:#9d288c' };\r\n    // custom formatter for Chrome\r\n    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n    const formatter = {\r\n        header(obj) {\r\n            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n            if (!isObject(obj)) {\r\n                return null;\r\n            }\r\n            if (obj.__isVue) {\r\n                return ['div', vueStyle, `VueInstance`];\r\n            }\r\n            else if (isRef(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, genRefFlag(obj)],\r\n                    '<',\r\n                    formatValue(obj.value),\r\n                    `>`\r\n                ];\r\n            }\r\n            else if (isReactive(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Reactive'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    `>${isReadonly(obj) ? ` (readonly)` : ``}`\r\n                ];\r\n            }\r\n            else if (isReadonly(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, 'Readonly'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    '>'\r\n                ];\r\n            }\r\n            return null;\r\n        },\r\n        hasBody(obj) {\r\n            return obj && obj.__isVue;\r\n        },\r\n        body(obj) {\r\n            if (obj && obj.__isVue) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ...formatInstance(obj.$)\r\n                ];\r\n            }\r\n        }\r\n    };\r\n    function formatInstance(instance) {\r\n        const blocks = [];\r\n        if (instance.type.props && instance.props) {\r\n            blocks.push(createInstanceBlock('props', toRaw(instance.props)));\r\n        }\r\n        if (instance.setupState !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('setup', instance.setupState));\r\n        }\r\n        if (instance.data !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('data', toRaw(instance.data)));\r\n        }\r\n        const computed = extractKeys(instance, 'computed');\r\n        if (computed) {\r\n            blocks.push(createInstanceBlock('computed', computed));\r\n        }\r\n        const injected = extractKeys(instance, 'inject');\r\n        if (injected) {\r\n            blocks.push(createInstanceBlock('injected', injected));\r\n        }\r\n        blocks.push([\r\n            'div',\r\n            {},\r\n            [\r\n                'span',\r\n                {\r\n                    style: keywordStyle.style + ';opacity:0.66'\r\n                },\r\n                '$ (internal): '\r\n            ],\r\n            ['object', { object: instance }]\r\n        ]);\r\n        return blocks;\r\n    }\r\n    function createInstanceBlock(type, target) {\r\n        target = extend({}, target);\r\n        if (!Object.keys(target).length) {\r\n            return ['span', {}];\r\n        }\r\n        return [\r\n            'div',\r\n            { style: 'line-height:1.25em;margin-bottom:0.6em' },\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'color:#476582'\r\n                },\r\n                type\r\n            ],\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'padding-left:1.25em'\r\n                },\r\n                ...Object.keys(target).map(key => {\r\n                    return [\r\n                        'div',\r\n                        {},\r\n                        ['span', keywordStyle, key + ': '],\r\n                        formatValue(target[key], false)\r\n                    ];\r\n                })\r\n            ]\r\n        ];\r\n    }\r\n    function formatValue(v, asRaw = true) {\r\n        if (typeof v === 'number') {\r\n            return ['span', numberStyle, v];\r\n        }\r\n        else if (typeof v === 'string') {\r\n            return ['span', stringStyle, JSON.stringify(v)];\r\n        }\r\n        else if (typeof v === 'boolean') {\r\n            return ['span', keywordStyle, v];\r\n        }\r\n        else if (isObject(v)) {\r\n            return ['object', { object: asRaw ? toRaw(v) : v }];\r\n        }\r\n        else {\r\n            return ['span', stringStyle, String(v)];\r\n        }\r\n    }\r\n    function extractKeys(instance, type) {\r\n        const Comp = instance.type;\r\n        if (isFunction(Comp)) {\r\n            return;\r\n        }\r\n        const extracted = {};\r\n        for (const key in instance.ctx) {\r\n            if (isKeyOfType(Comp, key, type)) {\r\n                extracted[key] = instance.ctx[key];\r\n            }\r\n        }\r\n        return extracted;\r\n    }\r\n    function isKeyOfType(Comp, key, type) {\r\n        const opts = Comp[type];\r\n        if ((isArray(opts) && opts.includes(key)) ||\r\n            (isObject(opts) && key in opts)) {\r\n            return true;\r\n        }\r\n        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n            return true;\r\n        }\r\n        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n            return true;\r\n        }\r\n    }\r\n    function genRefFlag(v) {\r\n        if (v._shallow) {\r\n            return `ShallowRef`;\r\n        }\r\n        if (v.effect) {\r\n            return `ComputedRef`;\r\n        }\r\n        return `Ref`;\r\n    }\r\n    if (window.devtoolsFormatters) {\r\n        window.devtoolsFormatters.push(formatter);\r\n    }\r\n    else {\r\n        window.devtoolsFormatters = [formatter];\r\n    }\r\n}\n\nconst svgNS = 'http://www.w3.org/2000/svg';\r\nconst doc = (typeof document !== 'undefined' ? document : null);\r\nlet tempContainer;\r\nlet tempSVGContainer;\r\nconst nodeOps = {\r\n    insert: (child, parent, anchor) => {\r\n        parent.insertBefore(child, anchor || null);\r\n    },\r\n    remove: child => {\r\n        const parent = child.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(child);\r\n        }\r\n    },\r\n    createElement: (tag, isSVG, is) => isSVG\r\n        ? doc.createElementNS(svgNS, tag)\r\n        : doc.createElement(tag, is ? { is } : undefined),\r\n    createText: text => doc.createTextNode(text),\r\n    createComment: text => doc.createComment(text),\r\n    setText: (node, text) => {\r\n        node.nodeValue = text;\r\n    },\r\n    setElementText: (el, text) => {\r\n        el.textContent = text;\r\n    },\r\n    parentNode: node => node.parentNode,\r\n    nextSibling: node => node.nextSibling,\r\n    querySelector: selector => doc.querySelector(selector),\r\n    setScopeId(el, id) {\r\n        el.setAttribute(id, '');\r\n    },\r\n    cloneNode(el) {\r\n        return el.cloneNode(true);\r\n    },\r\n    // __UNSAFE__\r\n    // Reason: innerHTML.\r\n    // Static content here can only come from compiled templates.\r\n    // As long as the user only uses trusted templates, this is safe.\r\n    insertStaticContent(content, parent, anchor, isSVG) {\r\n        const temp = isSVG\r\n            ? tempSVGContainer ||\r\n                (tempSVGContainer = doc.createElementNS(svgNS, 'svg'))\r\n            : tempContainer || (tempContainer = doc.createElement('div'));\r\n        temp.innerHTML = content;\r\n        const first = temp.firstChild;\r\n        let node = first;\r\n        let last = node;\r\n        while (node) {\r\n            last = node;\r\n            nodeOps.insert(node, parent, anchor);\r\n            node = temp.firstChild;\r\n        }\r\n        return [first, last];\r\n    }\r\n};\n\n// compiler should normalize class + :class bindings on the same element\r\n// into a single binding ['staticClass', dynamic]\r\nfunction patchClass(el, value, isSVG) {\r\n    if (value == null) {\r\n        value = '';\r\n    }\r\n    if (isSVG) {\r\n        el.setAttribute('class', value);\r\n    }\r\n    else {\r\n        // directly setting className should be faster than setAttribute in theory\r\n        // if this is an element during a transition, take the temporary transition\r\n        // classes into account.\r\n        const transitionClasses = el._vtc;\r\n        if (transitionClasses) {\r\n            value = (value\r\n                ? [value, ...transitionClasses]\r\n                : [...transitionClasses]).join(' ');\r\n        }\r\n        el.className = value;\r\n    }\r\n}\n\nfunction patchStyle(el, prev, next) {\r\n    const style = el.style;\r\n    if (!next) {\r\n        el.removeAttribute('style');\r\n    }\r\n    else if (isString(next)) {\r\n        if (prev !== next) {\r\n            style.cssText = next;\r\n        }\r\n    }\r\n    else {\r\n        for (const key in next) {\r\n            setStyle(style, key, next[key]);\r\n        }\r\n        if (prev && !isString(prev)) {\r\n            for (const key in prev) {\r\n                if (next[key] == null) {\r\n                    setStyle(style, key, '');\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nconst importantRE = /\\s*!important$/;\r\nfunction setStyle(style, name, val) {\r\n    if (isArray(val)) {\r\n        val.forEach(v => setStyle(style, name, v));\r\n    }\r\n    else {\r\n        if (name.startsWith('--')) {\r\n            // custom property definition\r\n            style.setProperty(name, val);\r\n        }\r\n        else {\r\n            const prefixed = autoPrefix(style, name);\r\n            if (importantRE.test(val)) {\r\n                // !important\r\n                style.setProperty(hyphenate(prefixed), val.replace(importantRE, ''), 'important');\r\n            }\r\n            else {\r\n                style[prefixed] = val;\r\n            }\r\n        }\r\n    }\r\n}\r\nconst prefixes = ['Webkit', 'Moz', 'ms'];\r\nconst prefixCache = {};\r\nfunction autoPrefix(style, rawName) {\r\n    const cached = prefixCache[rawName];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    let name = camelize(rawName);\r\n    if (name !== 'filter' && name in style) {\r\n        return (prefixCache[rawName] = name);\r\n    }\r\n    name = capitalize(name);\r\n    for (let i = 0; i < prefixes.length; i++) {\r\n        const prefixed = prefixes[i] + name;\r\n        if (prefixed in style) {\r\n            return (prefixCache[rawName] = prefixed);\r\n        }\r\n    }\r\n    return rawName;\r\n}\n\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\r\nfunction patchAttr(el, key, value, isSVG) {\r\n    if (isSVG && key.startsWith('xlink:')) {\r\n        if (value == null) {\r\n            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\r\n        }\r\n        else {\r\n            el.setAttributeNS(xlinkNS, key, value);\r\n        }\r\n    }\r\n    else {\r\n        // note we are only checking boolean attributes that don't have a\r\n        // corresponding dom prop of the same name here.\r\n        const isBoolean = isSpecialBooleanAttr(key);\r\n        if (value == null || (isBoolean && value === false)) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            el.setAttribute(key, isBoolean ? '' : value);\r\n        }\r\n    }\r\n}\n\n// __UNSAFE__\r\n// functions. The user is responsible for using them with only trusted content.\r\nfunction patchDOMProp(el, key, value, \r\n// the following args are passed only due to potential innerHTML/textContent\r\n// overriding existing VNodes, in which case the old tree must be properly\r\n// unmounted.\r\nprevChildren, parentComponent, parentSuspense, unmountChildren) {\r\n    if (key === 'innerHTML' || key === 'textContent') {\r\n        if (prevChildren) {\r\n            unmountChildren(prevChildren, parentComponent, parentSuspense);\r\n        }\r\n        el[key] = value == null ? '' : value;\r\n        return;\r\n    }\r\n    if (key === 'value' && el.tagName !== 'PROGRESS') {\r\n        // store value as _value as well since\r\n        // non-string values will be stringified.\r\n        el._value = value;\r\n        const newValue = value == null ? '' : value;\r\n        if (el.value !== newValue) {\r\n            el.value = newValue;\r\n        }\r\n        return;\r\n    }\r\n    if (value === '' || value == null) {\r\n        const type = typeof el[key];\r\n        if (value === '' && type === 'boolean') {\r\n            // e.g. <select multiple> compiles to { multiple: '' }\r\n            el[key] = true;\r\n            return;\r\n        }\r\n        else if (value == null && type === 'string') {\r\n            // e.g. <div :id=\"null\">\r\n            el[key] = '';\r\n            el.removeAttribute(key);\r\n            return;\r\n        }\r\n        else if (type === 'number') {\r\n            // e.g. <img :width=\"null\">\r\n            el[key] = 0;\r\n            el.removeAttribute(key);\r\n            return;\r\n        }\r\n    }\r\n    // some properties perform value validation and throw\r\n    try {\r\n        el[key] = value;\r\n    }\r\n    catch (e) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`Failed setting prop \"${key}\" on <${el.tagName.toLowerCase()}>: ` +\r\n                `value ${value} is invalid.`, e);\r\n        }\r\n    }\r\n}\n\n// Async edge case fix requires storing an event listener's attach timestamp.\r\nlet _getNow = Date.now;\r\n// Determine what event timestamp the browser is using. Annoyingly, the\r\n// timestamp can either be hi-res (relative to page load) or low-res\r\n// (relative to UNIX epoch), so in order to compare time we have to use the\r\n// same timestamp type when saving the flush timestamp.\r\nif (typeof document !== 'undefined' &&\r\n    _getNow() > document.createEvent('Event').timeStamp) {\r\n    // if the low-res timestamp which is bigger than the event timestamp\r\n    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\r\n    // and we need to use the hi-res version for event listeners as well.\r\n    _getNow = () => performance.now();\r\n}\r\n// To avoid the overhead of repeatedly calling performance.now(), we cache\r\n// and use the same timestamp for all event listeners attached in the same tick.\r\nlet cachedNow = 0;\r\nconst p = Promise.resolve();\r\nconst reset = () => {\r\n    cachedNow = 0;\r\n};\r\nconst getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));\r\nfunction addEventListener(el, event, handler, options) {\r\n    el.addEventListener(event, handler, options);\r\n}\r\nfunction removeEventListener(el, event, handler, options) {\r\n    el.removeEventListener(event, handler, options);\r\n}\r\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\r\n    // vei = vue event invokers\r\n    const invokers = el._vei || (el._vei = {});\r\n    const existingInvoker = invokers[rawName];\r\n    if (nextValue && existingInvoker) {\r\n        // patch\r\n        existingInvoker.value = nextValue;\r\n    }\r\n    else {\r\n        const [name, options] = parseName(rawName);\r\n        if (nextValue) {\r\n            // add\r\n            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));\r\n            addEventListener(el, name, invoker, options);\r\n        }\r\n        else if (existingInvoker) {\r\n            // remove\r\n            removeEventListener(el, name, existingInvoker, options);\r\n            invokers[rawName] = undefined;\r\n        }\r\n    }\r\n}\r\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\r\nfunction parseName(name) {\r\n    let options;\r\n    if (optionsModifierRE.test(name)) {\r\n        options = {};\r\n        let m;\r\n        while ((m = name.match(optionsModifierRE))) {\r\n            name = name.slice(0, name.length - m[0].length);\r\n            options[m[0].toLowerCase()] = true;\r\n        }\r\n    }\r\n    return [name.slice(2).toLowerCase(), options];\r\n}\r\nfunction createInvoker(initialValue, instance) {\r\n    const invoker = (e) => {\r\n        // async edge case #6566: inner click event triggers patch, event handler\r\n        // attached to outer element during patch, and triggered again. This\r\n        // happens because browsers fire microtask ticks between event propagation.\r\n        // the solution is simple: we save the timestamp when a handler is attached,\r\n        // and the handler would only fire if the event passed to it was fired\r\n        // AFTER it was attached.\r\n        const timeStamp = e.timeStamp || _getNow();\r\n        if (timeStamp >= invoker.attached - 1) {\r\n            callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);\r\n        }\r\n    };\r\n    invoker.value = initialValue;\r\n    invoker.attached = getNow();\r\n    return invoker;\r\n}\r\nfunction patchStopImmediatePropagation(e, value) {\r\n    if (isArray(value)) {\r\n        const originalStop = e.stopImmediatePropagation;\r\n        e.stopImmediatePropagation = () => {\r\n            originalStop.call(e);\r\n            e._stopped = true;\r\n        };\r\n        return value.map(fn => (e) => !e._stopped && fn(e));\r\n    }\r\n    else {\r\n        return value;\r\n    }\r\n}\n\nconst nativeOnRE = /^on[a-z]/;\r\nconst forcePatchProp = (_, key) => key === 'value';\r\nconst patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\r\n    switch (key) {\r\n        // special\r\n        case 'class':\r\n            patchClass(el, nextValue, isSVG);\r\n            break;\r\n        case 'style':\r\n            patchStyle(el, prevValue, nextValue);\r\n            break;\r\n        default:\r\n            if (isOn(key)) {\r\n                // ignore v-model listeners\r\n                if (!isModelListener(key)) {\r\n                    patchEvent(el, key, prevValue, nextValue, parentComponent);\r\n                }\r\n            }\r\n            else if (shouldSetAsProp(el, key, nextValue, isSVG)) {\r\n                patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\r\n            }\r\n            else {\r\n                // special case for <input v-model type=\"checkbox\"> with\r\n                // :true-value & :false-value\r\n                // store value as dom properties since non-string values will be\r\n                // stringified.\r\n                if (key === 'true-value') {\r\n                    el._trueValue = nextValue;\r\n                }\r\n                else if (key === 'false-value') {\r\n                    el._falseValue = nextValue;\r\n                }\r\n                patchAttr(el, key, nextValue, isSVG);\r\n            }\r\n            break;\r\n    }\r\n};\r\nfunction shouldSetAsProp(el, key, value, isSVG) {\r\n    if (isSVG) {\r\n        // most keys must be set as attribute on svg elements to work\r\n        // ...except innerHTML\r\n        if (key === 'innerHTML') {\r\n            return true;\r\n        }\r\n        // or native onclick with function values\r\n        if (key in el && nativeOnRE.test(key) && isFunction(value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // spellcheck and draggable are numerated attrs, however their\r\n    // corresponding DOM properties are actually booleans - this leads to\r\n    // setting it with a string \"false\" value leading it to be coerced to\r\n    // `true`, so we need to always treat them as attributes.\r\n    // Note that `contentEditable` doesn't have this problem: its DOM\r\n    // property is also enumerated string values.\r\n    if (key === 'spellcheck' || key === 'draggable') {\r\n        return false;\r\n    }\r\n    // #1787 form as an attribute must be a string, while it accepts an Element as\r\n    // a prop\r\n    if (key === 'form' && typeof value === 'string') {\r\n        return false;\r\n    }\r\n    // #1526 <input list> must be set as attribute\r\n    if (key === 'list' && el.tagName === 'INPUT') {\r\n        return false;\r\n    }\r\n    // native onclick with string value, must be set as attribute\r\n    if (nativeOnRE.test(key) && isString(value)) {\r\n        return false;\r\n    }\r\n    return key in el;\r\n}\n\nconst rendererOptions = extend({ patchProp, forcePatchProp }, nodeOps);\n\nfunction initDev() {\r\n    const target = getGlobalThis();\r\n    target.__VUE__ = true;\r\n    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);\r\n    {\r\n        initCustomFormatter();\r\n    }\r\n}\n\n// This entry exports the runtime only, and is built as\r\n(process.env.NODE_ENV !== 'production') && initDev();\n\nfunction processOptions(value) {\n  var options;\n\n  if (typeof value === 'function') {\n    // Simple options (callback-only)\n    options = {\n      callback: value\n    };\n  } else {\n    // Options object\n    options = value;\n  }\n\n  return options;\n}\nfunction throttle(callback, delay) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout;\n  var lastState;\n  var currentArgs;\n\n  var throttled = function throttled(state) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    currentArgs = args;\n    if (timeout && state === lastState) return;\n    var leading = options.leading;\n\n    if (typeof leading === 'function') {\n      leading = leading(state, lastState);\n    }\n\n    if ((!timeout || state !== lastState) && leading) {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n    }\n\n    lastState = state;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n      timeout = 0;\n    }, delay);\n  };\n\n  throttled._clear = function () {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return throttled;\n}\nfunction deepEqual(val1, val2) {\n  if (val1 === val2) return true;\n\n  if (_typeof(val1) === 'object') {\n    for (var key in val1) {\n      if (!deepEqual(val1[key], val2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar VisibilityState =\n/*#__PURE__*/\nfunction () {\n  function VisibilityState(el, options, vnode) {\n    _classCallCheck(this, VisibilityState);\n\n    this.el = el;\n    this.observer = null;\n    this.frozen = false;\n    this.createObserver(options, vnode);\n  }\n\n  _createClass(VisibilityState, [{\n    key: \"createObserver\",\n    value: function createObserver(options, vnode) {\n      var _this = this;\n\n      if (this.observer) {\n        this.destroyObserver();\n      }\n\n      if (this.frozen) return;\n      this.options = processOptions(options);\n\n      this.callback = function (result, entry) {\n        _this.options.callback(result, entry);\n\n        if (result && _this.options.once) {\n          _this.frozen = true;\n\n          _this.destroyObserver();\n        }\n      }; // Throttle\n\n\n      if (this.callback && this.options.throttle) {\n        var _ref = this.options.throttleOptions || {},\n            _leading = _ref.leading;\n\n        this.callback = throttle(this.callback, this.options.throttle, {\n          leading: function leading(state) {\n            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;\n          }\n        });\n      }\n\n      this.oldResult = undefined;\n      this.observer = new IntersectionObserver(function (entries) {\n        var entry = entries[0];\n\n        if (entries.length > 1) {\n          var intersectingEntry = entries.find(function (e) {\n            return e.isIntersecting;\n          });\n\n          if (intersectingEntry) {\n            entry = intersectingEntry;\n          }\n        }\n\n        if (_this.callback) {\n          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.\n          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;\n          if (result === _this.oldResult) return;\n          _this.oldResult = result;\n\n          _this.callback(result, entry);\n        }\n      }, this.options.intersection); // Wait for the element to be in document\n\n      nextTick(function () {\n        if (_this.observer) {\n          _this.observer.observe(_this.el);\n        }\n      });\n    }\n  }, {\n    key: \"destroyObserver\",\n    value: function destroyObserver() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      } // Cancel throttled call\n\n\n      if (this.callback && this.callback._clear) {\n        this.callback._clear();\n\n        this.callback = null;\n      }\n    }\n  }, {\n    key: \"threshold\",\n    get: function get() {\n      return this.options.intersection && this.options.intersection.threshold || 0;\n    }\n  }]);\n\n  return VisibilityState;\n}();\n\nfunction bind(el, _ref2, vnode) {\n  var value = _ref2.value;\n  if (!value) return;\n\n  if (typeof IntersectionObserver === 'undefined') {\n    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');\n  } else {\n    var state = new VisibilityState(el, value, vnode);\n    el._vue_visibilityState = state;\n  }\n}\n\nfunction update(el, _ref3, vnode) {\n  var value = _ref3.value,\n      oldValue = _ref3.oldValue;\n  if (deepEqual(value, oldValue)) return;\n  var state = el._vue_visibilityState;\n\n  if (!value) {\n    unbind(el);\n    return;\n  }\n\n  if (state) {\n    state.createObserver(value, vnode);\n  } else {\n    bind(el, {\n      value: value\n    }, vnode);\n  }\n}\n\nfunction unbind(el) {\n  var state = el._vue_visibilityState;\n\n  if (state) {\n    state.destroyObserver();\n    delete el._vue_visibilityState;\n  }\n}\n\nvar ObserveVisibility = {\n  beforeMount: bind,\n  updated: update,\n  unmounted: unbind\n};\n\nfunction install(Vue) {\n  Vue.directive('observe-visibility', ObserveVisibility);\n  /* -- Add more components here -- */\n}\n/* -- Plugin definition & Auto-install -- */\n\n/* You shouldn't have to modify the code below */\n// Plugin\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"0.9.0-ropez.1\",\n  install: install\n};\n\nvar GlobalVue = null;\n\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue;\n}\n\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n\nexport default plugin;\nexport { ObserveVisibility, install };\n","(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    root.Scrollparent = factory();\n  }\n}(this, function () {\n  var regex = /(auto|scroll)/;\n\n  var parents = function (node, ps) {\n    if (node.parentNode === null) { return ps; }\n\n    return parents(node.parentNode, ps.concat([node]));\n  };\n\n  var style = function (node, prop) {\n    return getComputedStyle(node, null).getPropertyValue(prop);\n  };\n\n  var overflow = function (node) {\n    return style(node, \"overflow\") + style(node, \"overflow-y\") + style(node, \"overflow-x\");\n  };\n\n  var scroll = function (node) {\n   return regex.test(overflow(node));\n  };\n\n  var scrollParent = function (node) {\n    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n      return ;\n    }\n\n    var ps = parents(node.parentNode, []);\n\n    for (var i = 0; i < ps.length; i += 1) {\n      if (scroll(ps[i])) {\n        return ps[i];\n      }\n    }\n\n    return document.scrollingElement || document.documentElement;\n  };\n\n  return scrollParent;\n}));\n","export const props = {\r\n  items: {\r\n    type: Array,\r\n    required: true,\r\n  },\r\n\r\n  keyField: {\r\n    type: String,\r\n    default: 'id',\r\n  },\r\n\r\n  direction: {\r\n    type: String,\r\n    default: 'vertical',\r\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\r\n  },\r\n}\r\n\r\nexport function simpleArray () {\r\n  return this.items.length && typeof this.items[0] !== 'object'\r\n}\r\n","export let supportsPassive = false\r\n\r\nif (typeof window !== 'undefined') {\r\n  supportsPassive = false\r\n  try {\r\n    var opts = Object.defineProperty({}, 'passive', {\r\n      get () {\r\n        supportsPassive = true\r\n      },\r\n    })\r\n    window.addEventListener('test', null, opts)\r\n  } catch (e) {}\r\n}\r\n","<template>\r\n  <div\r\n    v-observe-visibility=\"handleVisibilityChange\"\r\n    class=\"vue-recycle-scroller\"\r\n    :class=\"{\r\n      ready,\r\n      'page-mode': pageMode,\r\n      [`direction-${direction}`]: true,\r\n    }\"\r\n    @scroll.passive=\"handleScroll\"\r\n  >\r\n    <div\r\n      v-if=\"$slots.before\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"before\"\r\n      />\r\n    </div>\r\n\r\n    <div\r\n      ref=\"wrapper\"\r\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\r\n      class=\"vue-recycle-scroller__item-wrapper\"\r\n    >\r\n      <div\r\n        v-for=\"view of pool\"\r\n        :key=\"view.nr.id\"\r\n        :style=\"ready ? { transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px)` } : null\"\r\n        class=\"vue-recycle-scroller__item-view\"\r\n        :class=\"{ hover: hoverKey === view.nr.key }\"\r\n        @mouseenter=\"hoverKey = view.nr.key\"\r\n        @mouseleave=\"hoverKey = null\"\r\n      >\r\n        <slot\r\n          :item=\"view.item\"\r\n          :index=\"view.nr.index\"\r\n          :active=\"view.nr.used\"\r\n        />\r\n      </div>\r\n    </div>\r\n\r\n    <div\r\n      v-if=\"$slots.after\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"after\"\r\n      />\r\n    </div>\r\n\r\n    <ResizeObserver @notify=\"handleResize\" />\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { shallowReactive } from 'vue'\r\nimport { ResizeObserver } from 'vue-resize'\r\nimport { ObserveVisibility } from 'vue-observe-visibility'\r\nimport ScrollParent from 'scrollparent'\r\nimport config from '../config'\r\nimport { props, simpleArray } from './common'\r\nimport { supportsPassive } from '../utils'\r\n\r\nlet uid = 0\r\n\r\nexport default {\r\n  name: 'RecycleScroller',\r\n\r\n  components: {\r\n    ResizeObserver,\r\n  },\r\n\r\n  directives: {\r\n    ObserveVisibility,\r\n  },\r\n\r\n  emits: [\r\n    'update',\r\n    'resize',\r\n    'visible',\r\n    'hidden',\r\n  ],\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    itemSize: {\r\n      type: Number,\r\n      default: null,\r\n    },\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      default: null,\r\n    },\r\n\r\n    sizeField: {\r\n      type: String,\r\n      default: 'size',\r\n    },\r\n\r\n    typeField: {\r\n      type: String,\r\n      default: 'type',\r\n    },\r\n\r\n    buffer: {\r\n      type: Number,\r\n      default: 200,\r\n    },\r\n\r\n    pageMode: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    prerender: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n\r\n    emitUpdate: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n  },\r\n\r\n  data () {\r\n    return {\r\n      pool: [],\r\n      totalSize: 0,\r\n      ready: false,\r\n      hoverKey: null,\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    sizes () {\r\n      if (this.itemSize === null) {\r\n        const sizes = {\r\n          '-1': { accumulator: 0 },\r\n        }\r\n        const items = this.items\r\n        const field = this.sizeField\r\n        const minItemSize = this.minItemSize\r\n        let computedMinSize = 10000\r\n        let accumulator = 0\r\n        let current\r\n        for (let i = 0, l = items.length; i < l; i++) {\r\n          current = items[i][field] || minItemSize\r\n          if (current < computedMinSize) {\r\n            computedMinSize = current\r\n          }\r\n          accumulator += current\r\n          sizes[i] = { accumulator, size: current }\r\n        }\r\n        // eslint-disable-next-line\r\n        this.$_computedMinItemSize = computedMinSize\r\n        return sizes\r\n      }\r\n      return []\r\n    },\r\n\r\n    simpleArray,\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.updateVisibleItems(true)\r\n    },\r\n\r\n    pageMode () {\r\n      this.applyPageMode()\r\n      this.updateVisibleItems(false)\r\n    },\r\n\r\n    sizes: {\r\n      handler () {\r\n        this.updateVisibleItems(false)\r\n      },\r\n      deep: true,\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_startIndex = 0\r\n    this.$_endIndex = 0\r\n    this.$_views = new Map()\r\n    this.$_unusedViews = new Map()\r\n    this.$_scrollDirty = false\r\n    this.$_lastUpdateScrollPosition = 0\r\n\r\n    // In SSR mode, we also prerender the same number of item for the first render\r\n    // to avoir mismatch between server and client templates\r\n    if (this.prerender) {\r\n      this.$_prerender = true\r\n      this.updateVisibleItems(false)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    this.applyPageMode()\r\n    this.$nextTick(() => {\r\n      // In SSR mode, render the real number of visible items\r\n      this.$_prerender = false\r\n      this.updateVisibleItems(true)\r\n      this.ready = true\r\n    })\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.removeListeners()\r\n  },\r\n\r\n  methods: {\r\n    addView (pool, index, item, key, type) {\r\n      const view = shallowReactive({\r\n        item,\r\n        position: 0,\r\n        nr: {\r\n          id: uid++,\r\n          index,\r\n          used: true,\r\n          key,\r\n          type,\r\n        },\r\n      })\r\n      pool.push(view)\r\n      return view\r\n    },\r\n\r\n    unuseView (view, fake = false) {\r\n      const unusedViews = this.$_unusedViews\r\n      const type = view.nr.type\r\n      let unusedPool = unusedViews.get(type)\r\n      if (!unusedPool) {\r\n        unusedPool = []\r\n        unusedViews.set(type, unusedPool)\r\n      }\r\n      unusedPool.push(view)\r\n      if (!fake) {\r\n        view.nr.used = false\r\n        view.position = -9999\r\n        this.$_views.delete(view.nr.key)\r\n      }\r\n    },\r\n\r\n    handleResize () {\r\n      this.$emit('resize')\r\n      if (this.ready) this.updateVisibleItems(false)\r\n    },\r\n\r\n    handleScroll (event) {\r\n      if (!this.$_scrollDirty) {\r\n        this.$_scrollDirty = true\r\n        requestAnimationFrame(() => {\r\n          this.$_scrollDirty = false\r\n          const { continuous } = this.updateVisibleItems(false, true)\r\n\r\n          // It seems sometimes chrome doesn't fire scroll event :/\r\n          // When non continous scrolling is ending, we force a refresh\r\n          if (!continuous) {\r\n            clearTimeout(this.$_refreshTimout)\r\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\r\n          }\r\n        })\r\n      }\r\n    },\r\n\r\n    handleVisibilityChange (isVisible, entry) {\r\n      if (this.ready) {\r\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\r\n          this.$emit('visible')\r\n          requestAnimationFrame(() => {\r\n            this.updateVisibleItems(false)\r\n          })\r\n        } else {\r\n          this.$emit('hidden')\r\n        }\r\n      }\r\n    },\r\n\r\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\r\n      const itemSize = this.itemSize\r\n      const minItemSize = this.$_computedMinItemSize\r\n      const typeField = this.typeField\r\n      const keyField = this.simpleArray ? null : this.keyField\r\n      const items = this.items\r\n      const count = items.length\r\n      const sizes = this.sizes\r\n      const views = this.$_views\r\n      const unusedViews = this.$_unusedViews\r\n      const pool = this.pool\r\n      let startIndex, endIndex\r\n      let totalSize\r\n\r\n      if (!count) {\r\n        startIndex = endIndex = totalSize = 0\r\n      } else if (this.$_prerender) {\r\n        startIndex = 0\r\n        endIndex = this.prerender\r\n        totalSize = null\r\n      } else {\r\n        const scroll = this.getScroll()\r\n\r\n        // Skip update if use hasn't scrolled enough\r\n        if (checkPositionDiff) {\r\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\r\n          if (positionDiff < 0) positionDiff = -positionDiff\r\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\r\n            return {\r\n              continuous: true,\r\n            }\r\n          }\r\n        }\r\n        this.$_lastUpdateScrollPosition = scroll.start\r\n\r\n        const buffer = this.buffer\r\n        scroll.start -= buffer\r\n        scroll.end += buffer\r\n\r\n        // Variable size mode\r\n        if (itemSize === null) {\r\n          let h\r\n          let a = 0\r\n          let b = count - 1\r\n          let i = ~~(count / 2)\r\n          let oldI\r\n\r\n          // Searching for startIndex\r\n          do {\r\n            oldI = i\r\n            h = sizes[i].accumulator\r\n            if (h < scroll.start) {\r\n              a = i\r\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\r\n              b = i\r\n            }\r\n            i = ~~((a + b) / 2)\r\n          } while (i !== oldI)\r\n          i < 0 && (i = 0)\r\n          startIndex = i\r\n\r\n          // For container style\r\n          totalSize = sizes[count - 1].accumulator\r\n\r\n          // Searching for endIndex\r\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\r\n          if (endIndex === -1) {\r\n            endIndex = items.length - 1\r\n          } else {\r\n            endIndex++\r\n            // Bounds\r\n            endIndex > count && (endIndex = count)\r\n          }\r\n        } else {\r\n          // Fixed size mode\r\n          startIndex = ~~(scroll.start / itemSize)\r\n          endIndex = Math.ceil(scroll.end / itemSize)\r\n\r\n          // Bounds\r\n          startIndex < 0 && (startIndex = 0)\r\n          endIndex > count && (endIndex = count)\r\n\r\n          totalSize = count * itemSize\r\n        }\r\n      }\r\n\r\n      if (endIndex - startIndex > config.itemsLimit) {\r\n        this.itemsLimitError()\r\n      }\r\n\r\n      this.totalSize = totalSize\r\n\r\n      let view\r\n\r\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\r\n\r\n      if (this.$_continuous !== continuous) {\r\n        if (continuous) {\r\n          views.clear()\r\n          unusedViews.clear()\r\n          for (let i = 0, l = pool.length; i < l; i++) {\r\n            view = pool[i]\r\n            this.unuseView(view)\r\n          }\r\n        }\r\n        this.$_continuous = continuous\r\n      } else if (continuous) {\r\n        for (let i = 0, l = pool.length; i < l; i++) {\r\n          view = pool[i]\r\n          if (view.nr.used) {\r\n            // Update view item index\r\n            if (checkItem) {\r\n              view.nr.index = items.findIndex(\r\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item,\r\n              )\r\n            }\r\n\r\n            // Check if index is still in visible range\r\n            if (\r\n              view.nr.index === -1 ||\r\n              view.nr.index < startIndex ||\r\n              view.nr.index >= endIndex\r\n            ) {\r\n              this.unuseView(view)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const unusedIndex = continuous ? null : new Map()\r\n\r\n      let item, type, unusedPool\r\n      let v\r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        item = items[i]\r\n        const key = keyField ? item[keyField] : item\r\n        if (key == null) {\r\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\r\n        }\r\n        view = views.get(key)\r\n\r\n        if (!itemSize && !sizes[i].size) {\r\n          if (view) this.unuseView(view)\r\n          continue\r\n        }\r\n\r\n        // No view assigned to item\r\n        if (!view) {\r\n          type = item[typeField]\r\n          unusedPool = unusedViews.get(type)\r\n\r\n          if (continuous) {\r\n            // Reuse existing view\r\n            if (unusedPool && unusedPool.length) {\r\n              view = unusedPool.pop()\r\n              view.item = item\r\n              view.nr.used = true\r\n              view.nr.index = i\r\n              view.nr.key = key\r\n              view.nr.type = type\r\n            } else {\r\n              view = this.addView(pool, i, item, key, type)\r\n            }\r\n          } else {\r\n            // Use existing view\r\n            // We don't care if they are already used\r\n            // because we are not in continous scrolling\r\n            v = unusedIndex.get(type) || 0\r\n\r\n            if (!unusedPool || v >= unusedPool.length) {\r\n              view = this.addView(pool, i, item, key, type)\r\n              this.unuseView(view, true)\r\n              unusedPool = unusedViews.get(type)\r\n            }\r\n\r\n            view = unusedPool[v]\r\n            view.item = item\r\n            view.nr.used = true\r\n            view.nr.index = i\r\n            view.nr.key = key\r\n            view.nr.type = type\r\n            unusedIndex.set(type, v + 1)\r\n            v++\r\n          }\r\n          views.set(key, view)\r\n        } else {\r\n          view.nr.used = true\r\n          view.item = item\r\n        }\r\n\r\n        // Update position\r\n        if (itemSize === null) {\r\n          view.position = sizes[i - 1].accumulator\r\n        } else {\r\n          view.position = i * itemSize\r\n        }\r\n      }\r\n\r\n      this.$_startIndex = startIndex\r\n      this.$_endIndex = endIndex\r\n\r\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex)\r\n\r\n      // After the user has finished scrolling\r\n      // Sort views so text selection is correct\r\n      clearTimeout(this.$_sortTimer)\r\n      this.$_sortTimer = setTimeout(this.sortViews, 300)\r\n\r\n      return {\r\n        continuous,\r\n      }\r\n    },\r\n\r\n    getListenerTarget () {\r\n      let target = ScrollParent(this.$el)\r\n      // Fix global scroll target for Chrome and Safari\r\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\r\n        target = window\r\n      }\r\n      return target\r\n    },\r\n\r\n    getScroll () {\r\n      const { $el: el, direction } = this\r\n      const isVertical = direction === 'vertical'\r\n      let scrollState\r\n\r\n      if (this.pageMode) {\r\n        const bounds = el.getBoundingClientRect()\r\n        const boundsSize = isVertical ? bounds.height : bounds.width\r\n        let start = -(isVertical ? bounds.top : bounds.left)\r\n        let size = isVertical ? window.innerHeight : window.innerWidth\r\n        if (start < 0) {\r\n          size += start\r\n          start = 0\r\n        }\r\n        if (start + size > boundsSize) {\r\n          size = boundsSize - start\r\n        }\r\n        scrollState = {\r\n          start,\r\n          end: start + size,\r\n        }\r\n      } else if (isVertical) {\r\n        scrollState = {\r\n          start: el.scrollTop,\r\n          end: el.scrollTop + el.clientHeight,\r\n        }\r\n      } else {\r\n        scrollState = {\r\n          start: el.scrollLeft,\r\n          end: el.scrollLeft + el.clientWidth,\r\n        }\r\n      }\r\n\r\n      return scrollState\r\n    },\r\n\r\n    applyPageMode () {\r\n      if (this.pageMode) {\r\n        this.addListeners()\r\n      } else {\r\n        this.removeListeners()\r\n      }\r\n    },\r\n\r\n    addListeners () {\r\n      this.listenerTarget = this.getListenerTarget()\r\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {\r\n        passive: true,\r\n      } : false)\r\n      this.listenerTarget.addEventListener('resize', this.handleResize)\r\n    },\r\n\r\n    removeListeners () {\r\n      if (!this.listenerTarget) {\r\n        return\r\n      }\r\n\r\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\r\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\r\n\r\n      this.listenerTarget = null\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      let scroll\r\n      if (this.itemSize === null) {\r\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\r\n      } else {\r\n        scroll = index * this.itemSize\r\n      }\r\n      this.scrollToPosition(scroll)\r\n    },\r\n\r\n    scrollToPosition (position) {\r\n      if (this.direction === 'vertical') {\r\n        this.$el.scrollTop = position\r\n      } else {\r\n        this.$el.scrollLeft = position\r\n      }\r\n    },\r\n\r\n    itemsLimitError () {\r\n      setTimeout(() => {\r\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\r\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\r\n      })\r\n      throw new Error('Rendered items limit reached')\r\n    },\r\n\r\n    sortViews () {\r\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style>\r\n.vue-recycle-scroller {\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\r\n  overflow-y: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\r\n  overflow-x: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal {\r\n  display: flex;\r\n}\r\n\r\n.vue-recycle-scroller__slot {\r\n  flex: auto 0 0;\r\n}\r\n\r\n.vue-recycle-scroller__item-wrapper {\r\n  flex: 1;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  will-change: transform;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\r\n  height: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\r\n  height: 100%;\r\n}\r\n</style>\r\n","<template>\r\n  <div\r\n    v-observe-visibility=\"handleVisibilityChange\"\r\n    class=\"vue-recycle-scroller\"\r\n    :class=\"{\r\n      ready,\r\n      'page-mode': pageMode,\r\n      [`direction-${direction}`]: true,\r\n    }\"\r\n    @scroll.passive=\"handleScroll\"\r\n  >\r\n    <div\r\n      v-if=\"$slots.before\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"before\"\r\n      />\r\n    </div>\r\n\r\n    <div\r\n      ref=\"wrapper\"\r\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\r\n      class=\"vue-recycle-scroller__item-wrapper\"\r\n    >\r\n      <div\r\n        v-for=\"view of pool\"\r\n        :key=\"view.nr.id\"\r\n        :style=\"ready ? { transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px)` } : null\"\r\n        class=\"vue-recycle-scroller__item-view\"\r\n        :class=\"{ hover: hoverKey === view.nr.key }\"\r\n        @mouseenter=\"hoverKey = view.nr.key\"\r\n        @mouseleave=\"hoverKey = null\"\r\n      >\r\n        <slot\r\n          :item=\"view.item\"\r\n          :index=\"view.nr.index\"\r\n          :active=\"view.nr.used\"\r\n        />\r\n      </div>\r\n    </div>\r\n\r\n    <div\r\n      v-if=\"$slots.after\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"after\"\r\n      />\r\n    </div>\r\n\r\n    <ResizeObserver @notify=\"handleResize\" />\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { shallowReactive } from 'vue'\r\nimport { ResizeObserver } from 'vue-resize'\r\nimport { ObserveVisibility } from 'vue-observe-visibility'\r\nimport ScrollParent from 'scrollparent'\r\nimport config from '../config'\r\nimport { props, simpleArray } from './common'\r\nimport { supportsPassive } from '../utils'\r\n\r\nlet uid = 0\r\n\r\nexport default {\r\n  name: 'RecycleScroller',\r\n\r\n  components: {\r\n    ResizeObserver,\r\n  },\r\n\r\n  directives: {\r\n    ObserveVisibility,\r\n  },\r\n\r\n  emits: [\r\n    'update',\r\n    'resize',\r\n    'visible',\r\n    'hidden',\r\n  ],\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    itemSize: {\r\n      type: Number,\r\n      default: null,\r\n    },\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      default: null,\r\n    },\r\n\r\n    sizeField: {\r\n      type: String,\r\n      default: 'size',\r\n    },\r\n\r\n    typeField: {\r\n      type: String,\r\n      default: 'type',\r\n    },\r\n\r\n    buffer: {\r\n      type: Number,\r\n      default: 200,\r\n    },\r\n\r\n    pageMode: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    prerender: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n\r\n    emitUpdate: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n  },\r\n\r\n  data () {\r\n    return {\r\n      pool: [],\r\n      totalSize: 0,\r\n      ready: false,\r\n      hoverKey: null,\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    sizes () {\r\n      if (this.itemSize === null) {\r\n        const sizes = {\r\n          '-1': { accumulator: 0 },\r\n        }\r\n        const items = this.items\r\n        const field = this.sizeField\r\n        const minItemSize = this.minItemSize\r\n        let computedMinSize = 10000\r\n        let accumulator = 0\r\n        let current\r\n        for (let i = 0, l = items.length; i < l; i++) {\r\n          current = items[i][field] || minItemSize\r\n          if (current < computedMinSize) {\r\n            computedMinSize = current\r\n          }\r\n          accumulator += current\r\n          sizes[i] = { accumulator, size: current }\r\n        }\r\n        // eslint-disable-next-line\r\n        this.$_computedMinItemSize = computedMinSize\r\n        return sizes\r\n      }\r\n      return []\r\n    },\r\n\r\n    simpleArray,\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.updateVisibleItems(true)\r\n    },\r\n\r\n    pageMode () {\r\n      this.applyPageMode()\r\n      this.updateVisibleItems(false)\r\n    },\r\n\r\n    sizes: {\r\n      handler () {\r\n        this.updateVisibleItems(false)\r\n      },\r\n      deep: true,\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_startIndex = 0\r\n    this.$_endIndex = 0\r\n    this.$_views = new Map()\r\n    this.$_unusedViews = new Map()\r\n    this.$_scrollDirty = false\r\n    this.$_lastUpdateScrollPosition = 0\r\n\r\n    // In SSR mode, we also prerender the same number of item for the first render\r\n    // to avoir mismatch between server and client templates\r\n    if (this.prerender) {\r\n      this.$_prerender = true\r\n      this.updateVisibleItems(false)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    this.applyPageMode()\r\n    this.$nextTick(() => {\r\n      // In SSR mode, render the real number of visible items\r\n      this.$_prerender = false\r\n      this.updateVisibleItems(true)\r\n      this.ready = true\r\n    })\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.removeListeners()\r\n  },\r\n\r\n  methods: {\r\n    addView (pool, index, item, key, type) {\r\n      const view = shallowReactive({\r\n        item,\r\n        position: 0,\r\n        nr: {\r\n          id: uid++,\r\n          index,\r\n          used: true,\r\n          key,\r\n          type,\r\n        },\r\n      })\r\n      pool.push(view)\r\n      return view\r\n    },\r\n\r\n    unuseView (view, fake = false) {\r\n      const unusedViews = this.$_unusedViews\r\n      const type = view.nr.type\r\n      let unusedPool = unusedViews.get(type)\r\n      if (!unusedPool) {\r\n        unusedPool = []\r\n        unusedViews.set(type, unusedPool)\r\n      }\r\n      unusedPool.push(view)\r\n      if (!fake) {\r\n        view.nr.used = false\r\n        view.position = -9999\r\n        this.$_views.delete(view.nr.key)\r\n      }\r\n    },\r\n\r\n    handleResize () {\r\n      this.$emit('resize')\r\n      if (this.ready) this.updateVisibleItems(false)\r\n    },\r\n\r\n    handleScroll (event) {\r\n      if (!this.$_scrollDirty) {\r\n        this.$_scrollDirty = true\r\n        requestAnimationFrame(() => {\r\n          this.$_scrollDirty = false\r\n          const { continuous } = this.updateVisibleItems(false, true)\r\n\r\n          // It seems sometimes chrome doesn't fire scroll event :/\r\n          // When non continous scrolling is ending, we force a refresh\r\n          if (!continuous) {\r\n            clearTimeout(this.$_refreshTimout)\r\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\r\n          }\r\n        })\r\n      }\r\n    },\r\n\r\n    handleVisibilityChange (isVisible, entry) {\r\n      if (this.ready) {\r\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\r\n          this.$emit('visible')\r\n          requestAnimationFrame(() => {\r\n            this.updateVisibleItems(false)\r\n          })\r\n        } else {\r\n          this.$emit('hidden')\r\n        }\r\n      }\r\n    },\r\n\r\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\r\n      const itemSize = this.itemSize\r\n      const minItemSize = this.$_computedMinItemSize\r\n      const typeField = this.typeField\r\n      const keyField = this.simpleArray ? null : this.keyField\r\n      const items = this.items\r\n      const count = items.length\r\n      const sizes = this.sizes\r\n      const views = this.$_views\r\n      const unusedViews = this.$_unusedViews\r\n      const pool = this.pool\r\n      let startIndex, endIndex\r\n      let totalSize\r\n\r\n      if (!count) {\r\n        startIndex = endIndex = totalSize = 0\r\n      } else if (this.$_prerender) {\r\n        startIndex = 0\r\n        endIndex = this.prerender\r\n        totalSize = null\r\n      } else {\r\n        const scroll = this.getScroll()\r\n\r\n        // Skip update if use hasn't scrolled enough\r\n        if (checkPositionDiff) {\r\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\r\n          if (positionDiff < 0) positionDiff = -positionDiff\r\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\r\n            return {\r\n              continuous: true,\r\n            }\r\n          }\r\n        }\r\n        this.$_lastUpdateScrollPosition = scroll.start\r\n\r\n        const buffer = this.buffer\r\n        scroll.start -= buffer\r\n        scroll.end += buffer\r\n\r\n        // Variable size mode\r\n        if (itemSize === null) {\r\n          let h\r\n          let a = 0\r\n          let b = count - 1\r\n          let i = ~~(count / 2)\r\n          let oldI\r\n\r\n          // Searching for startIndex\r\n          do {\r\n            oldI = i\r\n            h = sizes[i].accumulator\r\n            if (h < scroll.start) {\r\n              a = i\r\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\r\n              b = i\r\n            }\r\n            i = ~~((a + b) / 2)\r\n          } while (i !== oldI)\r\n          i < 0 && (i = 0)\r\n          startIndex = i\r\n\r\n          // For container style\r\n          totalSize = sizes[count - 1].accumulator\r\n\r\n          // Searching for endIndex\r\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\r\n          if (endIndex === -1) {\r\n            endIndex = items.length - 1\r\n          } else {\r\n            endIndex++\r\n            // Bounds\r\n            endIndex > count && (endIndex = count)\r\n          }\r\n        } else {\r\n          // Fixed size mode\r\n          startIndex = ~~(scroll.start / itemSize)\r\n          endIndex = Math.ceil(scroll.end / itemSize)\r\n\r\n          // Bounds\r\n          startIndex < 0 && (startIndex = 0)\r\n          endIndex > count && (endIndex = count)\r\n\r\n          totalSize = count * itemSize\r\n        }\r\n      }\r\n\r\n      if (endIndex - startIndex > config.itemsLimit) {\r\n        this.itemsLimitError()\r\n      }\r\n\r\n      this.totalSize = totalSize\r\n\r\n      let view\r\n\r\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\r\n\r\n      if (this.$_continuous !== continuous) {\r\n        if (continuous) {\r\n          views.clear()\r\n          unusedViews.clear()\r\n          for (let i = 0, l = pool.length; i < l; i++) {\r\n            view = pool[i]\r\n            this.unuseView(view)\r\n          }\r\n        }\r\n        this.$_continuous = continuous\r\n      } else if (continuous) {\r\n        for (let i = 0, l = pool.length; i < l; i++) {\r\n          view = pool[i]\r\n          if (view.nr.used) {\r\n            // Update view item index\r\n            if (checkItem) {\r\n              view.nr.index = items.findIndex(\r\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item,\r\n              )\r\n            }\r\n\r\n            // Check if index is still in visible range\r\n            if (\r\n              view.nr.index === -1 ||\r\n              view.nr.index < startIndex ||\r\n              view.nr.index >= endIndex\r\n            ) {\r\n              this.unuseView(view)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const unusedIndex = continuous ? null : new Map()\r\n\r\n      let item, type, unusedPool\r\n      let v\r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        item = items[i]\r\n        const key = keyField ? item[keyField] : item\r\n        if (key == null) {\r\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\r\n        }\r\n        view = views.get(key)\r\n\r\n        if (!itemSize && !sizes[i].size) {\r\n          if (view) this.unuseView(view)\r\n          continue\r\n        }\r\n\r\n        // No view assigned to item\r\n        if (!view) {\r\n          type = item[typeField]\r\n          unusedPool = unusedViews.get(type)\r\n\r\n          if (continuous) {\r\n            // Reuse existing view\r\n            if (unusedPool && unusedPool.length) {\r\n              view = unusedPool.pop()\r\n              view.item = item\r\n              view.nr.used = true\r\n              view.nr.index = i\r\n              view.nr.key = key\r\n              view.nr.type = type\r\n            } else {\r\n              view = this.addView(pool, i, item, key, type)\r\n            }\r\n          } else {\r\n            // Use existing view\r\n            // We don't care if they are already used\r\n            // because we are not in continous scrolling\r\n            v = unusedIndex.get(type) || 0\r\n\r\n            if (!unusedPool || v >= unusedPool.length) {\r\n              view = this.addView(pool, i, item, key, type)\r\n              this.unuseView(view, true)\r\n              unusedPool = unusedViews.get(type)\r\n            }\r\n\r\n            view = unusedPool[v]\r\n            view.item = item\r\n            view.nr.used = true\r\n            view.nr.index = i\r\n            view.nr.key = key\r\n            view.nr.type = type\r\n            unusedIndex.set(type, v + 1)\r\n            v++\r\n          }\r\n          views.set(key, view)\r\n        } else {\r\n          view.nr.used = true\r\n          view.item = item\r\n        }\r\n\r\n        // Update position\r\n        if (itemSize === null) {\r\n          view.position = sizes[i - 1].accumulator\r\n        } else {\r\n          view.position = i * itemSize\r\n        }\r\n      }\r\n\r\n      this.$_startIndex = startIndex\r\n      this.$_endIndex = endIndex\r\n\r\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex)\r\n\r\n      // After the user has finished scrolling\r\n      // Sort views so text selection is correct\r\n      clearTimeout(this.$_sortTimer)\r\n      this.$_sortTimer = setTimeout(this.sortViews, 300)\r\n\r\n      return {\r\n        continuous,\r\n      }\r\n    },\r\n\r\n    getListenerTarget () {\r\n      let target = ScrollParent(this.$el)\r\n      // Fix global scroll target for Chrome and Safari\r\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\r\n        target = window\r\n      }\r\n      return target\r\n    },\r\n\r\n    getScroll () {\r\n      const { $el: el, direction } = this\r\n      const isVertical = direction === 'vertical'\r\n      let scrollState\r\n\r\n      if (this.pageMode) {\r\n        const bounds = el.getBoundingClientRect()\r\n        const boundsSize = isVertical ? bounds.height : bounds.width\r\n        let start = -(isVertical ? bounds.top : bounds.left)\r\n        let size = isVertical ? window.innerHeight : window.innerWidth\r\n        if (start < 0) {\r\n          size += start\r\n          start = 0\r\n        }\r\n        if (start + size > boundsSize) {\r\n          size = boundsSize - start\r\n        }\r\n        scrollState = {\r\n          start,\r\n          end: start + size,\r\n        }\r\n      } else if (isVertical) {\r\n        scrollState = {\r\n          start: el.scrollTop,\r\n          end: el.scrollTop + el.clientHeight,\r\n        }\r\n      } else {\r\n        scrollState = {\r\n          start: el.scrollLeft,\r\n          end: el.scrollLeft + el.clientWidth,\r\n        }\r\n      }\r\n\r\n      return scrollState\r\n    },\r\n\r\n    applyPageMode () {\r\n      if (this.pageMode) {\r\n        this.addListeners()\r\n      } else {\r\n        this.removeListeners()\r\n      }\r\n    },\r\n\r\n    addListeners () {\r\n      this.listenerTarget = this.getListenerTarget()\r\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {\r\n        passive: true,\r\n      } : false)\r\n      this.listenerTarget.addEventListener('resize', this.handleResize)\r\n    },\r\n\r\n    removeListeners () {\r\n      if (!this.listenerTarget) {\r\n        return\r\n      }\r\n\r\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\r\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\r\n\r\n      this.listenerTarget = null\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      let scroll\r\n      if (this.itemSize === null) {\r\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\r\n      } else {\r\n        scroll = index * this.itemSize\r\n      }\r\n      this.scrollToPosition(scroll)\r\n    },\r\n\r\n    scrollToPosition (position) {\r\n      if (this.direction === 'vertical') {\r\n        this.$el.scrollTop = position\r\n      } else {\r\n        this.$el.scrollLeft = position\r\n      }\r\n    },\r\n\r\n    itemsLimitError () {\r\n      setTimeout(() => {\r\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\r\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\r\n      })\r\n      throw new Error('Rendered items limit reached')\r\n    },\r\n\r\n    sortViews () {\r\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style>\r\n.vue-recycle-scroller {\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\r\n  overflow-y: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\r\n  overflow-x: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal {\r\n  display: flex;\r\n}\r\n\r\n.vue-recycle-scroller__slot {\r\n  flex: auto 0 0;\r\n}\r\n\r\n.vue-recycle-scroller__item-wrapper {\r\n  flex: 1;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  will-change: transform;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\r\n  height: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\r\n  height: 100%;\r\n}\r\n</style>\r\n","<template>\r\n  <RecycleScroller\r\n    ref=\"scroller\"\r\n    :items=\"itemsWithSize\"\r\n    :min-item-size=\"minItemSize\"\r\n    :direction=\"direction\"\r\n    key-field=\"id\"\r\n    v-bind=\"$attrs\"\r\n    @resize=\"onScrollerResize\"\r\n    @visible=\"onScrollerVisible\"\r\n    v-on=\"listeners\"\r\n  >\r\n    <template v-slot=\"{ item: itemWithSize, index, active }\">\r\n      <slot\r\n        v-bind=\"{\r\n          item: itemWithSize.item,\r\n          index,\r\n          active,\r\n          itemWithSize\r\n        }\"\r\n      />\r\n    </template>\r\n    <template v-slot:before>\r\n      <slot name=\"before\" />\r\n    </template>\r\n    <template v-slot:after>\r\n      <slot name=\"after\" />\r\n    </template>\r\n  </RecycleScroller>\r\n</template>\r\n\r\n<script>\r\nimport RecycleScroller from './RecycleScroller.vue'\r\nimport { props, simpleArray } from './common'\r\n\r\nexport default {\r\n  name: 'DynamicScroller',\r\n\r\n  components: {\r\n    RecycleScroller,\r\n  },\r\n\r\n  inheritAttrs: false,\r\n\r\n  provide () {\r\n    if (typeof ResizeObserver !== 'undefined') {\r\n      this.$_resizeObserver = new ResizeObserver(entries => {\r\n        for (const entry of entries) {\r\n          if (entry.target) {\r\n            const event = new CustomEvent(\r\n              'resize',\r\n              {\r\n                detail: {\r\n                  contentRect: entry.contentRect,\r\n                },\r\n              },\r\n            )\r\n            entry.target.dispatchEvent(event)\r\n          }\r\n        }\r\n      })\r\n    }\r\n\r\n    return {\r\n      vscrollData: this.vscrollData,\r\n      vscrollParent: this,\r\n      vscrollResizeObserver: this.$_resizeObserver,\r\n    }\r\n  },\r\n\r\n  emits: [\r\n    'resize',\r\n    'visible',\r\n    'vscroll:update',\r\n  ],\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      required: true,\r\n    },\r\n  },\r\n\r\n  data () {\r\n    return {\r\n      vscrollData: {\r\n        active: true,\r\n        sizes: {},\r\n        validSizes: {},\r\n        keyField: this.keyField,\r\n        simpleArray: false,\r\n      },\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    simpleArray,\r\n\r\n    itemsWithSize () {\r\n      const result = []\r\n      const { items, keyField, simpleArray } = this\r\n      const sizes = this.vscrollData.sizes\r\n      for (let i = 0; i < items.length; i++) {\r\n        const item = items[i]\r\n        const id = simpleArray ? i : item[keyField]\r\n        let size = sizes[id]\r\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\r\n          size = 0\r\n        }\r\n        result.push({\r\n          item,\r\n          id,\r\n          size,\r\n        })\r\n      }\r\n      return result\r\n    },\r\n\r\n    listeners () {\r\n      const listeners = {}\r\n      for (const key in this.$listeners) {\r\n        if (key !== 'resize' && key !== 'visible') {\r\n          listeners[key] = this.$listeners[key]\r\n        }\r\n      }\r\n      return listeners\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.forceUpdate(false)\r\n    },\r\n\r\n    simpleArray: {\r\n      handler (value) {\r\n        this.vscrollData.simpleArray = value\r\n      },\r\n      immediate: true,\r\n    },\r\n\r\n    direction (value) {\r\n      this.forceUpdate(true)\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_updates = []\r\n    this.$_undefinedSizes = 0\r\n    this.$_undefinedMap = {}\r\n  },\r\n\r\n  activated () {\r\n    this.vscrollData.active = true\r\n  },\r\n\r\n  deactivated () {\r\n    this.vscrollData.active = false\r\n  },\r\n\r\n  methods: {\r\n    onScrollerResize () {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) {\r\n        this.forceUpdate()\r\n      }\r\n      this.$emit('resize')\r\n    },\r\n\r\n    onScrollerVisible () {\r\n      this.$emit('vscroll:update', { force: false })\r\n      this.$emit('visible')\r\n    },\r\n\r\n    forceUpdate (clear = true) {\r\n      if (clear || this.simpleArray) {\r\n        this.vscrollData.validSizes = {}\r\n      }\r\n      this.$emit('vscroll:update', { force: true })\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) scroller.scrollToItem(index)\r\n    },\r\n\r\n    getItemSize (item, index = undefined) {\r\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\r\n      return this.vscrollData.sizes[id] || 0\r\n    },\r\n\r\n    scrollToBottom () {\r\n      if (this.$_scrollingToBottom) return\r\n      this.$_scrollingToBottom = true\r\n      const el = this.$el\r\n      // Item is inserted to the DOM\r\n      this.$nextTick(() => {\r\n        el.scrollTop = el.scrollHeight + 5000\r\n        // Item sizes are computed\r\n        const cb = () => {\r\n          el.scrollTop = el.scrollHeight + 5000\r\n          requestAnimationFrame(() => {\r\n            el.scrollTop = el.scrollHeight + 5000\r\n            if (this.$_undefinedSizes === 0) {\r\n              this.$_scrollingToBottom = false\r\n            } else {\r\n              requestAnimationFrame(cb)\r\n            }\r\n          })\r\n        }\r\n        requestAnimationFrame(cb)\r\n      })\r\n    },\r\n  },\r\n}\r\n</script>\r\n","<template>\r\n  <RecycleScroller\r\n    ref=\"scroller\"\r\n    :items=\"itemsWithSize\"\r\n    :min-item-size=\"minItemSize\"\r\n    :direction=\"direction\"\r\n    key-field=\"id\"\r\n    v-bind=\"$attrs\"\r\n    @resize=\"onScrollerResize\"\r\n    @visible=\"onScrollerVisible\"\r\n    v-on=\"listeners\"\r\n  >\r\n    <template v-slot=\"{ item: itemWithSize, index, active }\">\r\n      <slot\r\n        v-bind=\"{\r\n          item: itemWithSize.item,\r\n          index,\r\n          active,\r\n          itemWithSize\r\n        }\"\r\n      />\r\n    </template>\r\n    <template v-slot:before>\r\n      <slot name=\"before\" />\r\n    </template>\r\n    <template v-slot:after>\r\n      <slot name=\"after\" />\r\n    </template>\r\n  </RecycleScroller>\r\n</template>\r\n\r\n<script>\r\nimport RecycleScroller from './RecycleScroller.vue'\r\nimport { props, simpleArray } from './common'\r\n\r\nexport default {\r\n  name: 'DynamicScroller',\r\n\r\n  components: {\r\n    RecycleScroller,\r\n  },\r\n\r\n  inheritAttrs: false,\r\n\r\n  provide () {\r\n    if (typeof ResizeObserver !== 'undefined') {\r\n      this.$_resizeObserver = new ResizeObserver(entries => {\r\n        for (const entry of entries) {\r\n          if (entry.target) {\r\n            const event = new CustomEvent(\r\n              'resize',\r\n              {\r\n                detail: {\r\n                  contentRect: entry.contentRect,\r\n                },\r\n              },\r\n            )\r\n            entry.target.dispatchEvent(event)\r\n          }\r\n        }\r\n      })\r\n    }\r\n\r\n    return {\r\n      vscrollData: this.vscrollData,\r\n      vscrollParent: this,\r\n      vscrollResizeObserver: this.$_resizeObserver,\r\n    }\r\n  },\r\n\r\n  emits: [\r\n    'resize',\r\n    'visible',\r\n    'vscroll:update',\r\n  ],\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      required: true,\r\n    },\r\n  },\r\n\r\n  data () {\r\n    return {\r\n      vscrollData: {\r\n        active: true,\r\n        sizes: {},\r\n        validSizes: {},\r\n        keyField: this.keyField,\r\n        simpleArray: false,\r\n      },\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    simpleArray,\r\n\r\n    itemsWithSize () {\r\n      const result = []\r\n      const { items, keyField, simpleArray } = this\r\n      const sizes = this.vscrollData.sizes\r\n      for (let i = 0; i < items.length; i++) {\r\n        const item = items[i]\r\n        const id = simpleArray ? i : item[keyField]\r\n        let size = sizes[id]\r\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\r\n          size = 0\r\n        }\r\n        result.push({\r\n          item,\r\n          id,\r\n          size,\r\n        })\r\n      }\r\n      return result\r\n    },\r\n\r\n    listeners () {\r\n      const listeners = {}\r\n      for (const key in this.$listeners) {\r\n        if (key !== 'resize' && key !== 'visible') {\r\n          listeners[key] = this.$listeners[key]\r\n        }\r\n      }\r\n      return listeners\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.forceUpdate(false)\r\n    },\r\n\r\n    simpleArray: {\r\n      handler (value) {\r\n        this.vscrollData.simpleArray = value\r\n      },\r\n      immediate: true,\r\n    },\r\n\r\n    direction (value) {\r\n      this.forceUpdate(true)\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_updates = []\r\n    this.$_undefinedSizes = 0\r\n    this.$_undefinedMap = {}\r\n  },\r\n\r\n  activated () {\r\n    this.vscrollData.active = true\r\n  },\r\n\r\n  deactivated () {\r\n    this.vscrollData.active = false\r\n  },\r\n\r\n  methods: {\r\n    onScrollerResize () {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) {\r\n        this.forceUpdate()\r\n      }\r\n      this.$emit('resize')\r\n    },\r\n\r\n    onScrollerVisible () {\r\n      this.$emit('vscroll:update', { force: false })\r\n      this.$emit('visible')\r\n    },\r\n\r\n    forceUpdate (clear = true) {\r\n      if (clear || this.simpleArray) {\r\n        this.vscrollData.validSizes = {}\r\n      }\r\n      this.$emit('vscroll:update', { force: true })\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) scroller.scrollToItem(index)\r\n    },\r\n\r\n    getItemSize (item, index = undefined) {\r\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\r\n      return this.vscrollData.sizes[id] || 0\r\n    },\r\n\r\n    scrollToBottom () {\r\n      if (this.$_scrollingToBottom) return\r\n      this.$_scrollingToBottom = true\r\n      const el = this.$el\r\n      // Item is inserted to the DOM\r\n      this.$nextTick(() => {\r\n        el.scrollTop = el.scrollHeight + 5000\r\n        // Item sizes are computed\r\n        const cb = () => {\r\n          el.scrollTop = el.scrollHeight + 5000\r\n          requestAnimationFrame(() => {\r\n            el.scrollTop = el.scrollHeight + 5000\r\n            if (this.$_undefinedSizes === 0) {\r\n              this.$_scrollingToBottom = false\r\n            } else {\r\n              requestAnimationFrame(cb)\r\n            }\r\n          })\r\n        }\r\n        requestAnimationFrame(cb)\r\n      })\r\n    },\r\n  },\r\n}\r\n</script>\r\n","<script>\r\nexport default {\r\n  name: 'DynamicScrollerItem',\r\n\r\n  inject: [\r\n    'vscrollData',\r\n    'vscrollParent',\r\n    'vscrollResizeObserver',\r\n  ],\r\n\r\n  props: {\r\n    // eslint-disable-next-line vue/require-prop-types\r\n    item: {\r\n      required: true,\r\n    },\r\n\r\n    watchData: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    /**\r\n     * Indicates if the view is actively used to display an item.\r\n     */\r\n    active: {\r\n      type: Boolean,\r\n      required: true,\r\n    },\r\n\r\n    index: {\r\n      type: Number,\r\n      default: undefined,\r\n    },\r\n\r\n    sizeDependencies: {\r\n      type: [Array, Object],\r\n      default: null,\r\n    },\r\n\r\n    emitResize: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    tag: {\r\n      type: String,\r\n      default: 'div',\r\n    },\r\n  },\r\n\r\n  computed: {\r\n    id () {\r\n      return this.vscrollData.simpleArray ? this.index : this.item[this.vscrollData.keyField]\r\n    },\r\n\r\n    size () {\r\n      return (this.vscrollData.validSizes[this.id] && this.vscrollData.sizes[this.id]) || 0\r\n    },\r\n\r\n    finalActive () {\r\n      return this.active && this.vscrollData.active\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    watchData: 'updateWatchData',\r\n\r\n    id () {\r\n      if (!this.size) {\r\n        this.onDataUpdate()\r\n      }\r\n    },\r\n\r\n    finalActive (value) {\r\n      if (!this.size) {\r\n        if (value) {\r\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\r\n            this.vscrollParent.$_undefinedSizes++\r\n            this.vscrollParent.$_undefinedMap[this.id] = true\r\n          }\r\n        } else {\r\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\r\n            this.vscrollParent.$_undefinedSizes--\r\n            this.vscrollParent.$_undefinedMap[this.id] = false\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.vscrollResizeObserver) {\r\n        if (value) {\r\n          this.observeSize()\r\n        } else {\r\n          this.unobserveSize()\r\n        }\r\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\r\n        this.updateSize()\r\n      }\r\n    },\r\n  },\r\n\r\n  created () {\r\n    if (this.$isServer) return\r\n\r\n    this.$_forceNextVScrollUpdate = null\r\n    this.updateWatchData()\r\n\r\n    if (!this.vscrollResizeObserver) {\r\n      for (const k in this.sizeDependencies) {\r\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate)\r\n      }\r\n\r\n      this.vscrollParent.$on('vscroll:update', this.onVscrollUpdate)\r\n      this.vscrollParent.$on('vscroll:update-size', this.onVscrollUpdateSize)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    if (this.vscrollData.active) {\r\n      this.updateSize()\r\n      this.observeSize()\r\n    }\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.vscrollParent.$off('vscroll:update', this.onVscrollUpdate)\r\n    this.vscrollParent.$off('vscroll:update-size', this.onVscrollUpdateSize)\r\n    this.unobserveSize()\r\n  },\r\n\r\n  methods: {\r\n    updateSize () {\r\n      if (this.finalActive) {\r\n        if (this.$_pendingSizeUpdate !== this.id) {\r\n          this.$_pendingSizeUpdate = this.id\r\n          this.$_forceNextVScrollUpdate = null\r\n          this.$_pendingVScrollUpdate = null\r\n          this.computeSize(this.id)\r\n        }\r\n      } else {\r\n        this.$_forceNextVScrollUpdate = this.id\r\n      }\r\n    },\r\n\r\n    updateWatchData () {\r\n      if (this.watchData) {\r\n        this.$_watchData = this.$watch('data', () => {\r\n          this.onDataUpdate()\r\n        }, {\r\n          deep: true,\r\n        })\r\n      } else if (this.$_watchData) {\r\n        this.$_watchData()\r\n        this.$_watchData = null\r\n      }\r\n    },\r\n\r\n    onVscrollUpdate ({ force }) {\r\n      // If not active, sechedule a size update when it becomes active\r\n      if (!this.finalActive && force) {\r\n        this.$_pendingVScrollUpdate = this.id\r\n      }\r\n\r\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\r\n        this.updateSize()\r\n      }\r\n    },\r\n\r\n    onDataUpdate () {\r\n      this.updateSize()\r\n    },\r\n\r\n    computeSize (id) {\r\n      this.$nextTick(() => {\r\n        if (this.id === id) {\r\n          const width = this.$el.offsetWidth\r\n          const height = this.$el.offsetHeight\r\n          this.applySize(width, height)\r\n        }\r\n        this.$_pendingSizeUpdate = null\r\n      })\r\n    },\r\n\r\n    applySize (width, height) {\r\n      const size = Math.round(this.vscrollParent.direction === 'vertical' ? height : width)\r\n      if (size && this.size !== size) {\r\n        if (this.vscrollParent.$_undefinedMap[this.id]) {\r\n          this.vscrollParent.$_undefinedSizes--\r\n          this.vscrollParent.$_undefinedMap[this.id] = undefined\r\n        }\r\n        this.$set(this.vscrollData.sizes, this.id, size)\r\n        this.$set(this.vscrollData.validSizes, this.id, true)\r\n        if (this.emitResize) this.$emit('resize', this.id)\r\n      }\r\n    },\r\n\r\n    observeSize () {\r\n      if (!this.vscrollResizeObserver) return\r\n      this.vscrollResizeObserver.observe(this.$el.parentNode)\r\n      this.$el.parentNode.addEventListener('resize', this.onResize)\r\n    },\r\n\r\n    unobserveSize () {\r\n      if (!this.vscrollResizeObserver) return\r\n      this.vscrollResizeObserver.unobserve(this.$el.parentNode)\r\n      this.$el.parentNode.removeEventListener('resize', this.onResize)\r\n    },\r\n\r\n    onResize (event) {\r\n      const { width, height } = event.detail.contentRect\r\n      this.applySize(width, height)\r\n    },\r\n  },\r\n\r\n  render (h) {\r\n    return h(this.tag, this.$slots.default)\r\n  },\r\n}\r\n</script>\r\n","import config from './config'\r\n\r\nimport RecycleScroller from './components/RecycleScroller.vue'\r\nimport DynamicScroller from './components/DynamicScroller.vue'\r\nimport DynamicScrollerItem from './components/DynamicScrollerItem.vue'\r\n\r\nexport { default as IdState } from './mixins/IdState'\r\n\r\nexport {\r\n  RecycleScroller,\r\n  DynamicScroller,\r\n  DynamicScrollerItem,\r\n}\r\n\r\nfunction registerComponents (Vue, prefix) {\r\n  Vue.component(`${prefix}recycle-scroller`, RecycleScroller)\r\n  Vue.component(`${prefix}RecycleScroller`, RecycleScroller)\r\n  Vue.component(`${prefix}dynamic-scroller`, DynamicScroller)\r\n  Vue.component(`${prefix}DynamicScroller`, DynamicScroller)\r\n  Vue.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\r\n  Vue.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\r\n}\r\n\r\nconst plugin = {\r\n  // eslint-disable-next-line no-undef\r\n  version: VERSION,\r\n  install (Vue, options) {\r\n    const finalOptions = Object.assign({}, {\r\n      installComponents: true,\r\n      componentsPrefix: '',\r\n    }, options)\r\n\r\n    for (const key in finalOptions) {\r\n      if (typeof finalOptions[key] !== 'undefined') {\r\n        config[key] = finalOptions[key]\r\n      }\r\n    }\r\n\r\n    if (finalOptions.installComponents) {\r\n      registerComponents(Vue, finalOptions.componentsPrefix)\r\n    }\r\n  },\r\n}\r\n\r\nexport default plugin\r\n\r\n// Auto-install\r\nlet GlobalVue = null\r\nif (typeof window !== 'undefined') {\r\n  GlobalVue = window.Vue\r\n} else if (typeof global !== 'undefined') {\r\n  GlobalVue = global.Vue\r\n}\r\nif (GlobalVue) {\r\n  GlobalVue.use(plugin)\r\n}\r\n","import { reactive } from 'vue'\r\n\r\nexport default function ({\r\n  idProp = vm => vm.item.id,\r\n} = {}) {\r\n  const store = reactive({})\r\n\r\n  // @vue/component\r\n  return {\r\n    data () {\r\n      return {\r\n        idState: null,\r\n      }\r\n    },\r\n\r\n    created () {\r\n      this.$_id = null\r\n      if (typeof idProp === 'function') {\r\n        this.$_getId = () => idProp.call(this, this)\r\n      } else {\r\n        this.$_getId = () => this[idProp]\r\n      }\r\n      this.$watch(this.$_getId, {\r\n        handler (value) {\r\n          this.$nextTick(() => {\r\n            this.$_id = value\r\n          })\r\n        },\r\n        immediate: true,\r\n      })\r\n      this.$_updateIdState()\r\n    },\r\n\r\n    beforeUpdate () {\r\n      this.$_updateIdState()\r\n    },\r\n\r\n    methods: {\r\n      /**\r\n       * Initialize an idState\r\n       * @param {number|string} id Unique id for the data\r\n       */\r\n      $_idStateInit (id) {\r\n        const factory = this.$options.idState\r\n        if (typeof factory === 'function') {\r\n          const data = factory.call(this, this)\r\n          store[id] = data\r\n          this.$_id = id\r\n          return data\r\n        } else {\r\n          throw new Error('[mixin IdState] Missing `idState` function on component definition.')\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Ensure idState is created and up-to-date\r\n       */\r\n      $_updateIdState () {\r\n        const id = this.$_getId()\r\n        if (id == null) {\r\n          console.warn(`No id found for IdState with idProp: '${idProp}'.`)\r\n        }\r\n        if (id !== this.$_id) {\r\n          if (!store[id]) {\r\n            this.$_idStateInit(id)\r\n          }\r\n          this.idState = store[id]\r\n        }\r\n      },\r\n    },\r\n  }\r\n}\r\n"],"names":["itemsLimit","makeMap","str","expectsLowerCase","map","Object","create","list","split","i","length","val","toLowerCase","isGloballyWhitelisted","normalizeStyle","value","isArray","res","item","normalized","isString","parseStringStyle","key","isObject","listDelimiterRE","propertyDelimiterRE","cssText","ret","forEach","tmp","trim","normalizeClass","name","EMPTY_OBJ","process","env","NODE_ENV","freeze","EMPTY_ARR","NOOP","onRE","isOn","test","extend","assign","hasOwnProperty","prototype","hasOwn","call","Array","isMap","toTypeString","isFunction","isSymbol","objectToString","toString","toRawType","slice","isIntegerKey","parseInt","capitalize","fn","cache","cacheStringFunction","charAt","toUpperCase","hasChanged","oldValue","_globalThis","targetMap","WeakMap","effectStack","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","effect","options","_isEffect","isEffect","raw","active","scheduler","undefined","includes","cleanup","trackStack","push","shouldTrack","pop","resetTracking","id","uid","allowRecurse","deps","createReactiveEffect","lazy","stop","onStop","delete","pauseTracking","last","track","target","type","depsMap","get","set","Map","dep","Set","has","add","onTrack","trigger","newValue","oldTarget","effects","effectsToAdd","onTrigger","builtInSymbols","getOwnPropertyNames","filter","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","isReadonly","shallow","receiver","readonlyMap","reactiveMap","targetIsArray","Reflect","isRef","readonly","reactive","createSetter","toRaw","hadKey","Number","result","method","args","arr","this","l","apply","mutableHandlers","deleteProperty","ownKeys","readonlyHandlers","console","warn","String","shallowReadonlyHandlers","toReactive","toReadonly","toShallow","getProto","v","getPrototypeOf","get$1","isShallow","rawTarget","rawKey","wrap","has$1","size","set$1","checkIdentityKeys","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","[object Object]","done","next","createReadonlyMethod","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","createInstrumentationGetter","instrumentations","mutableCollectionHandlers","readonlyCollectionHandlers","createReactiveObject","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","isExtensible","rawType","targetTypeMap","proxy","Proxy","isReactive","isProxy","r","Boolean","__v_isRef","stack","msg","instance","component","appWarnHandler","appContext","config","warnHandler","trace","currentVNode","normalizedStack","vnode","recurseCount","parentInstance","parent","getComponentTrace","callWithErrorHandling","join","formatComponentName","warnArgs","logs","entry","postfix","isRoot","open","close","props","formatProps","formatTraceEntry","formatTrace","keys","formatProp","JSON","stringify","ErrorTypeStrings","bc","c","bm","m","bu","u","bum","um","a","da","ec","rtc","rtg","0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","err","handleError","callWithAsyncErrorHandling","then","catch","values","throwInDev","contextVNode","cur","exposedInstance","errorInfo","errorCapturedHooks","appErrorHandler","errorHandler","info","error","logError","isFlushing","isFlushPending","queue","flushIndex","pendingPreFlushCbs","activePreFlushCbs","preFlushIndex","pendingPostFlushCbs","activePostFlushCbs","postFlushIndex","resolvedPromise","Promise","resolve","currentFlushPromise","currentPreFlushParentJob","nextTick","p","bind","queueJob","job","queueFlush","flushJobs","queueCb","cb","activeQueue","pendingQueue","index","queuePostFlushCb","getId","Infinity","seen","flushPreFlushCbs","parentJob","checkRecursiveUpdates","sort","b","deduped","flushPostFlushCbs","count","Error","hmrDirtyComponents","global","self","window","__VUE_HMR_RUNTIME__","createRecord","tryWrap","isClassComponent","__vccOpts","instances","rerender","newRender","record","render","from","renderCache","update","reload","newComp","location","arg","e","currentRenderingInstance","setCurrentRenderingInstance","normalizeSuspenseSlot","s","singleChild","children","singleRoot","child","isVNode","Comment","filterSingleRoot","normalizeVNode","isRenderingCompiledSlot","setCompiledSlotRendering","n","currentScopeId","scopeIdStack","pushScopeId","popScopeId","withScopeId","ctx","renderFnWithContext","openBlock","owner","closeBlock","_c","withCtx","arguments","INITIAL_WATCHER_VALUE","doWatch","source","immediate","deep","flush","currentInstance","warnInvalidSource","getter","forceTrigger","_shallow","traverse","isUnmounted","onInvalidate","baseGetter","runner","queuePostRenderEffect","suspense","isMounted","queuePreFlushCb","recordInstanceBoundEffect","el","indexOf","splice","remove","instanceWatch","publicThis","pendingBranch","NULL_DYNAMIC_COMPONENT","Fragment","Text","blockStack","currentBlock","disableTracking","__v_isVNode","normalizeKey","normalizeRef","ref","createVNode","_createVNode","patchFlag","dynamicProps","isBlockNode","cloned","cloneVNode","normalizeChildren","class","klass","style","shapeFlag","__isSuspense","isSuspense","__isTeleport","isTeleport","__v_skip","scopeId","ssContent","ssFallback","dirs","transition","anchor","targetAnchor","staticCount","dynamicChildren","content","fallback","default","normalizeSuspenseChildren","extraProps","mergeRef","mergedProps","toMerge","existing","incoming","concat","mergeProps","createTextVNode","text","flag","slot","slotFlag","_","_ctx","mergeOptions","to","strats","optionMergeStrategies","mixins","extends","extendsOptions","getPublicInstance","publicPropertiesMap","$","$el","$data","data","$props","$attrs","attrs","$slots","slots","$refs","refs","$parent","$root","root","$emit","emit","$options","__VUE_OPTIONS_API__","__merged","globalMixins","resolveMergedOptions","$forceUpdate","$nextTick","$watch","PublicInstanceProxyHandlers","setupState","accessCache","normalizedProps","propsOptions","publicGetter","cssModule","globalProperties","__cssModules","defineProperty","enumerable","configurable","unscopables","classifyRE","Component","displayName","__file","match","inferFromRegistry","registry","components","replace","isIE","initCompat","init","ua","navigator","userAgent","msie","substring","rv","edge","getInternetExplorerVersion","globalThis","__VUE__","__VUE_DEVTOOLS_GLOBAL_HOOK__","vueStyle","numberStyle","stringStyle","keywordStyle","formatter","header","obj","__isVue","genRefFlag","formatValue","hasBody","formatInstance","blocks","createInstanceBlock","computed","extractKeys","injected","object","asRaw","Comp","extracted","isKeyOfType","opts","some","devtoolsFormatters","initCustomFormatter","initDev","script","mounted","_this","_w","offsetWidth","_h","offsetHeight","document","createElement","_resizeObject","setAttribute","onload","addResizeHandlers","appendChild","beforeUnmount","removeResizeHandlers","methods","compareAndNotify","width","height","contentDocument","defaultView","addEventListener","removeEventListener","removeChild","_withId","_hoisted_1","tabindex","_cache","$setup","createBlock","__scopeId","plugin","version","install","Vue","GlobalVue","_typeof","constructor","_defineProperties","descriptor","writable","_toConsumableArray","arr2","_arrayWithoutHoles","iter","_iterableToArray","TypeError","_nonIterableSpread","use","isSpecialBooleanAttr","camelizeRE","camelize","hyphenateRE","hyphenate","svgNS","doc","tempContainer","tempSVGContainer","nodeOps","insert","insertBefore","parentNode","tag","isSVG","is","createElementNS","createText","createTextNode","createComment","setText","node","nodeValue","setElementText","textContent","nextSibling","querySelector","selector","cloneNode","temp","innerHTML","first","firstChild","importantRE","setStyle","startsWith","setProperty","prefixed","rawName","cached","prefixCache","prefixes","autoPrefix","xlinkNS","_getNow","Date","now","createEvent","timeStamp","performance","cachedNow","reset","patchEvent","prevValue","nextValue","invokers","_vei","existingInvoker","optionsModifierRE","parseName","event","handler","initialValue","invoker","attached","originalStop","stopImmediatePropagation","_stopped","patchStopImmediatePropagation","getNow","createInvoker","nativeOnRE","patchProp","prevChildren","parentComponent","parentSuspense","unmountChildren","transitionClasses","_vtc","className","patchClass","prev","removeAttribute","patchStyle","isModelListener","tagName","shouldSetAsProp","_value","patchDOMProp","_trueValue","_falseValue","removeAttributeNS","setAttributeNS","isBoolean","patchAttr","forcePatchProp","VisibilityState","Constructor","_classCallCheck","observer","frozen","createObserver","protoProps","staticProps","destroyObserver","once","throttle","_leading","throttleOptions","leading","delay","timeout","lastState","currentArgs","throttled","state","_len","_key","clearTimeout","setTimeout","_clear","oldResult","IntersectionObserver","entries","intersectingEntry","find","isIntersecting","intersectionRatio","threshold","intersection","observe","disconnect","_ref2","_vue_visibilityState","unbind","ObserveVisibility","beforeMount","updated","_ref3","deepEqual","val1","val2","unmounted","directive","factory","regex","parents","ps","prop","getComputedStyle","getPropertyValue","scroll","overflow","HTMLElement","SVGElement","scrollingElement","documentElement","module","exports","Scrollparent","items","required","keyField","direction","validator","simpleArray","supportsPassive","ResizeObserver","directives","emits","itemSize","minItemSize","sizeField","typeField","buffer","pageMode","prerender","emitUpdate","pool","totalSize","ready","hoverKey","sizes","current","accumulator","field","computedMinSize","$_computedMinItemSize","watch","updateVisibleItems","applyPageMode","created","$_startIndex","$_endIndex","$_views","$_unusedViews","$_scrollDirty","$_lastUpdateScrollPosition","$_prerender","removeListeners","addView","view","shallowReactive","position","nr","used","unuseView","fake","unusedViews","unusedPool","handleResize","handleScroll","requestAnimationFrame","_this2","continuous","$_refreshTimout","handleVisibilityChange","isVisible","boundingClientRect","_this3","checkItem","startIndex","endIndex","checkPositionDiff","views","getScroll","positionDiff","start","end","oldI","Math","ceil","itemsLimitError","$_continuous","findIndex","unusedIndex","$_sortTimer","sortViews","getListenerTarget","ScrollParent","body","scrollState","isVertical","bounds","getBoundingClientRect","boundsSize","top","left","innerHeight","innerWidth","scrollTop","clientHeight","scrollLeft","clientWidth","addListeners","listenerTarget","passive","scrollToItem","scrollToPosition","log","_this4","viewA","viewB","_createBlock","before","_renderSlot","onMouseenter","onMouseleave","after","_hoisted_2","onNotify","RecycleScroller","inheritAttrs","provide","$_resizeObserver","CustomEvent","detail","contentRect","dispatchEvent","vscrollData","vscrollParent","vscrollResizeObserver","validSizes","itemsWithSize","$_undefinedMap","listeners","$listeners","forceUpdate","$_updates","$_undefinedSizes","activated","deactivated","onScrollerResize","scroller","onScrollerVisible","force","getItemSize","scrollToBottom","$_scrollingToBottom","scrollHeight","_mergeProps","onResize","onVisible","_toHandlers","itemWithSize","inject","watchData","sizeDependencies","emitResize","finalActive","onDataUpdate","observeSize","unobserveSize","$_pendingVScrollUpdate","updateSize","$isServer","$_forceNextVScrollUpdate","updateWatchData","k","$on","onVscrollUpdate","onVscrollUpdateSize","$off","$_pendingSizeUpdate","computeSize","$_watchData","applySize","round","$set","unobserve","h","VERSION","finalOptions","installComponents","componentsPrefix","prefix","DynamicScroller","DynamicScrollerItem","registerComponents","idProp","vm","store","idState","$_id","$_getId","$_updateIdState","beforeUpdate","$_idStateInit"],"mappings":"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"}